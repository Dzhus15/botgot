{"file_contents":{"config.py":{"content":"import os\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Config:\n    \"\"\"Configuration class for the Telegram bot\"\"\"\n    \n    # Telegram Bot Configuration\n    TELEGRAM_BOT_TOKEN: str = os.getenv(\"TELEGRAM_BOT_TOKEN\", \"\")\n    \n    # Veo API Configuration\n    VEO_API_KEY: str = os.getenv(\"VEO_API_KEY\", \"\")\n    VEO_API_BASE_URL: str = \"https://api.kie.ai\"\n    \n    # Payment Configuration\n    YOOKASSA_API_KEY: str = os.getenv(\"YOOKASSA_API_KEY\", \"\")\n    YOOKASSA_SHOP_ID: str = os.getenv(\"YOOKASSA_SHOP_ID\", \"\")\n    YOOKASSA_WEBHOOK_SECRET: str = os.getenv(\"YOOKASSA_WEBHOOK_SECRET\", \"\")\n    TELEGRAM_PAYMENTS_TOKEN: str = os.getenv(\"TELEGRAM_PAYMENTS_TOKEN\", \"\")\n    \n    # Admin Configuration\n    ADMIN_USER_ID: int = 1864913930\n    INITIAL_ADMIN_CREDITS: int = 100\n    \n    # Database Configuration  \n    DATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"\")\n    \n    # Rate Limiting Configuration\n    RATE_LIMIT_MESSAGES: int = 100  # messages per period (increased)\n    RATE_LIMIT_WINDOW: int = 60   # seconds\n    \n    # Video Generation Configuration\n    DEFAULT_MODEL: str = \"veo3_fast\"  # Cost-efficient model\n    DEFAULT_ASPECT_RATIO: str = \"16:9\"\n    \n    # Credits Configuration\n    VIDEO_GENERATION_COST: int = 10  # credits per video\n    \n    def __post_init__(self):\n        \"\"\"Validate configuration after initialization\"\"\"\n        if not self.TELEGRAM_BOT_TOKEN:\n            raise ValueError(\"TELEGRAM_BOT_TOKEN environment variable is required\")\n        \n        if not self.VEO_API_KEY:\n            raise ValueError(\"VEO_API_KEY environment variable is required\")\n","size_bytes":1610},"main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom aiohttp import web\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\nfrom aiogram.fsm.storage.memory import MemoryStorage\n\nfrom config import Config\nfrom database.database import init_database\nfrom handlers import start, generate, payments, admin\nfrom middlewares.rate_limit import RateLimitMiddleware\nfrom webhook_server import init_webhook_server\nfrom utils.async_logger import setup_async_logging\n\n# Setup async logging for better performance\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nsetup_async_logging()\nlogger = logging.getLogger(__name__)\n\nasync def start_bot_polling():\n    \"\"\"Start Telegram bot polling in background\"\"\"\n    try:\n        # Initialize configuration\n        config = Config()\n        logger.info(f\"Starting bot with Veo model: {config.DEFAULT_MODEL}\")\n        \n        # Initialize bot and dispatcher\n        bot = Bot(\n            token=config.TELEGRAM_BOT_TOKEN,\n            default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n        )\n        \n        dp = Dispatcher(storage=MemoryStorage())\n        \n        # Register middleware\n        dp.message.middleware(RateLimitMiddleware())\n        dp.callback_query.middleware(RateLimitMiddleware())\n        \n        # Register handlers\n        dp.include_router(start.router)\n        dp.include_router(generate.router)\n        dp.include_router(payments.router)\n        dp.include_router(admin.router)\n        \n        logger.info(\"Bot starting polling...\")\n        \n        # Start polling\n        await dp.start_polling(bot, skip_updates=True)\n        \n    except Exception as e:\n        logger.error(f\"Error starting bot: {e}\")\n        import traceback\n        logger.error(traceback.format_exc())\n        raise\n\nasync def main():\n    \"\"\"Main function to start the web server on port 5000\"\"\"\n    try:\n        # Initialize database\n        await init_database()\n        logger.info(\"Database initialized successfully\")\n        \n        # Initialize webhook web application\n        app = await init_webhook_server()\n        \n        # Start bot polling in background\n        bot_task = asyncio.create_task(start_bot_polling())\n        logger.info(\"Bot polling started in background...\")\n        \n        # Start payment monitoring in background\n        from utils.payment_monitor import payment_monitor\n        monitor_task = asyncio.create_task(payment_monitor.start_monitoring())\n        logger.info(\"Payment monitoring started in background...\")\n        \n        # Start web server on port 5000 (main process)\n        runner = web.AppRunner(app)\n        await runner.setup()\n        \n        site = web.TCPSite(runner, '0.0.0.0', 5000)\n        await site.start()\n        \n        logger.info(\"Web server started on port 5000\")\n        logger.info(\"Application endpoints:\")\n        logger.info(\"  POST /webhook/veo-complete/{task_id} - Veo completion callbacks\")\n        logger.info(\"  POST /webhook/yookassa - YooKassa payment notifications\")\n        logger.info(\"  GET /health - Health check\")\n        \n        # Keep the server running indefinitely\n        try:\n            # Create a future that will never complete to keep the event loop running\n            stop_event = asyncio.Event()\n            await stop_event.wait()\n        except asyncio.CancelledError:\n            logger.info(\"Application shutdown requested\")\n        finally:\n            # Cleanup tasks\n            bot_task.cancel()\n            monitor_task.cancel()\n            await runner.cleanup()\n        \n    except Exception as e:\n        logger.error(f\"Error starting application: {e}\")\n        import traceback\n        logger.error(traceback.format_exc())\n        raise\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logger.info(\"Application stopped by user\")\n    except Exception as e:\n        logger.error(f\"Fatal error: {e}\")\n","size_bytes":4026},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":143},"replit.md":{"content":"# Overview\n\nThis is a Telegram bot that generates AI videos using Google's Veo 3 API through the kie.ai platform. The bot provides text-to-video and image-to-video generation capabilities with a credit-based payment system. Users can purchase credits using Telegram Stars or traditional payment methods (YooKassa), and each video generation costs 10 credits. The bot includes comprehensive admin functionality for user management and broadcasting.\n\n# Recent Changes\n\n**2025-08-26**: \n- ✅ Fixed tokenomics: 399₽ package now gives 50 credits (5 video generations)\n- ✅ Fixed database connection issues in payment monitoring system\n- ✅ Increased rate limiting from 15 to 100 messages per minute\n- ✅ Added manual credit management tool (admin_tools/credit_manager.py)\n- ✅ Hybrid database system: SQLite (current) + PostgreSQL ready for production\n- ✅ User 848867375 compensated with 35 credits for incorrect 399₽ package\n- ✅ **NEW**: Secure admin credit management system with production-only restrictions\n- ✅ **NEW**: Automatic user notifications when admin grants credits with custom comments\n- ✅ **NEW**: Complete audit trail for all admin credit operations\n- ✅ **NEW**: Fully automated database migration system - data auto-transfers on every deploy\n- ✅ **NEW**: Smart migration detection - only migrates when needed\n- ✅ **SECURITY**: Fixed all critical payment vulnerabilities - HMAC verification, rate limiting, race conditions\n- ✅ **SECURITY**: Enhanced Telegram Stars payment validation against fraud attempts\n- ✅ **SECURITY**: Strengthened webhook IP validation (removed localhost bypass)\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework and Communication\nBuilt on aiogram (asynchronous Telegram bot framework) with handler-based routing for different bot commands and interactions. Uses inline keyboards for user navigation and FSM (Finite State Machine) for managing user conversation states during video generation and payment flows.\n\n## Database Layer\nHybrid database system with SQLite-based persistence layer using aiosqlite (currently active) and PostgreSQL support ready for production deployment. Automatically switches to PostgreSQL when asyncpg is available and DATABASE_URL is configured. Core entities include:\n- Users: Telegram ID, credits balance, admin status, user metadata\n- Transactions: Credit purchases and spending with audit trail\n- Video Generations: Task tracking for AI video creation\n- Admin Logs: Activity tracking for administrative actions\n\nDefault admin user (ID: 1864913930) receives 100 credits and admin privileges on first registration. Database persists data during redeploys when using PostgreSQL.\n\n## Credit System and Payments\nDual payment integration supporting:\n- Telegram Stars for in-app purchases\n- YooKassa for traditional payment methods (cards, SBP)\nFixed pricing at 10 credits per video generation with configurable credit packages.\n\n## AI Video Generation\nIntegration with Veo 3 API through kie.ai platform supporting:\n- Text-to-video generation from prompts\n- Image-to-video generation (with image upload handling)\n- Configurable models (default: veo3_fast for cost efficiency)\n- Standard 16:9 aspect ratio output\n\n## Security and Rate Limiting\n- **Enhanced Payment Security**: HMAC signature verification for YooKassa webhooks with configurable secret\n- **Fraud Prevention**: Multi-layer validation for Telegram Stars payments including amount verification and user ID matching\n- **Rate Limiting**: Dual-layer protection - user rate limiting (100 msg/60s) + webhook rate limiting (10 req/60s per IP)\n- **Race Condition Protection**: Atomic payment processing with database constraints to prevent duplicate credit grants\n- **Webhook Security**: Strict IP validation for YooKassa webhooks without localhost bypass vulnerabilities\n- Environment variable configuration for all API keys and secrets\n- Input validation for prompts with content filtering\n- Parameterized database queries for SQL injection prevention\n- Comprehensive logging without sensitive data exposure\n\n## Administrative Features\nAdmin-only functionality includes:\n- User statistics and analytics dashboard\n- Broadcast messaging system with media support\n- **Advanced credit management system:**\n  - Check user credits balance by Telegram ID\n  - Grant credits with custom reason/comment (production only)\n  - Automatic user notifications with admin comments\n  - Complete audit logging and transaction records\n  - Environment-aware security (local vs production)\n- Activity monitoring and comprehensive audit trails\n- Payment verification and manual credit recovery tools\n- **Database Migration Tools:**\n  - Automated data transfer from SQLite to PostgreSQL\n  - Complete backup and recovery system for data loss scenarios\n  - One-command migration: `bash migrate_data.sh`\n  - Safe data export/import with conflict resolution\n\n## Error Handling and Resilience\nComprehensive error handling with user-friendly messages, structured logging with rotation, graceful degradation for API failures, and async architecture for handling concurrent requests.\n\n# External Dependencies\n\n## Primary APIs\n- **Telegram Bot API**: Core bot functionality via aiogram library\n- **Veo 3 AI API**: Video generation through kie.ai platform (api.kie.ai)\n- **YooKassa Payment API**: Russian payment processing for cards and SBP\n- **Telegram Payments API**: Telegram Stars integration\n\n## Database\n- **SQLite**: Local persistent storage with async operations via aiosqlite (development)\n- **PostgreSQL**: Production database with automatic migration tools\n- **Migration System**: Universal tool for transferring data between environments\n\n## Python Libraries\n- **aiogram**: Telegram bot framework with async support\n- **aiosqlite**: Async SQLite database operations\n- **aiohttp**: HTTP client for API integrations\n- **logging**: Built-in Python logging with rotation\n\n## Infrastructure\n- **Replit Environment**: Hosting platform with secrets management\n- **File Storage**: Local filesystem for database and logs\n\n## Authentication Requirements\n- TELEGRAM_BOT_TOKEN: Bot authentication with Telegram\n- VEO_API_KEY: Access to Veo 3 video generation API\n- YOOKASSA_API_KEY & YOOKASSA_SHOP_ID: Payment processing credentials\n- TELEGRAM_PAYMENTS_TOKEN: Telegram Stars payment processing","size_bytes":6376},"api_integrations/payment_api.py":{"content":"import aiohttp\nimport logging\nimport uuid\nimport hmac\nimport hashlib\nfrom typing import Optional\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass PaymentAPI:\n    \"\"\"Payment API integrations\"\"\"\n    \n    def __init__(self):\n        self.yookassa_api_key = config.YOOKASSA_API_KEY\n        self.yookassa_shop_id = config.YOOKASSA_SHOP_ID\n        self.yookassa_base_url = \"https://api.yookassa.ru/v3\"\n    \n    async def create_yookassa_payment(\n        self, \n        amount: int, \n        description: str, \n        user_id: int,\n        package_id: str,\n        payment_method: str = \"bank_card\"\n    ) -> Optional[str]:\n        \"\"\"Create YooKassa payment and return payment URL\"\"\"\n        \n        if not self.yookassa_api_key or not self.yookassa_shop_id:\n            logger.error(\"YooKassa credentials not configured\")\n            return None\n        \n        try:\n            import base64\n            \n            # Prepare authentication\n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\",\n                \"Idempotence-Key\": str(uuid.uuid4())\n            }\n            \n            # Payment data with receipt (required by 54-FZ)\n            payment_data = {\n                \"amount\": {\n                    \"value\": f\"{amount}.00\",\n                    \"currency\": \"RUB\"\n                },\n                \"confirmation\": {\n                    \"type\": \"redirect\",\n                    \"return_url\": \"https://t.me/VideoAnalizAiBot?start=payment_success\"\n                },\n                \"capture\": True,\n                \"description\": description,\n                \"metadata\": {\n                    \"user_id\": str(user_id),\n                    \"package_id\": package_id,\n                    \"source\": \"telegram_bot\"\n                },\n                \"payment_method_data\": {\n                    \"type\": payment_method\n                },\n                \"receipt\": {\n                    \"customer\": {\n                        \"email\": \"customer@example.com\"\n                    },\n                    \"items\": [\n                        {\n                            \"description\": description,\n                            \"quantity\": \"1.00\",\n                            \"amount\": {\n                                \"value\": f\"{amount}.00\",\n                                \"currency\": \"RUB\"\n                            },\n                            \"vat_code\": 1  # НДС не облагается\n                        }\n                    ]\n                }\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.yookassa_base_url}/payments\",\n                    headers=headers,\n                    json=payment_data,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        \n                        confirmation_url = result.get(\"confirmation\", {}).get(\"confirmation_url\")\n                        payment_id = result.get(\"id\")\n                        \n                        if confirmation_url and payment_id:\n                            logger.info(f\"YooKassa payment created: {payment_id} for user {user_id}\")\n                            \n                            # Store payment info for webhook processing\n                            # In a real implementation, you'd store this in database\n                            # await self.store_pending_payment(payment_id, user_id, package_id, amount)\n                            \n                            return confirmation_url\n                        else:\n                            logger.error(f\"Invalid YooKassa response: {result}\")\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"YooKassa API error {response.status}: {error_text}\")\n                        \n        except Exception as e:\n            logger.error(f\"Error creating YooKassa payment: {e}\")\n        \n        return None\n    \n    async def verify_yookassa_payment(self, payment_id: str) -> dict:\n        \"\"\"Verify YooKassa payment status\"\"\"\n        \n        if not self.yookassa_api_key or not self.yookassa_shop_id:\n            logger.error(\"YooKassa credentials not configured\")\n            return {\"status\": \"error\", \"message\": \"Not configured\"}\n        \n        try:\n            import base64\n            \n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.get(\n                    f\"{self.yookassa_base_url}/payments/{payment_id}\",\n                    headers=headers,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        return {\n                            \"status\": result.get(\"status\"),\n                            \"amount\": result.get(\"amount\", {}).get(\"value\"),\n                            \"currency\": result.get(\"amount\", {}).get(\"currency\"),\n                            \"metadata\": result.get(\"metadata\", {}),\n                            \"paid\": result.get(\"status\") == \"succeeded\"\n                        }\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"YooKassa verify error {response.status}: {error_text}\")\n                        return {\"status\": \"error\", \"message\": error_text}\n                        \n        except Exception as e:\n            logger.error(f\"Error verifying YooKassa payment {payment_id}: {e}\")\n            return {\"status\": \"error\", \"message\": str(e)}\n    \n    def verify_webhook_signature(self, payload: bytes, signature: str) -> bool:\n        \"\"\"Verify YooKassa webhook HMAC signature for security\"\"\"\n        if not config.YOOKASSA_WEBHOOK_SECRET:\n            logger.warning(\"YOOKASSA_WEBHOOK_SECRET not configured - skipping signature verification\")\n            return True  # Allow if secret not configured (backward compatibility)\n        \n        if not signature:\n            logger.error(\"Missing webhook signature\")\n            return False\n        \n        try:\n            # YooKassa sends signature as \"sha256=<hash>\"\n            if not signature.startswith('sha256='):\n                logger.error(f\"Invalid signature format: {signature[:20]}...\")\n                return False\n            \n            expected_signature = signature[7:]  # Remove \"sha256=\" prefix\n            \n            # Calculate HMAC\n            calculated_signature = hmac.new(\n                config.YOOKASSA_WEBHOOK_SECRET.encode('utf-8'),\n                payload,\n                hashlib.sha256\n            ).hexdigest()\n            \n            # Secure comparison\n            is_valid = hmac.compare_digest(expected_signature, calculated_signature)\n            \n            if not is_valid:\n                logger.error(\"Webhook signature verification failed\")\n            \n            return is_valid\n            \n        except Exception as e:\n            logger.error(f\"Error verifying webhook signature: {e}\")\n            return False\n    \n    async def process_yookassa_webhook(self, webhook_data: dict, raw_payload: bytes = None, signature: str = None) -> bool:\n        \"\"\"Process YooKassa webhook notification with enhanced security\"\"\"\n        \n        try:\n            # Verify HMAC signature if provided\n            if raw_payload is not None and signature is not None:\n                if not self.verify_webhook_signature(raw_payload, signature):\n                    logger.error(\"Webhook signature verification failed - potential fraud attempt\")\n                    return False\n            # Validate webhook data structure\n            if not isinstance(webhook_data, dict):\n                logger.error(\"Invalid webhook data type\")\n                return False\n            \n            event_type = webhook_data.get(\"event\")\n            payment_object = webhook_data.get(\"object\", {})\n            \n            logger.info(f\"Processing YooKassa webhook: event={event_type}\")\n            \n            if event_type == \"payment.succeeded\":\n                # Validate required fields\n                payment_id = payment_object.get(\"id\")\n                if not payment_id:\n                    logger.error(\"Missing payment ID in webhook\")\n                    return False\n                \n                metadata = payment_object.get(\"metadata\", {})\n                amount_data = payment_object.get(\"amount\", {})\n                amount_value = amount_data.get(\"value\")\n                currency = amount_data.get(\"currency\")\n                \n                # Validate currency\n                if currency != \"RUB\":\n                    logger.error(f\"Invalid currency in payment {payment_id}: {currency}\")\n                    return False\n                \n                user_id = metadata.get(\"user_id\")\n                package_id = metadata.get(\"package_id\")\n                source = metadata.get(\"source\")\n                \n                # Validate metadata\n                if not all([user_id, package_id, amount_value]):\n                    logger.error(f\"Missing required fields in payment {payment_id}\")\n                    return False\n                \n                # Validate source\n                if source != \"telegram_bot\":\n                    logger.warning(f\"Unexpected payment source: {source}\")\n                \n                # Process successful payment\n                success = await self._process_successful_card_payment(\n                    user_id=int(user_id),\n                    package_id=package_id,\n                    payment_id=payment_id,\n                    amount=float(amount_value)\n                )\n                \n                logger.info(f\"YooKassa payment {payment_id} processed: {success}\")\n                return success\n                \n            elif event_type == \"payment.canceled\":\n                payment_id = payment_object.get(\"id\")\n                logger.info(f\"Payment canceled: {payment_id}\")\n                return True\n                \n            else:\n                logger.info(f\"Ignoring webhook event: {event_type}\")\n                return True\n                \n        except ValueError as e:\n            logger.error(f\"Data validation error in YooKassa webhook: {e}\")\n        except Exception as e:\n            logger.error(f\"Unexpected error processing YooKassa webhook: {e}\")\n        \n        return False\n    \n    async def _process_successful_card_payment(\n        self, \n        user_id: int, \n        package_id: str, \n        payment_id: str, \n        amount: float\n    ) -> bool:\n        \"\"\"Process successful card payment with duplicate protection\"\"\"\n        \n        try:\n            from handlers.payments import CREDIT_PACKAGES\n            from database.database import db\n            from database.models import Transaction, TransactionType, PaymentMethod\n            \n            # SECURITY: Atomic check and creation to prevent race conditions\n            # We'll rely on database constraints to prevent duplicates\n            \n            package = CREDIT_PACKAGES.get(package_id)\n            if not package:\n                logger.error(f\"Package {package_id} not found\")\n                return False\n            \n            # Validate payment amount matches package price\n            expected_amount = float(package['price_rub'])\n            if abs(float(amount) - expected_amount) > 0.01:  # Allow small floating point differences\n                logger.error(f\"Payment amount mismatch: expected {expected_amount}, got {amount}\")\n                return False\n            \n            # Calculate total credits (including bonus)\n            total_credits = package['credits']\n            if package.get('bonus'):\n                total_credits += package['bonus']\n            \n            # Verify user exists and get current credits\n            user = await db.get_user(user_id)\n            if not user:\n                logger.error(f\"User {user_id} not found for payment {payment_id}\")\n                return False\n            \n            # Create transaction record FIRST (atomic operation with duplicate check)\n            transaction = Transaction(\n                user_id=user_id,\n                type=TransactionType.CREDIT_PURCHASE,\n                amount=total_credits,\n                description=f\"YooKassa: {package['title']} ({payment_id})\",\n                payment_method=PaymentMethod.YOOKASSA,\n                payment_id=payment_id\n            )\n            \n            # Try to create transaction - will fail if payment_id already exists (race condition protection)\n            transaction_created = await db.create_transaction(transaction)\n            if not transaction_created:\n                # Check if it was a duplicate payment (race condition)\n                if await db.payment_exists(payment_id):\n                    logger.warning(f\"Duplicate payment processing attempt detected: {payment_id}\")\n                    return False  # Not an error, just already processed\n                else:\n                    logger.error(f\"Failed to create transaction record for payment {payment_id}\")\n                    return False\n            \n            # Update user credits\n            new_credits = user.credits + total_credits\n            credits_updated = await db.update_user_credits(user_id, new_credits)\n            \n            if not credits_updated:\n                logger.error(f\"Failed to update credits for user {user_id}, payment {payment_id}\")\n                # Note: Transaction is already recorded, manual intervention may be needed\n                return False\n            \n            # Notify user about successful payment\n            try:\n                await self._notify_payment_success(user_id, total_credits, new_credits)\n            except Exception as e:\n                logger.error(f\"Failed to notify user {user_id} about payment success: {e}\")\n                # Don't return False here - payment was processed successfully\n            \n            logger.info(f\"Payment processed successfully: user={user_id}, payment_id={payment_id}, credits={total_credits}\")\n            return True\n                \n        except ValueError as e:\n            logger.error(f\"Validation error processing payment {payment_id}: {e}\")\n        except Exception as e:\n            logger.error(f\"Unexpected error processing payment {payment_id}: {e}\")\n        \n        return False\n    \n    async def _notify_payment_success(self, user_id: int, credits_added: int, total_credits: int):\n        \"\"\"Notify user about successful payment\"\"\"\n        bot = None\n        try:\n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            \n            from keyboards.inline import get_main_menu_keyboard\n            \n            success_text = f\"\"\"\n✅ <b>Оплата успешно завершена!</b>\n\n💰 <b>Добавлено кредитов:</b> {credits_added}\n💳 <b>Ваш баланс:</b> {total_credits} кредитов\n\nТеперь вы можете генерировать видео! 🎬\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_id,\n                text=success_text,\n                parse_mode=\"HTML\",\n                reply_markup=get_main_menu_keyboard()\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error notifying payment success to user {user_id}: {e}\")\n        finally:\n            # Properly close bot session to prevent unclosed client session error\n            if bot:\n                await bot.session.close()\n","size_bytes":16468},"api_integrations/veo_api.py":{"content":"import aiohttp\nimport asyncio\nimport logging\nimport os\nfrom typing import Optional\nfrom config import Config\nfrom database.database import db\nfrom database.models import GenerationType\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass VeoAPI:\n    \"\"\"Veo API integration for video generation\"\"\"\n    \n    def __init__(self):\n        self.base_url = config.VEO_API_BASE_URL\n        self.api_key = config.VEO_API_KEY\n        \n    async def generate_video(\n        self, \n        task_id: str,\n        prompt: str, \n        generation_type: GenerationType,\n        user_id: int,\n        image_file_id: Optional[str] = None\n    ) -> bool:\n        \"\"\"Generate video using Veo API\"\"\"\n        \n        try:\n            headers = {\n                \"Authorization\": f\"Bearer {self.api_key}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            # Prepare request data according to API documentation\n            request_data = {\n                \"prompt\": prompt,\n                \"model\": config.DEFAULT_MODEL,\n                \"aspectRatio\": config.DEFAULT_ASPECT_RATIO,\n                \"enableFallback\": True,  # Enable fallback for higher success rates\n            }\n            \n            # Callback URL temporarily disabled due to port conflict\n            # repl_slug = os.getenv('REPL_SLUG')\n            # repl_owner = os.getenv('REPL_OWNER')\n            # if repl_slug and repl_owner:\n            #     callback_url = f\"https://{repl_slug}.{repl_owner}.repl.co/webhook/veo-complete/{task_id}\"\n            #     request_data[\"callBackUrl\"] = callback_url\n            #     logger.info(f\"Using callback URL: {callback_url}\")\n            \n            # Handle image-to-video\n            if generation_type == GenerationType.IMAGE_TO_VIDEO and image_file_id:\n                # Upload image using kie.ai File Upload API\n                image_url = await self._upload_telegram_image(image_file_id)\n                if image_url:\n                    request_data[\"imageUrls\"] = [image_url]\n                    logger.info(f\"Using uploaded image URL: {image_url}\")\n                else:\n                    logger.error(f\"Failed to upload image for task {task_id}\")\n                    await db.update_video_generation(\n                        task_id, \"failed\", \n                        error_message=\"Failed to upload image to kie.ai\"\n                    )\n                    return False\n            \n            # Log request details for debugging\n            logger.info(f\"Sending API request for task {task_id}\")\n            logger.info(f\"URL: {self.base_url}/api/v1/veo/generate\")\n            logger.info(f\"Prompt: {prompt[:100]}...\")\n            \n            # Make API request\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/api/v1/veo/generate\",\n                    headers=headers,\n                    json=request_data,\n                    timeout=aiohttp.ClientTimeout(total=30)\n                ) as response:\n                    \n                    logger.info(f\"API Response status: {response.status}\")\n                    response_text = await response.text()\n                    logger.info(f\"API Response: {response_text[:500]}...\")\n                    \n                    if response.status == 200:\n                        try:\n                            result = await response.json()\n                            logger.info(f\"Parsed response: {result}\")\n                            \n                            if result.get(\"code\") == 200:\n                                veo_task_id = result.get(\"data\", {}).get(\"taskId\")\n                                if veo_task_id:\n                                    # Update database with Veo task ID and set processing status\n                                    await db.update_veo_task_id(task_id, veo_task_id)\n                                    \n                                    # Start polling for completion\n                                    asyncio.create_task(\n                                        self._poll_video_status(task_id, veo_task_id, user_id)\n                                    )\n                                    \n                                    logger.info(f\"Video generation started: {task_id} -> {veo_task_id}\")\n                                    return True\n                                else:\n                                    logger.error(f\"No task ID in response: {result}\")\n                            else:\n                                error_msg = result.get(\"msg\", \"Unknown API error\")\n                                logger.error(f\"API error for task {task_id}: {error_msg}\")\n                                await db.update_video_generation(\n                                    task_id, \"failed\", \n                                    error_message=error_msg\n                                )\n                        except Exception as json_error:\n                            logger.error(f\"JSON parsing error: {json_error}\")\n                            logger.error(f\"Raw response: {response_text}\")\n                    else:\n                        logger.error(f\"HTTP error {response.status} for task {task_id}: {response_text}\")\n                        await db.update_video_generation(\n                            task_id, \"failed\", \n                            error_message=f\"HTTP {response.status}: {response_text[:100]}\"\n                        )\n                        \n        except asyncio.TimeoutError:\n            logger.error(f\"Timeout error for task {task_id}\")\n            await db.update_video_generation(\n                task_id, \"failed\", \n                error_message=\"Request timeout\"\n            )\n        except Exception as e:\n            logger.error(f\"Exception in video generation for task {task_id}: {e}\")\n            await db.update_video_generation(\n                task_id, \"failed\", \n                error_message=str(e)\n            )\n        \n        return False\n    \n    async def _upload_telegram_image(self, file_id: str) -> Optional[str]:\n        \"\"\"Upload Telegram image using kie.ai File Upload API\"\"\"\n        try:\n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            \n            # Download file from Telegram\n            file_info = await bot.get_file(file_id)\n            if not file_info.file_path:\n                logger.error(f\"No file path for image {file_id}\")\n                return None\n            \n            file_data = await bot.download_file(file_info.file_path)\n            if not file_data:\n                logger.error(f\"Failed to download file data for {file_id}\")\n                return None\n            \n            # Convert file data to bytes\n            file_bytes = file_data.read()\n            \n            # Upload to kie.ai File Upload API\n            upload_url = f\"https://kieai.redpandaai.co/api/file-stream-upload\"\n            \n            # Prepare multipart form data\n            form_data = aiohttp.FormData()\n            form_data.add_field('file', \n                              file_bytes, \n                              filename=f\"{file_id}.jpg\",\n                              content_type='image/jpeg')\n            form_data.add_field('uploadPath', 'telegram-images')\n            form_data.add_field('fileName', f\"{file_id}.jpg\")\n            \n            headers = {\n                \"Authorization\": f\"Bearer {self.api_key}\"\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    upload_url,\n                    headers=headers,\n                    data=form_data,\n                    timeout=aiohttp.ClientTimeout(total=30)\n                ) as response:\n                    logger.info(f\"File upload response status: {response.status}\")\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        logger.info(f\"File upload response: {result}\")\n                        \n                        if result.get(\"success\") and result.get(\"data\"):\n                            # File Upload API returns downloadUrl field\n                            file_url = result[\"data\"].get(\"downloadUrl\") or result[\"data\"].get(\"fileUrl\")\n                            if file_url:\n                                logger.info(f\"Image uploaded successfully: {file_id} -> {file_url}\")\n                                return file_url\n                            else:\n                                logger.error(f\"No download URL in response: {result}\")\n                                return None\n                    \n                    # Log error response\n                    error_text = await response.text()\n                    logger.error(f\"File upload failed: {response.status} - {error_text}\")\n                    return None\n            \n        except Exception as e:\n            logger.error(f\"Error uploading image {file_id}: {e}\")\n            return None\n    \n    async def _poll_video_status(self, task_id: str, veo_task_id: str, user_id: int):\n        \"\"\"Poll video generation status with multiple endpoint attempts\"\"\"\n        max_attempts = 60  # 5 minutes with 5-second intervals (video generation takes time)\n        attempt = 0\n        \n        logger.info(f\"Starting polling for task {task_id} with Veo ID {veo_task_id}\")\n        \n        while attempt < max_attempts:\n            try:\n                await asyncio.sleep(5)  # Wait 5 seconds between checks\n                \n                # Try multiple possible endpoints for status checking\n                status_result = await self._get_video_status_multiple_endpoints(veo_task_id)\n                \n                if status_result:\n                    logger.info(f\"Status result for {task_id}: {status_result}\")\n                    \n                    status = status_result.get(\"status\")\n                    \n                    if status == \"completed\" or status == \"success\":\n                        video_url = status_result.get(\"video_url\") or status_result.get(\"videoUrl\") or status_result.get(\"url\")\n                        \n                        if video_url:\n                            await db.update_video_generation(\n                                task_id, \"completed\", video_url=video_url\n                            )\n                            \n                            # Notify user\n                            await self._notify_user_completion(user_id, video_url, task_id)\n                            logger.info(f\"Video generation completed: {task_id}\")\n                            return\n                        \n                    elif status == \"failed\" or status == \"error\":\n                        error_msg = status_result.get(\"error\") or status_result.get(\"message\") or \"Generation failed\"\n                        await db.update_video_generation(\n                            task_id, \"failed\", error_message=error_msg\n                        )\n                        \n                        # Notify user of failure\n                        await self._notify_user_failure(user_id, error_msg)\n                        logger.error(f\"Video generation failed: {task_id} - {error_msg}\")\n                        return\n                else:\n                    logger.warning(f\"No status result for {task_id}, attempt {attempt + 1}\")\n                \n                attempt += 1\n                \n            except Exception as e:\n                logger.error(f\"Error polling status for {task_id}: {e}\")\n                attempt += 1\n        \n        # Timeout - but don't mark as failed immediately\n        logger.warning(f\"Polling timeout for {task_id}, but task might still be processing\")\n        \n        # Just log timeout, don't mark as failed in case task is still processing\n        # The user can check manually or we can implement a longer polling strategy\n    \n    async def _get_video_status_multiple_endpoints(self, veo_task_id: str) -> Optional[dict]:\n        \"\"\"Try multiple possible endpoints for video status\"\"\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # Use the correct Veo API endpoint according to official docs\n        # The primary endpoint uses GET with taskId as query parameter\n        record_info_url = f\"{self.base_url}/api/v1/veo/record-info?taskId={veo_task_id}\"\n        \n        async with aiohttp.ClientSession() as session:\n            try:\n                # Primary endpoint: GET with taskId as query parameter (official docs)\n                async with session.get(\n                    record_info_url,\n                    headers=headers,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    logger.info(f\"Trying GET {record_info_url}, status: {response.status}\")\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        logger.info(f\"Success response from record-info: {result}\")\n                        \n                        # Handle official Veo API response format\n                        if result.get(\"code\") == 200 and result.get(\"data\"):\n                            data = result[\"data\"]\n                            success_flag = data.get(\"successFlag\")\n                            \n                            # Convert successFlag to standard status format\n                            if success_flag == 0:\n                                # Still processing\n                                return {\"status\": \"processing\"}\n                            elif success_flag == 1:\n                                # Success - extract video URLs from correct location\n                                response_data = data.get(\"response\", {})\n                                result_urls = response_data.get(\"resultUrls\", [])\n                                \n                                if result_urls:\n                                    # resultUrls is already an array\n                                    video_url = result_urls[0] if result_urls and len(result_urls) > 0 else None\n                                    \n                                    if video_url:\n                                        return {\"status\": \"completed\", \"video_url\": video_url}\n                                \n                                logger.error(f\"Success status but no video URLs found. Response: {data}\")\n                            elif success_flag in [2, 3]:\n                                # Failed\n                                error_msg = data.get(\"errorMessage\", \"Video generation failed\")\n                                return {\"status\": \"failed\", \"error\": error_msg}\n                    else:\n                        text = await response.text()\n                        logger.warning(f\"Status {response.status} from record-info: {text[:200]}\")\n                        \n            except Exception as e:\n                logger.error(f\"Error checking status with official endpoint: {e}\")\n                \n            # Fallback: try alternative endpoints if main one fails\n            fallback_endpoints = [\n                f\"{self.base_url}/api/v1/veo/record-detail?taskId={veo_task_id}\",  # Alternative with query param\n                f\"{self.base_url}/api/v1/veo/status/{veo_task_id}\",  # GET with task ID in path\n            ]\n            \n            for endpoint in fallback_endpoints:\n                try:\n                    # For other endpoints, use GET\n                    async with session.get(\n                        endpoint,\n                        headers=headers,\n                        timeout=aiohttp.ClientTimeout(total=10)\n                    ) as response:\n                        \n                        logger.info(f\"Trying GET {endpoint}: status {response.status}\")\n                        \n                        if response.status == 200:\n                            result = await response.json()\n                            logger.info(f\"Success response from {endpoint}: {result}\")\n                            \n                            # Handle different response structures\n                            if \"data\" in result:\n                                return result[\"data\"]\n                            elif \"result\" in result:\n                                return result[\"result\"]\n                            else:\n                                return result\n                                \n                        elif response.status == 404:\n                            continue  # Try next endpoint\n                        else:\n                            text = await response.text()\n                            logger.warning(f\"Status {response.status} from {endpoint}: {text[:200]}\")\n                            \n                except Exception as e:\n                    logger.debug(f\"Error with endpoint {endpoint}: {e}\")\n                    continue\n        \n        return None\n    \n    async def _notify_user_completion(self, user_id: int, video_url: str, task_id: str):\n        \"\"\"Notify user about video completion\"\"\"\n        bot = None\n        try:\n            logger.info(f\"Notifying user {user_id} about completion: {task_id}\")\n            \n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            from keyboards.inline import get_main_menu_keyboard\n            \n            await bot.send_message(\n                chat_id=user_id,\n                text=f\"✅ <b>Ваше видео готово!</b>\\n\\n\"\n                     f\"🎬 Видео успешно сгенерировано и готово к просмотру.\\n\"\n                     f\"📥 Скачайте видео по ссылке ниже:\",\n                parse_mode=\"HTML\",\n                reply_markup=get_main_menu_keyboard()\n            )\n            \n            # Send video file\n            if video_url and video_url.startswith(\"http\"):\n                await bot.send_video(\n                    chat_id=user_id,\n                    video=video_url,\n                    caption=\"🎬 Ваше AI-видео готово!\"\n                )\n            \n        except Exception as e:\n            logger.error(f\"Error notifying user {user_id}: {e}\")\n        finally:\n            # Properly close bot session\n            if bot:\n                await bot.session.close()\n    \n    async def _notify_user_failure(self, user_id: int, error_message: str):\n        \"\"\"Notify user about generation failure\"\"\"\n        bot = None\n        try:\n            logger.info(f\"Notifying user {user_id} about failure: {error_message}\")\n            \n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            from keyboards.inline import get_main_menu_keyboard\n            \n            user_friendly_error = self._get_user_friendly_error(error_message)\n            \n            await bot.send_message(\n                chat_id=user_id,\n                text=f\"❌ <b>Ошибка генерации видео</b>\\n\\n\"\n                     f\"К сожалению, не удалось сгенерировать ваше видео.\\n\\n\"\n                     f\"💡 <b>Причина:</b> {user_friendly_error}\\n\\n\"\n                     f\"💰 Кредиты возвращены на ваш счет.\\n\"\n                     f\"🔄 Попробуйте еще раз с другим запросом.\",\n                parse_mode=\"HTML\",\n                reply_markup=get_main_menu_keyboard()\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error notifying user failure {user_id}: {e}\")\n        finally:\n            # Properly close bot session\n            if bot:\n                await bot.session.close()\n    \n    def _get_user_friendly_error(self, error_message: str) -> str:\n        \"\"\"Convert technical error to user-friendly message\"\"\"\n        error_lower = error_message.lower()\n        \n        if \"timeout\" in error_lower:\n            return \"Превышено время ожидания. Сервис перегружен.\"\n        elif \"content policies\" in error_lower or \"flagged\" in error_lower:\n            return \"Запрос нарушает правила контента. Измените описание.\"\n        elif \"insufficient credits\" in error_lower:\n            return \"Недостаточно кредитов на счете.\"\n        elif \"rate limit\" in error_lower:\n            return \"Слишком много запросов. Подождите немного.\"\n        else:\n            return \"Техническая ошибка сервиса. Попробуйте позже.\"\n","size_bytes":20971},"database/database.py":{"content":"import aiosqlite\nimport logging\nimport os\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom config import Config\nfrom database.models import User, Transaction, VideoGeneration, AdminLog, UserStatus, TransactionType, PaymentMethod, GenerationType\nimport time\nfrom functools import lru_cache\n\n# Try to import asyncpg for PostgreSQL, fallback to SQLite\ntry:\n    import asyncpg\n    POSTGRES_AVAILABLE = True\nexcept ImportError:\n    POSTGRES_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\nconfig = Config()\n\nclass Database:\n    \"\"\"Database manager for PostgreSQL and SQLite operations\"\"\"\n    \n    def __init__(self, database_url: Optional[str] = None, sqlite_path: Optional[str] = None):\n        self.database_url = database_url or os.getenv('DATABASE_URL')\n        self.sqlite_path = sqlite_path or \"bot_database.db\" \n        self.use_postgres = POSTGRES_AVAILABLE and self.database_url is not None\n        \n        # Connection pool for PostgreSQL (performance optimization)\n        self._postgres_pool = None\n        \n        # In-memory cache for frequent queries (performance optimization)\n        self._user_cache = {}\n        self._cache_ttl = 300  # 5 minutes cache TTL\n        \n        if self.use_postgres:\n            logger.info(\"Using PostgreSQL database with connection pooling\")\n        else:\n            logger.info(\"Using SQLite database as fallback\")\n    \n    async def get_postgres_pool(self):\n        \"\"\"Get or create PostgreSQL connection pool\"\"\"\n        if self._postgres_pool is None:\n            self._postgres_pool = await asyncpg.create_pool(\n                self.database_url,\n                min_size=2,\n                max_size=10,\n                command_timeout=30\n            )\n        return self._postgres_pool\n    \n    async def get_postgres_connection(self):\n        \"\"\"Get PostgreSQL connection from pool\"\"\"\n        pool = await self.get_postgres_pool()\n        return pool\n    \n    def get_sqlite_connection(self):\n        \"\"\"Get SQLite connection\"\"\"\n        return aiosqlite.connect(self.sqlite_path)\n    \n    async def close_pool(self):\n        \"\"\"Close PostgreSQL connection pool\"\"\"\n        if self._postgres_pool:\n            await self._postgres_pool.close()\n            self._postgres_pool = None\n    \n    async def create_tables(self):\n        \"\"\"Create all necessary tables\"\"\"\n        if self.use_postgres:\n            pool = await self.get_postgres_pool()\n            async with pool.acquire() as conn:\n                # Users table  \n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS users (\n                        telegram_id BIGINT PRIMARY KEY,\n                        username TEXT,\n                        first_name TEXT,\n                        last_name TEXT,\n                        credits INTEGER DEFAULT 0,\n                        status TEXT DEFAULT 'regular',\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                    )\n                ''')\n                \n                # Transactions table\n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS transactions (\n                        id SERIAL PRIMARY KEY,\n                        user_id BIGINT,\n                        type TEXT NOT NULL,\n                        amount INTEGER NOT NULL,\n                        description TEXT,\n                        payment_method TEXT,\n                        payment_id TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Video generations table\n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS video_generations (\n                        id SERIAL PRIMARY KEY,\n                        user_id BIGINT,\n                        task_id TEXT UNIQUE,\n                        veo_task_id TEXT,\n                        prompt TEXT NOT NULL,\n                        generation_type TEXT NOT NULL,\n                        image_url TEXT,\n                        model TEXT DEFAULT 'veo3_fast',\n                        aspect_ratio TEXT DEFAULT '16:9',\n                        status TEXT DEFAULT 'pending',\n                        video_url TEXT,\n                        error_message TEXT,\n                        credits_spent INTEGER DEFAULT 0,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        completed_at TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Admin logs table\n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS admin_logs (\n                        id SERIAL PRIMARY KEY,\n                        admin_id BIGINT,\n                        action TEXT NOT NULL,\n                        target_user_id BIGINT,\n                        description TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Create performance indexes\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_payment_id ON transactions(payment_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_created_at ON transactions(created_at)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_user_id ON video_generations(user_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_task_id ON video_generations(task_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_status ON video_generations(status)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_admin_logs_admin_id ON admin_logs(admin_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_admin_logs_target_user ON admin_logs(target_user_id)')\n                \n                logger.info(\"Database tables and indexes created successfully (PostgreSQL)\")\n        else:\n            # SQLite version\n            async with self.get_sqlite_connection() as db:\n                # Users table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS users (\n                        telegram_id INTEGER PRIMARY KEY,\n                        username TEXT,\n                        first_name TEXT,\n                        last_name TEXT,\n                        credits INTEGER DEFAULT 0,\n                        status TEXT DEFAULT 'regular',\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                    )\n                ''')\n                \n                # Transactions table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS transactions (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        user_id INTEGER,\n                        type TEXT NOT NULL,\n                        amount INTEGER NOT NULL,\n                        description TEXT,\n                        payment_method TEXT,\n                        payment_id TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Video generations table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS video_generations (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        user_id INTEGER,\n                        task_id TEXT UNIQUE,\n                        veo_task_id TEXT,\n                        prompt TEXT NOT NULL,\n                        generation_type TEXT NOT NULL,\n                        image_url TEXT,\n                        model TEXT DEFAULT 'veo3_fast',\n                        aspect_ratio TEXT DEFAULT '16:9',\n                        status TEXT DEFAULT 'pending',\n                        video_url TEXT,\n                        error_message TEXT,\n                        credits_spent INTEGER DEFAULT 0,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        completed_at TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Admin logs table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS admin_logs (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        admin_id INTEGER,\n                        action TEXT NOT NULL,\n                        target_user_id INTEGER,\n                        description TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Add veo_task_id column if it doesn't exist (migration)\n                try:\n                    await db.execute('ALTER TABLE video_generations ADD COLUMN veo_task_id TEXT')\n                    await db.commit()\n                    logger.info(\"Added veo_task_id column to video_generations table\")\n                except Exception:\n                    # Column already exists\n                    pass\n                \n                await db.commit()\n                logger.info(\"Database tables created successfully (SQLite)\")\n    \n    # User operations\n    def _is_cache_valid(self, cache_time: float) -> bool:\n        \"\"\"Check if cache entry is still valid\"\"\"\n        return time.time() - cache_time < self._cache_ttl\n    \n    def _cache_user(self, user: User):\n        \"\"\"Cache user data\"\"\"\n        self._user_cache[user.telegram_id] = {\n            'user': user,\n            'time': time.time()\n        }\n    \n    def _get_cached_user(self, telegram_id: int) -> Optional[User]:\n        \"\"\"Get user from cache if valid\"\"\"\n        if telegram_id in self._user_cache:\n            cache_entry = self._user_cache[telegram_id]\n            if self._is_cache_valid(cache_entry['time']):\n                return cache_entry['user']\n            else:\n                # Remove expired cache entry\n                del self._user_cache[telegram_id]\n        return None\n    \n    async def get_user(self, telegram_id: int) -> Optional[User]:\n        \"\"\"Get user by telegram ID with caching\"\"\"\n        # Check cache first\n        cached_user = self._get_cached_user(telegram_id)\n        if cached_user:\n            return cached_user\n        \n        if self.use_postgres:\n            pool = await self.get_postgres_pool()\n            async with pool.acquire() as conn:\n                row = await conn.fetchrow(\n                    \"SELECT * FROM users WHERE telegram_id = $1\",\n                    telegram_id\n                )\n                if row:\n                    user = User(\n                        telegram_id=row[0],\n                        username=row[1],\n                        first_name=row[2],\n                        last_name=row[3],\n                        credits=row[4],\n                        status=UserStatus(row[5]),\n                        created_at=row[6],\n                        updated_at=row[7]\n                    )\n                    # Cache the user\n                    self._cache_user(user)\n                    return user\n                return None\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute(\n                    \"SELECT * FROM users WHERE telegram_id = ?\",\n                    (telegram_id,)\n                )\n                row = await cursor.fetchone()\n                if row:\n                    return User(\n                        telegram_id=row[0],\n                        username=row[1],\n                        first_name=row[2],\n                        last_name=row[3],\n                        credits=row[4],\n                        status=UserStatus(row[5]),\n                        created_at=datetime.fromisoformat(row[6]) if row[6] else None,\n                        updated_at=datetime.fromisoformat(row[7]) if row[7] else None\n                    )\n                return None\n    \n    async def create_user(self, user: User) -> bool:\n        \"\"\"Create a new user\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                    ''', \n                        user.telegram_id,\n                        user.username,\n                        user.first_name,\n                        user.last_name,\n                        user.credits,\n                        user.status.value,\n                        user.created_at or datetime.now(),\n                        user.updated_at or datetime.now()\n                    )\n                    logger.info(f\"Created user {user.telegram_id}\")\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n                    ''', (\n                        user.telegram_id,\n                        user.username,\n                        user.first_name,\n                        user.last_name,\n                        user.credits,\n                        user.status.value,\n                        (user.created_at or datetime.now()).isoformat(),\n                        (user.updated_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    logger.info(f\"Created user {user.telegram_id}\")\n                    return True\n        except Exception as e:\n            logger.error(f\"Error creating user {user.telegram_id}: {e}\")\n            return False\n    \n    async def update_user_credits(self, telegram_id: int, credits: int) -> bool:\n        \"\"\"Update user credits\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute(\n                        \"UPDATE users SET credits = $1, updated_at = $2 WHERE telegram_id = $3\",\n                        credits, datetime.now(), telegram_id\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute(\n                        \"UPDATE users SET credits = ?, updated_at = ? WHERE telegram_id = ?\",\n                        (credits, datetime.now().isoformat(), telegram_id)\n                    )\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error updating credits for user {telegram_id}: {e}\")\n            return False\n    \n    # Transaction operations\n    async def create_transaction(self, transaction: Transaction) -> bool:\n        \"\"\"Create a new transaction\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                    ''', \n                        transaction.user_id,\n                        transaction.type.value,\n                        transaction.amount,\n                        transaction.description,\n                        transaction.payment_method.value if transaction.payment_method is not None else None,\n                        transaction.payment_id,\n                        transaction.created_at or datetime.now()\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES (?, ?, ?, ?, ?, ?, ?)\n                    ''', (\n                        transaction.user_id,\n                        transaction.type.value,\n                        transaction.amount,\n                        transaction.description,\n                        transaction.payment_method.value if transaction.payment_method is not None else None,\n                        transaction.payment_id,\n                        (transaction.created_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error creating transaction: {e}\")\n            return False\n    \n    async def payment_exists(self, payment_id: str) -> bool:\n        \"\"\"Check if payment_id already exists in transactions\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    result = await conn.fetchval(\n                        \"SELECT COUNT(*) FROM transactions WHERE payment_id = $1\",\n                        payment_id\n                    )\n                    return result > 0 if result else False\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    cursor = await db.execute(\n                        \"SELECT COUNT(*) FROM transactions WHERE payment_id = ?\",\n                        (payment_id,)\n                    )\n                    result = await cursor.fetchone()\n                    return result[0] > 0 if result else False\n        except Exception as e:\n            logger.error(f\"Error checking payment existence: {e}\")\n            return False\n    \n    # Video generation operations\n    async def create_video_generation(self, generation: VideoGeneration) -> bool:\n        \"\"\"Create a new video generation record\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, credits_spent, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\n                    ''', \n                        generation.user_id,\n                        generation.task_id,\n                        generation.veo_task_id,\n                        generation.prompt,\n                        generation.generation_type.value if generation.generation_type is not None else 'text_to_video',\n                        generation.image_url,\n                        generation.model,\n                        generation.aspect_ratio,\n                        generation.status,\n                        generation.credits_spent,\n                        generation.created_at or datetime.now()\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, credits_spent, created_at)\n                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n                    ''', (\n                        generation.user_id,\n                        generation.task_id,\n                        generation.veo_task_id,\n                        generation.prompt,\n                        generation.generation_type.value if generation.generation_type is not None else 'text_to_video',\n                        generation.image_url,\n                        generation.model,\n                        generation.aspect_ratio,\n                        generation.status,\n                        generation.credits_spent,\n                        (generation.created_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error creating video generation record: {e}\")\n            return False\n    \n    async def update_video_generation(self, task_id: str, status: str, video_url: Optional[str] = None, error_message: Optional[str] = None) -> bool:\n        \"\"\"Update video generation status\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    completed_at = datetime.now() if status in ['completed', 'failed'] else None\n                    await conn.execute('''\n                        UPDATE video_generations \n                        SET status = $1, video_url = $2, error_message = $3, completed_at = $4\n                        WHERE task_id = $5\n                    ''', status, video_url, error_message, completed_at, task_id)\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    completed_at = datetime.now().isoformat() if status in ['completed', 'failed'] else None\n                    await db.execute('''\n                        UPDATE video_generations \n                        SET status = ?, video_url = ?, error_message = ?, completed_at = ?\n                        WHERE task_id = ?\n                    ''', (status, video_url, error_message, completed_at, task_id))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error updating video generation {task_id}: {e}\")\n            return False\n    \n    async def update_veo_task_id(self, task_id: str, veo_task_id: str) -> bool:\n        \"\"\"Update the Veo API task ID for a generation\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        UPDATE video_generations \n                        SET veo_task_id = $1, status = 'processing'\n                        WHERE task_id = $2\n                    ''', veo_task_id, task_id)\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        UPDATE video_generations \n                        SET veo_task_id = ?, status = 'processing'\n                        WHERE task_id = ?\n                    ''', (veo_task_id, task_id))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error updating veo_task_id for {task_id}: {e}\")\n            return False\n            \n    async def get_video_generation_by_veo_id(self, veo_task_id: str) -> Optional[VideoGeneration]:\n        \"\"\"Get video generation by Veo task ID\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                row = await conn.fetchrow(\n                    \"SELECT * FROM video_generations WHERE veo_task_id = $1\",\n                    veo_task_id\n                )\n                if row:\n                    return VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=row[13],\n                        completed_at=row[14]\n                    )\n                return None\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute(\n                    \"SELECT * FROM video_generations WHERE veo_task_id = ?\",\n                    (veo_task_id,)\n                )\n                row = await cursor.fetchone()\n                if row:\n                    return VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=datetime.fromisoformat(row[13]) if row[13] else None,\n                        completed_at=datetime.fromisoformat(row[14]) if row[14] else None\n                    )\n                return None\n            \n    async def get_processing_generations(self) -> List[VideoGeneration]:\n        \"\"\"Get all processing video generations that have veo_task_id\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                rows = await conn.fetch('''\n                    SELECT * FROM video_generations \n                    WHERE status = 'processing' AND veo_task_id IS NOT NULL\n                ''')\n                generations = []\n                for row in rows:\n                    generation = VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=row[13],\n                        completed_at=row[14]\n                    )\n                    generations.append(generation)\n                return generations\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute('''\n                    SELECT * FROM video_generations \n                    WHERE status = 'processing' AND veo_task_id IS NOT NULL\n                ''')\n                rows = await cursor.fetchall()\n                generations = []\n                for row in rows:\n                    generation = VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=datetime.fromisoformat(row[13]) if row[13] else None,\n                        completed_at=datetime.fromisoformat(row[14]) if row[14] else None\n                    )\n                    generations.append(generation)\n                return generations\n    \n    # Admin operations\n    async def get_user_statistics(self) -> dict:\n        \"\"\"Get user statistics for admin\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                # Total users\n                total_users = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n                \n                # Active users (generated video in last 30 days)\n                active_users = await conn.fetchval('''\n                    SELECT COUNT(DISTINCT user_id) FROM video_generations \n                    WHERE created_at >= NOW() - INTERVAL '30 days'\n                ''')\n                \n                # Total credits in system\n                total_credits = await conn.fetchval(\"SELECT SUM(credits) FROM users\") or 0\n                \n                # Total videos generated\n                total_videos = await conn.fetchval(\"SELECT COUNT(*) FROM video_generations WHERE status = 'completed'\")\n                \n                return {\n                    'total_users': total_users or 0,\n                    'active_users': active_users or 0,\n                    'total_credits': total_credits or 0,\n                    'total_videos': total_videos or 0\n                }\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                # Total users\n                cursor = await db.execute(\"SELECT COUNT(*) FROM users\")\n                result = await cursor.fetchone()\n                total_users = result[0] if result else 0\n                \n                # Active users (generated video in last 30 days)\n                cursor = await db.execute('''\n                    SELECT COUNT(DISTINCT user_id) FROM video_generations \n                    WHERE created_at >= datetime('now', '-30 days')\n                ''')\n                result = await cursor.fetchone()\n                active_users = result[0] if result else 0\n                \n                # Total credits in system\n                cursor = await db.execute(\"SELECT SUM(credits) FROM users\")\n                result = await cursor.fetchone()\n                total_credits = result[0] if result else 0\n                \n                # Total videos generated\n                cursor = await db.execute(\"SELECT COUNT(*) FROM video_generations WHERE status = 'completed'\")\n                result = await cursor.fetchone()\n                total_videos = result[0] if result else 0\n                \n                return {\n                    'total_users': total_users,\n                    'active_users': active_users,\n                    'total_credits': total_credits,\n                    'total_videos': total_videos\n                }\n    \n    async def get_all_user_ids(self) -> List[int]:\n        \"\"\"Get all user IDs for broadcasting\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                rows = await conn.fetch(\"SELECT telegram_id FROM users WHERE status != 'banned'\")\n                return [row[0] for row in rows]\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute(\"SELECT telegram_id FROM users WHERE status != 'banned'\")\n                rows = await cursor.fetchall()\n                return [row[0] for row in rows]\n    \n    async def log_admin_action(self, log: AdminLog) -> bool:\n        \"\"\"Log admin action\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES ($1, $2, $3, $4, $5)\n                    ''', \n                        log.admin_id,\n                        log.action,\n                        log.target_user_id,\n                        log.description,\n                        log.created_at or datetime.now()\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES (?, ?, ?, ?, ?)\n                    ''', (\n                        log.admin_id,\n                        log.action,\n                        log.target_user_id,\n                        log.description,\n                        (log.created_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error logging admin action: {e}\")\n            return False\n\n# Create database instance directly\ndb = Database()\n\nasync def init_database():\n    \"\"\"Initialize database with tables and admin user\"\"\"\n    await db.create_tables()\n    \n    # Create admin user if not exists\n    admin_user = await db.get_user(config.ADMIN_USER_ID)\n    if not admin_user:\n        admin_user = User(\n            telegram_id=config.ADMIN_USER_ID,\n            credits=config.INITIAL_ADMIN_CREDITS,\n            status=UserStatus.ADMIN\n        )\n        await db.create_user(admin_user)\n        \n        # Log admin creation\n        transaction = Transaction(\n            user_id=config.ADMIN_USER_ID,\n            type=TransactionType.ADMIN_GRANT,\n            amount=config.INITIAL_ADMIN_CREDITS,\n            description=\"Initial admin credits\"\n        )\n        await db.create_transaction(transaction)\n        \n        logger.info(f\"Admin user created with {config.INITIAL_ADMIN_CREDITS} credits\")\n","size_bytes":35362},"database/models.py":{"content":"from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom enum import Enum\n\nclass UserStatus(Enum):\n    REGULAR = \"regular\"\n    ADMIN = \"admin\"\n    BANNED = \"banned\"\n\nclass TransactionType(Enum):\n    CREDIT_PURCHASE = \"credit_purchase\"\n    CREDIT_SPEND = \"credit_spend\"\n    ADMIN_GRANT = \"admin_grant\"\n\nclass PaymentMethod(Enum):\n    TELEGRAM_STARS = \"telegram_stars\"\n    YOOKASSA = \"yookassa\"\n\nclass GenerationType(Enum):\n    TEXT_TO_VIDEO = \"text_to_video\"\n    IMAGE_TO_VIDEO = \"image_to_video\"\n\n@dataclass\nclass User:\n    \"\"\"User model\"\"\"\n    telegram_id: int\n    username: Optional[str] = None\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    credits: int = 0\n    status: UserStatus = UserStatus.REGULAR\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.updated_at is None:\n            self.updated_at = datetime.now()\n\n@dataclass\nclass Transaction:\n    \"\"\"Transaction model for credit operations\"\"\"\n    id: Optional[int] = None\n    user_id: Optional[int] = None\n    type: Optional[TransactionType] = None\n    amount: int = 0\n    description: str = \"\"\n    payment_method: Optional[PaymentMethod] = None\n    payment_id: Optional[str] = None\n    created_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n@dataclass\nclass VideoGeneration:\n    \"\"\"Video generation task model\"\"\"\n    id: Optional[int] = None\n    user_id: Optional[int] = None\n    task_id: str = \"\"\n    veo_task_id: Optional[str] = None  # API task ID from Veo\n    prompt: str = \"\"\n    generation_type: Optional[GenerationType] = None\n    image_url: Optional[str] = None\n    model: str = \"veo3_fast\"\n    aspect_ratio: str = \"16:9\"\n    status: str = \"pending\"  # pending, processing, completed, failed\n    video_url: Optional[str] = None\n    error_message: Optional[str] = None\n    credits_spent: int = 0\n    created_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n@dataclass\nclass AdminLog:\n    \"\"\"Admin action log model\"\"\"\n    id: Optional[int] = None\n    admin_id: Optional[int] = None\n    action: str = \"\"\n    target_user_id: Optional[int] = None\n    description: str = \"\"\n    created_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n","size_bytes":2673},"handlers/admin.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nimport asyncio\n\nfrom database.database import db\nfrom database.models import AdminLog, UserStatus\nfrom keyboards.inline import get_admin_menu_keyboard, get_back_to_admin_keyboard\nfrom config import Config\nfrom utils.logger import get_logger\nfrom admin_tools.credit_management import check_user_credits, grant_user_credits, emergency_credit_restore\n\nlogger = get_logger(__name__)\nrouter = Router()\nconfig = Config()\n\nclass AdminStates(StatesGroup):\n    waiting_broadcast_message = State()\n    waiting_payment_id = State()\n    waiting_user_id_for_notification = State()\n    waiting_user_id_for_credits = State()\n    waiting_credits_amount = State()\n    waiting_credits_reason = State()\n\nasync def is_admin(user_id: int) -> bool:\n    \"\"\"Check if user is admin\"\"\"\n    user = await db.get_user(user_id)\n    return user and user.status == UserStatus.ADMIN\n\n@router.message(Command(\"admin\"))\nasync def admin_command(message: Message, state: FSMContext):\n    \"\"\"Handle /admin command\"\"\"\n    if not await is_admin(message.from_user.id):\n        await message.answer(\"❌ У вас нет прав администратора.\")\n        return\n    \n    await state.clear()\n    \n    admin_text = \"\"\"\n👑 <b>Панель администратора</b>\n\nДобро пожаловать в админ-панель! Выберите действие:\n\n📊 <b>Статистика пользователей</b> - просмотр статистики\n💰 <b>Проверить кредиты</b> - проверить баланс пользователя по ID\n💎 <b>Выдать кредиты</b> - начислить кредиты пользователю (только на production)\n📢 <b>Рассылка сообщений</b> - отправка сообщений всем пользователям\n🔍 <b>Проверка платежа</b> - проверить статус и начислить кредиты\n\nВыберите действие из меню ниже:\n    \"\"\"\n    \n    await message.answer(\n        admin_text,\n        reply_markup=get_admin_menu_keyboard()\n    )\n\n@router.callback_query(F.data == \"admin_stats\")\nasync def admin_statistics(callback: CallbackQuery):\n    \"\"\"Show admin statistics\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    try:\n        stats = await db.get_user_statistics()\n        \n        stats_text = f\"\"\"\n📊 <b>Статистика пользователей</b>\n\n👥 <b>Общее количество пользователей:</b> {stats['total_users']}\n🔥 <b>Активные пользователи (30 дней):</b> {stats['active_users']}\n💰 <b>Всего кредитов в системе:</b> {stats['total_credits']:,}\n🎬 <b>Всего создано видео:</b> {stats['total_videos']}\n\n📈 <b>Активность:</b>\n• Конверсия в активных: {(stats['active_users'] / max(stats['total_users'], 1) * 100):.1f}%\n• Среднее кредитов на пользователя: {(stats['total_credits'] / max(stats['total_users'], 1)):.1f}\n        \"\"\"\n        \n        await callback.message.edit_text(\n            stats_text,\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        \n        # Log admin action\n        admin_log = AdminLog(\n            admin_id=callback.from_user.id,\n            action=\"view_statistics\",\n            description=\"Viewed user statistics\"\n        )\n        await db.log_admin_action(admin_log)\n        \n    except Exception as e:\n        logger.error(f\"Error getting admin statistics: {e}\")\n        await callback.message.edit_text(\n            \"❌ Ошибка получения статистики\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n    \n    await callback.answer()\n\n@router.callback_query(F.data == \"admin_broadcast\")\nasync def admin_broadcast_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start broadcast message creation\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    broadcast_text = \"\"\"\n📢 <b>Рассылка сообщений</b>\n\nОтправьте сообщение, которое хотите разослать всем пользователям.\n\n💡 <b>Вы можете отправить:</b>\n• Текстовое сообщение\n• Сообщение с фото\n• Переслать сообщение из другого чата\n\n⚠️ <b>Внимание:</b> Рассылка будет отправлена ВСЕМ активным пользователям бота!\n\nОтправьте сообщение для рассылки:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        broadcast_text,\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_broadcast_message)\n    await callback.answer()\n\n@router.message(AdminStates.waiting_broadcast_message)\nasync def admin_broadcast_process(message: Message, state: FSMContext):\n    \"\"\"Process broadcast message\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    await state.clear()\n    \n    # Get all user IDs\n    user_ids = await db.get_all_user_ids()\n    total_users = len(user_ids)\n    \n    if total_users == 0:\n        await message.answer(\n            \"❌ Нет пользователей для рассылки.\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        return\n    \n    # Confirm broadcast\n    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [\n            InlineKeyboardButton(text=\"✅ Подтвердить рассылку\", callback_data=\"confirm_broadcast\"),\n            InlineKeyboardButton(text=\"❌ Отменить\", callback_data=\"admin_menu\")\n        ]\n    ])\n    \n    await message.answer(\n        f\"📢 <b>Подтверждение рассылки</b>\\n\\n\"\n        f\"👥 <b>Получателей:</b> {total_users} пользователей\\n\"\n        f\"📝 <b>Тип сообщения:</b> {'С фото' if message.photo else 'Текстовое'}\\n\\n\"\n        f\"⚠️ Вы уверены, что хотите отправить рассылку?\",\n        reply_markup=confirm_keyboard\n    )\n    \n    # Store message for broadcast\n    await state.update_data(\n        broadcast_message_id=message.message_id,\n        total_users=total_users\n    )\n\n@router.callback_query(F.data == \"confirm_broadcast\")\nasync def admin_broadcast_confirm(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Confirm and execute broadcast\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    state_data = await state.get_data()\n    broadcast_message_id = state_data.get('broadcast_message_id')\n    total_users = state_data.get('total_users', 0)\n    \n    if not broadcast_message_id:\n        await callback.answer(\"❌ Сообщение для рассылки не найдено\")\n        return\n    \n    await state.clear()\n    \n    # Start broadcast\n    progress_msg = await callback.message.edit_text(\n        f\"📢 <b>Рассылка началась...</b>\\n\\n\"\n        f\"👥 Всего пользователей: {total_users}\\n\"\n        f\"✅ Отправлено: 0\\n\"\n        f\"❌ Ошибок: 0\\n\\n\"\n        f\"⏳ Ожидайте завершения...\"\n    )\n    \n    # Get user IDs and start broadcast\n    user_ids = await db.get_all_user_ids()\n    success_count = 0\n    error_count = 0\n    \n    # Import bot instance\n    from aiogram import Bot\n    from config import Config\n    bot_config = Config()\n    bot = Bot(token=bot_config.TELEGRAM_BOT_TOKEN)\n    \n    for i, user_id in enumerate(user_ids):\n        try:\n            # Forward the broadcast message\n            await bot.forward_message(\n                chat_id=user_id,\n                from_chat_id=callback.from_user.id,\n                message_id=broadcast_message_id\n            )\n            success_count += 1\n            \n            # Update progress every 10 users\n            if (i + 1) % 10 == 0 or i == len(user_ids) - 1:\n                try:\n                    await progress_msg.edit_text(\n                        f\"📢 <b>Рассылка в процессе...</b>\\n\\n\"\n                        f\"👥 Всего пользователей: {total_users}\\n\"\n                        f\"✅ Отправлено: {success_count}\\n\"\n                        f\"❌ Ошибок: {error_count}\\n\"\n                        f\"📊 Прогресс: {((i + 1) / total_users * 100):.1f}%\"\n                    )\n                except:\n                    pass  # Ignore edit errors\n            \n            # Small delay to avoid rate limits\n            await asyncio.sleep(0.05)\n            \n        except Exception as e:\n            error_count += 1\n            logger.warning(f\"Broadcast error for user {user_id}: {e}\")\n            \n            # Longer delay on errors\n            await asyncio.sleep(0.1)\n    \n    # Final results\n    await progress_msg.edit_text(\n        f\"📢 <b>Рассылка завершена!</b>\\n\\n\"\n        f\"👥 Всего пользователей: {total_users}\\n\"\n        f\"✅ Успешно отправлено: {success_count}\\n\"\n        f\"❌ Ошибок доставки: {error_count}\\n\"\n        f\"📊 Успешность: {(success_count / max(total_users, 1) * 100):.1f}%\",\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    \n    # Log admin action\n    admin_log = AdminLog(\n        admin_id=callback.from_user.id,\n        action=\"broadcast_message\",\n        description=f\"Broadcast sent to {success_count}/{total_users} users\"\n    )\n    await db.log_admin_action(admin_log)\n    \n    logger.info(f\"Broadcast completed: {success_count}/{total_users} users\")\n    await callback.answer(\"✅ Рассылка завершена!\")\n\n@router.callback_query(F.data == \"admin_check_payment\")\nasync def admin_check_payment(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Check payment status manually\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    await callback.message.edit_text(\n        \"🔍 <b>Проверка платежа</b>\\n\\n\"\n        \"Введите ID платежа ЮКассы для проверки и начисления кредитов:\\n\\n\"\n        \"💡 ID платежа можно найти в логах бота или личном кабинете ЮКассы\",\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_payment_id)\n    await callback.answer()\n\n@router.message(AdminStates.waiting_payment_id)\nasync def process_payment_check(message: Message, state: FSMContext):\n    \"\"\"Process payment ID and check status\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    payment_id = message.text.strip()\n    \n    if not payment_id:\n        await message.reply(\"❌ Введите корректный ID платежа\")\n        return\n    \n    # Show progress message\n    progress_msg = await message.reply(\"🔍 Проверяю статус платежа...\")\n    \n    try:\n        from api_integrations.payment_api import PaymentAPI\n        \n        payment_api = PaymentAPI()\n        result = await payment_api.verify_yookassa_payment(payment_id)\n        \n        if result.get(\"status\") == \"error\":\n            await progress_msg.edit_text(f\"❌ Ошибка проверки: {result.get('message')}\")\n            await state.clear()\n            return\n        \n        status = result.get(\"status\")\n        amount = result.get(\"amount\")\n        currency = result.get(\"currency\")\n        metadata = result.get(\"metadata\", {})\n        is_paid = result.get(\"paid\", False)\n        \n        user_id = metadata.get(\"user_id\")\n        package_id = metadata.get(\"package_id\")\n        \n        status_text = f\"\"\"\n🔍 <b>Результат проверки платежа</b>\n\n💳 <b>ID платежа:</b> {payment_id}\n💰 <b>Сумма:</b> {amount} {currency}\n📊 <b>Статус:</b> {status}\n✅ <b>Оплачен:</b> {'Да ✅' if is_paid else 'Нет ❌'}\n\n👤 <b>Пользователь:</b> {user_id or 'Не указан'}\n📦 <b>Пакет:</b> {package_id or 'Не указан'}\n        \"\"\"\n        \n        if is_paid and user_id and package_id:\n            # Check if credits were already processed\n            payment_exists = await db.payment_exists(payment_id)\n            \n            if payment_exists:\n                status_text += \"\\n\\n⚠️ Кредиты уже начислены ранее\"\n            else:\n                # Process payment manually\n                await progress_msg.edit_text(\"💰 Начисляю кредиты...\")\n                \n                success = await payment_api._process_successful_card_payment(\n                    user_id=int(user_id),\n                    package_id=package_id,\n                    payment_id=payment_id,\n                    amount=float(amount)\n                )\n                \n                if success:\n                    status_text += \"\\n\\n✅ Кредиты успешно начислены!\"\n                    \n                    # Log admin action\n                    admin_log = AdminLog(\n                        admin_id=message.from_user.id,\n                        action=\"manual_payment_processing\",\n                        target_user_id=int(user_id),\n                        description=f\"Manually processed payment {payment_id}\"\n                    )\n                    await db.log_admin_action(admin_log)\n                else:\n                    status_text += \"\\n\\n❌ Ошибка начисления кредитов\"\n        elif is_paid:\n            status_text += \"\\n\\n⚠️ Платеж успешен, но метаданные неполные\"\n        \n        await progress_msg.edit_text(status_text)\n        \n    except Exception as e:\n        logger.error(f\"Error checking payment {payment_id}: {e}\")\n        await progress_msg.edit_text(f\"❌ Ошибка проверки платежа: {e}\")\n    \n    await state.clear()\n\n@router.callback_query(F.data == \"admin_menu\")\nasync def back_to_admin_menu(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Back to admin menu\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    await state.clear()\n    \n    admin_text = \"\"\"\n👑 <b>Панель администратора</b>\n\nВыберите действие из меню ниже:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        admin_text,\n        reply_markup=get_admin_menu_keyboard()\n    )\n    await callback.answer()\n\n# ======= НОВЫЕ ФУНКЦИИ УПРАВЛЕНИЯ КРЕДИТАМИ =======\n\n@router.callback_query(F.data == \"admin_check_credits\")\nasync def admin_check_credits_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start checking user credits\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    text = \"\"\"\n🔍 <b>Проверка кредитов пользователя</b>\n\nВведите ID пользователя (Telegram ID), чтобы проверить его баланс кредитов:\n\n<i>Пример: 123456789</i>\n    \"\"\"\n    \n    await callback.message.edit_text(\n        text,\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_user_id_for_credits)\n    await state.update_data(action=\"check\")\n    await callback.answer()\n\n@router.callback_query(F.data == \"admin_grant_credits\")\nasync def admin_grant_credits_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start granting credits to user\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"❌ Нет доступа\")\n        return\n    \n    # Проверяем environment\n    from admin_tools.credit_management import credit_manager\n    \n    if not credit_manager.is_production:\n        await callback.message.edit_text(\n            \"⚠️ <b>Выдача кредитов заблокирована</b>\\n\\n\"\n            \"Эта функция работает только на production (после deploy).\\n\"\n            \"Локальный запуск не позволяет выдавать кредиты для безопасности.\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        await callback.answer()\n        return\n    \n    text = \"\"\"\n💎 <b>Выдача кредитов пользователю</b>\n\n⚠️ <b>ВНИМАНИЕ:</b> Выдача кредитов работает только на production!\n\nВведите ID пользователя (Telegram ID):\n\n<i>Пример: 123456789</i>\n    \"\"\"\n    \n    await callback.message.edit_text(\n        text,\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_user_id_for_credits)\n    await state.update_data(action=\"grant\")\n    await callback.answer()\n\n@router.message(AdminStates.waiting_user_id_for_credits)\nasync def admin_process_user_id_for_action(message: Message, state: FSMContext):\n    \"\"\"Process user ID for credit actions\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    try:\n        data = await state.get_data()\n        action = data.get('action', 'check')\n        user_id = int(message.text.strip())\n        \n        if action == \"check\":\n            # Проверяем кредиты через безопасную систему\n            result = await check_user_credits(message.from_user.id, user_id)\n            \n            if \"error\" in result:\n                await message.answer(f\"❌ {result['error']}\")\n            else:\n                credits_text = f\"\"\"\n💰 <b>Баланс кредитов пользователя</b>\n\n👤 <b>User ID:</b> {result['user_id']}\n👤 <b>Username:</b> @{result['username'] or 'не указан'}\n👤 <b>Имя:</b> {result['first_name'] or 'не указано'}\n💎 <b>Кредиты:</b> {result['credits']}\n📊 <b>Статус:</b> {result['status']}\n📅 <b>Регистрация:</b> {result['created_at'][:10] if result['created_at'] else 'неизвестно'}\n🕐 <b>Обновлен:</b> {result['updated_at'][:10] if result['updated_at'] else 'неизвестно'}\n                \"\"\"\n                \n                await message.answer(\n                    credits_text,\n                    reply_markup=get_back_to_admin_keyboard()\n                )\n            await state.clear()\n            \n        elif action == \"grant\":\n            # Переходим к вводу количества кредитов\n            await state.update_data(user_id=user_id)\n            \n            await message.answer(\n                f\"💎 <b>Выдача кредитов пользователю {user_id}</b>\\n\\n\"\n                f\"Введите количество кредитов для выдачи (1-1000):\\n\\n\"\n                f\"<i>Например: 50</i>\",\n                reply_markup=get_back_to_admin_keyboard()\n            )\n            await state.set_state(AdminStates.waiting_credits_amount)\n            \n    except ValueError:\n        await message.answer(\"❌ Неверный формат ID. Введите числовой Telegram ID.\")\n    except Exception as e:\n        logger.error(f\"Error processing user ID for action: {e}\")\n        await message.answer(\"❌ Ошибка при обработке ID пользователя.\")\n\n@router.message(AdminStates.waiting_credits_amount)\nasync def admin_process_credits_amount(message: Message, state: FSMContext):\n    \"\"\"Process credits amount input\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    try:\n        credits = int(message.text.strip())\n        \n        if credits <= 0:\n            await message.answer(\"❌ Количество кредитов должно быть положительным числом.\")\n            return\n            \n        if credits > 1000:\n            await message.answer(\"❌ Максимальное количество кредитов за раз: 1000\")\n            return\n        \n        await state.update_data(credits=credits)\n        \n        await message.answer(\n            f\"💎 <b>Выдача {credits} кредитов</b>\\n\\n\"\n            f\"Введите причину выдачи кредитов (необязательно):\\n\\n\"\n            f\"<i>Например: Компенсация за техническую ошибку</i>\\n\\n\"\n            f\"Или отправьте '-' чтобы пропустить:\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        await state.set_state(AdminStates.waiting_credits_reason)\n        \n    except ValueError:\n        await message.answer(\"❌ Введите числовое количество кредитов.\")\n    except Exception as e:\n        logger.error(f\"Error processing credits amount: {e}\")\n        await message.answer(\"❌ Ошибка при обработке количества кредитов.\")\n\n@router.message(AdminStates.waiting_credits_reason)\nasync def admin_process_credits_reason(message: Message, state: FSMContext):\n    \"\"\"Process credits reason and complete grant\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    try:\n        data = await state.get_data()\n        user_id = data.get('user_id')\n        credits = data.get('credits')\n        reason = message.text.strip() if message.text.strip() != '-' else \"\"\n        \n        # Выдаем кредиты через безопасную систему с уведомлением пользователю\n        result = await grant_user_credits(message.from_user.id, user_id, credits, reason, message.bot)\n        \n        if result.get(\"success\"):\n            notification_status = \"✅ Отправлено\" if result.get(\"notification_sent\") else \"⚠️ Не отправлено\"\n            \n            success_text = f\"\"\"\n✅ <b>КРЕДИТЫ УСПЕШНО ВЫДАНЫ!</b>\n\n👤 <b>Пользователь:</b> {result['user_id']}\n💎 <b>Выдано кредитов:</b> {result['credits_granted']}\n💰 <b>Старый баланс:</b> {result['old_balance']}\n💰 <b>Новый баланс:</b> {result['new_balance']}\n📝 <b>Причина:</b> {result['reason'] or 'Не указана'}\n🕐 <b>Время:</b> {result['timestamp'][:19]}\n📨 <b>Уведомление пользователю:</b> {notification_status}\n\nОперация записана в логи администратора.\n            \"\"\"\n            await message.answer(\n                success_text,\n                reply_markup=get_back_to_admin_keyboard()\n            )\n        else:\n            await message.answer(\n                f\"❌ <b>Ошибка при выдаче кредитов:</b>\\n\\n{result.get('error')}\",\n                reply_markup=get_back_to_admin_keyboard()\n            )\n            \n    except Exception as e:\n        logger.error(f\"Error in credit grant completion: {e}\")\n        await message.answer(\n            \"❌ Ошибка при завершении выдачи кредитов.\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n    \n    await state.clear()\n","size_bytes":23887},"handlers/generate.py":{"content":"from aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nimport uuid\n\nfrom database.database import db\nfrom database.models import VideoGeneration, Transaction, TransactionType, GenerationType\nfrom api_integrations.veo_api import VeoAPI\nfrom keyboards.inline import get_generation_menu_keyboard, get_back_to_menu_keyboard\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nrouter = Router()\nconfig = Config()\n\nclass GenerationStates(StatesGroup):\n    waiting_text_prompt = State()\n    waiting_image_prompt = State()\n    waiting_image = State()\n\n@router.callback_query(F.data == \"generate_video\")\nasync def generate_video_menu(callback: CallbackQuery):\n    \"\"\"Show video generation menu\"\"\"\n    text = \"\"\"\n🎬 Генерация видео\n\nВыберите тип генерации:\n\n📝 Видео из текста - создайте видео по текстовому описанию\n🖼 Видео из изображения - оживите изображение с помощью ИИ\n\n💡 Стоимость: 10 кредитов за видео (79₽)\n    \"\"\"\n    \n    await callback.message.edit_text(\n        text,\n        reply_markup=get_generation_menu_keyboard()\n    )\n    await callback.answer()\n\n@router.callback_query(F.data == \"text_to_video\")\nasync def text_to_video_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start text-to-video generation\"\"\"\n    user = await db.get_user(callback.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await callback.message.edit_text(\n            f\"❌ <b>Недостаточно кредитов!</b>\\n\\n\"\n            f\"Для генерации видео нужно {config.VIDEO_GENERATION_COST} кредитов.\\n\"\n            f\"Ваш баланс: {user.credits if user else 0} кредитов\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        await callback.answer()\n        return\n    \n    prompt_tips = \"\"\"\n🎬 <b>Генерация видео из текста</b>\n\n📝 Напишите подробное описание видео, которое хотите создать.\n\n💡 <b>Советы для лучшего результата:</b>\n• Описывайте действия, движения, сцены\n• Указывайте стиль, освещение, ракурс камеры\n• Будьте конкретными и детальными\n• Избегайте сложных сцен с множеством персонажей\n\n<b>Пример хорошего промпта:</b>\n\"Крупный план золотистого ретривера, играющего с мячом в солнечном парке. Собака радостно подпрыгивает, ловя мяч. Мягкое естественное освещение, кинематографическая съемка\"\n\nОтправьте ваш промпт:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        prompt_tips,\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    await state.set_state(GenerationStates.waiting_text_prompt)\n    await callback.answer()\n\n@router.callback_query(F.data == \"image_to_video\")\nasync def image_to_video_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start image-to-video generation\"\"\"\n    user = await db.get_user(callback.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await callback.message.edit_text(\n            f\"❌ <b>Недостаточно кредитов!</b>\\n\\n\"\n            f\"Для генерации видео нужно {config.VIDEO_GENERATION_COST} кредитов.\\n\"\n            f\"Ваш баланс: {user.credits if user else 0} кредитов\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        await callback.answer()\n        return\n    \n    image_instructions = \"\"\"\n🖼 <b>Генерация видео из изображения</b>\n\n📷 Отправьте изображение, которое хотите оживить.\n\n📝 После отправки изображения опишите, как оно должно ожить:\n\n💡 <b>Советы:</b>\n• Описывайте движения и действия\n• Указывайте, какие части изображения должны двигаться\n• Избегайте кардинальных изменений изображения\n• Фокусируйтесь на естественных движениях\n\nОтправьте изображение:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        image_instructions,\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    await state.set_state(GenerationStates.waiting_image)\n    await callback.answer()\n\n@router.message(GenerationStates.waiting_text_prompt)\nasync def process_text_prompt(message: Message, state: FSMContext):\n    \"\"\"Process text-to-video prompt\"\"\"\n    if not message.text:\n        await message.answer(\"❌ Пожалуйста, отправьте текстовое описание видео.\")\n        return\n    \n    await state.clear()\n    \n    # Check user credits again\n    user = await db.get_user(message.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await message.answer(\n            f\"❌ Недостаточно кредитов! Нужно {config.VIDEO_GENERATION_COST} кредитов.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        return\n    \n    # Generate unique task ID\n    task_id = f\"veo_{uuid.uuid4().hex[:12]}\"\n    \n    # Deduct credits\n    new_credits = user.credits - config.VIDEO_GENERATION_COST\n    await db.update_user_credits(message.from_user.id, new_credits)\n    \n    # Create transaction record\n    transaction = Transaction(\n        user_id=message.from_user.id,\n        type=TransactionType.CREDIT_SPEND,\n        amount=-config.VIDEO_GENERATION_COST,\n        description=f\"Video generation: {message.text[:50]}...\"\n    )\n    await db.create_transaction(transaction)\n    \n    # Create video generation record\n    generation = VideoGeneration(\n        user_id=message.from_user.id,\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.TEXT_TO_VIDEO,\n        model=config.DEFAULT_MODEL,\n        aspect_ratio=config.DEFAULT_ASPECT_RATIO,\n        credits_spent=config.VIDEO_GENERATION_COST\n    )\n    await db.create_video_generation(generation)\n    \n    # Start video generation\n    processing_msg = await message.answer(\n        f\"🎬 <b>Генерируем ваше видео...</b>\\n\\n\"\n        f\"📝 Промпт: {message.text[:100]}{'...' if len(message.text) > 100 else ''}\\n\"\n        f\"💰 Списано кредитов: {config.VIDEO_GENERATION_COST}\\n\"\n        f\"💳 Остаток: {new_credits} кредитов\\n\\n\"\n        f\"⏳ Процесс займет 1-5 минут. Мы уведомим вас о готовности!\",\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    \n    # Call Veo API\n    veo_api = VeoAPI()\n    success = await veo_api.generate_video(\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.TEXT_TO_VIDEO,\n        user_id=message.from_user.id\n    )\n    \n    if not success:\n        # Refund credits on failure\n        await db.update_user_credits(message.from_user.id, user.credits)\n        refund_transaction = Transaction(\n            user_id=message.from_user.id,\n            type=TransactionType.ADMIN_GRANT,\n            amount=config.VIDEO_GENERATION_COST,\n            description=\"Refund for failed generation\"\n        )\n        await db.create_transaction(refund_transaction)\n        \n        await message.answer(\n            \"❌ <b>Ошибка генерации видео</b>\\n\\n\"\n            \"Кредиты возвращены на ваш счет. Попробуйте еще раз.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n\n@router.message(GenerationStates.waiting_image)\nasync def process_image_upload(message: Message, state: FSMContext):\n    \"\"\"Process image for image-to-video generation\"\"\"\n    logger.info(f\"Processing image upload from user {message.from_user.id}\")\n    \n    if not message.photo:\n        logger.warning(f\"No photo in message from user {message.from_user.id}\")\n        await message.answer(\"❌ Пожалуйста, отправьте изображение.\")\n        return\n    \n    # Get the largest photo size\n    photo = message.photo[-1]\n    \n    # Store image file_id in state\n    await state.update_data(image_file_id=photo.file_id)\n    \n    await message.answer(\n        \"📝 <b>Отлично! Изображение получено.</b>\\n\\n\"\n        \"Теперь опишите, как изображение должно ожить:\\n\"\n        \"• Какие движения должны происходить?\\n\"\n        \"• Какие части изображения должны двигаться?\\n\"\n        \"• Какая атмосфера должна быть?\\n\\n\"\n        \"Напишите описание:\",\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    await state.set_state(GenerationStates.waiting_image_prompt)\n\n@router.message(GenerationStates.waiting_image_prompt)\nasync def process_image_prompt(message: Message, state: FSMContext):\n    \"\"\"Process prompt for image-to-video generation\"\"\"\n    logger.info(f\"Processing image prompt from user {message.from_user.id}: {message.text[:50] if message.text else 'No text'}\")\n    \n    if not message.text:\n        await message.answer(\"❌ Пожалуйста, отправьте текстовое описание.\")\n        return\n    \n    state_data = await state.get_data()\n    image_file_id = state_data.get('image_file_id')\n    \n    if not image_file_id:\n        await message.answer(\"❌ Изображение потеряно. Начните сначала.\")\n        await state.clear()\n        return\n    \n    await state.clear()\n    \n    # Check user credits\n    user = await db.get_user(message.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await message.answer(\n            f\"❌ Недостаточно кредитов! Нужно {config.VIDEO_GENERATION_COST} кредитов.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        return\n    \n    # Generate unique task ID\n    task_id = f\"veo_{uuid.uuid4().hex[:12]}\"\n    \n    # Deduct credits\n    new_credits = user.credits - config.VIDEO_GENERATION_COST\n    await db.update_user_credits(message.from_user.id, new_credits)\n    \n    # Create transaction record\n    transaction = Transaction(\n        user_id=message.from_user.id,\n        type=TransactionType.CREDIT_SPEND,\n        amount=-config.VIDEO_GENERATION_COST,\n        description=f\"Image-to-video generation: {message.text[:50]}...\"\n    )\n    await db.create_transaction(transaction)\n    \n    # For image-to-video, we need to get the actual image URL\n    # In a real implementation, you would upload the image to a public URL\n    # For now, we'll use the file_id (this needs to be converted to a public URL)\n    image_url = f\"telegram_file:{image_file_id}\"  # Placeholder\n    \n    # Create video generation record\n    generation = VideoGeneration(\n        user_id=message.from_user.id,\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.IMAGE_TO_VIDEO,\n        image_url=image_url,\n        model=config.DEFAULT_MODEL,\n        aspect_ratio=config.DEFAULT_ASPECT_RATIO,\n        credits_spent=config.VIDEO_GENERATION_COST\n    )\n    await db.create_video_generation(generation)\n    \n    await message.answer(\n        f\"🖼 <b>Генерируем видео из изображения...</b>\\n\\n\"\n        f\"📝 Описание: {message.text[:100]}{'...' if len(message.text) > 100 else ''}\\n\"\n        f\"💰 Списано кредитов: {config.VIDEO_GENERATION_COST}\\n\"\n        f\"💳 Остаток: {new_credits} кредитов\\n\\n\"\n        f\"⏳ Процесс займет 1-5 минут. Мы уведомим вас о готовности!\",\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    \n    # Call Veo API for image-to-video\n    veo_api = VeoAPI()\n    success = await veo_api.generate_video(\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.IMAGE_TO_VIDEO,\n        image_file_id=image_file_id,\n        user_id=message.from_user.id\n    )\n    \n    if not success:\n        # Refund credits on failure\n        await db.update_user_credits(message.from_user.id, user.credits)\n        refund_transaction = Transaction(\n            user_id=message.from_user.id,\n            type=TransactionType.ADMIN_GRANT,\n            amount=config.VIDEO_GENERATION_COST,\n            description=\"Refund for failed generation\"\n        )\n        await db.create_transaction(refund_transaction)\n        \n        await message.answer(\n            \"❌ <b>Ошибка генерации видео</b>\\n\\n\"\n            \"Кредиты возвращены на ваш счет. Попробуйте еще раз.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n","size_bytes":13416},"handlers/payments.py":{"content":"from aiogram import Router, F\nfrom aiogram.types import CallbackQuery, Message, PreCheckoutQuery, SuccessfulPayment\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom database.database import db\nfrom database.models import Transaction, TransactionType, PaymentMethod\nfrom keyboards.inline import get_payment_menu_keyboard, get_back_to_menu_keyboard, get_credit_packages_keyboard\nfrom api_integrations.payment_api import PaymentAPI\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nrouter = Router()\nconfig = Config()\n\nclass PaymentStates(StatesGroup):\n    waiting_custom_amount = State()\n\n# Credit packages - правильные цены\nCREDIT_PACKAGES = {\n    \"package_1\": {\"credits\": 10, \"price_stars\": 79, \"price_rub\": 79, \"title\": \"1 генерация видео (10 кредитов)\"},\n    \"package_5\": {\"credits\": 50, \"price_stars\": 399, \"price_rub\": 399, \"title\": \"5 генераций видео (50 кредитов)\"},\n    \"package_10\": {\"credits\": 100, \"price_stars\": 749, \"price_rub\": 749, \"title\": \"10 генераций видео (100 кредитов)\", \"popular\": True},\n    \"package_50\": {\"credits\": 500, \"price_stars\": 3499, \"price_rub\": 3499, \"title\": \"50 генераций видео (500 кредитов)\", \"bonus\": 50},\n}\n\n@router.callback_query(F.data == \"buy_credits\")\nasync def buy_credits_menu(callback: CallbackQuery):\n    \"\"\"Show credits purchase menu\"\"\"\n    user = await db.get_user(callback.from_user.id)\n    credits = user.credits if user else 0\n    \n    text = f\"\"\"\n💰 <b>Покупка кредитов</b>\n\n💳 <b>Ваш текущий баланс:</b> {credits} кредитов\n\nВыберите способ оплаты:\n\n⭐️ <b>Telegram Stars</b> - быстро и удобно\n💳 <b>Банковская карта/СБП</b> - через ЮКасса\n\n💡 <b>1 кредит от 7₽</b> (в большом пакете)\n🎬 <b>1 видео = 10 кредитов (от 70₽)</b>\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_payment_menu_keyboard()\n        )\n    await callback.answer()\n\n@router.callback_query(F.data == \"pay_stars\")\nasync def pay_with_stars(callback: CallbackQuery):\n    \"\"\"Show Telegram Stars payment options\"\"\"\n    text = \"\"\"\n⭐️ <b>Оплата Telegram Stars</b>\n\n🎬 <b>1 видео = 10 кредитов</b>\n💰 <b>Выгодные цены:</b>\n• 1 генерация - 79⭐️ (7.9⭐️ за кредит)\n• 5 генераций - 399⭐️ (7.98⭐️ за кредит) 🔥\n• 10 генераций - 749⭐️ (7.49⭐️ за кредит) \n• 50 генераций - 3499⭐️ (7⭐️ за кредит) + 🎁 бонус!\n\nВыберите пакет кредитов:\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_credit_packages_keyboard(\"stars\")\n        )\n    await callback.answer()\n\n@router.callback_query(F.data == \"pay_card\")\nasync def pay_with_card(callback: CallbackQuery):\n    \"\"\"Show card payment options\"\"\"\n    text = \"\"\"\n💳 <b>Оплата банковской картой</b>\n\n🎬 <b>1 видео = 10 кредитов</b>\n💰 <b>Выгодные цены:</b>\n• 1 генерация - 79₽ (7.9₽ за кредит)\n• 5 генераций - 399₽ (7.98₽ за кредит) 🔥 \n• 10 генераций - 749₽ (7.49₽ за кредит)\n• 50 генераций - 3499₽ (7₽ за кредит) + 🎁 бонус!\n\nВыберите пакет кредитов:\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_credit_packages_keyboard(\"card\")\n        )\n    await callback.answer()\n\n@router.callback_query(F.data == \"pay_sbp\")\nasync def pay_with_sbp(callback: CallbackQuery):\n    \"\"\"Show SBP payment options\"\"\"\n    text = \"\"\"\n🏦 <b>Оплата через СБП</b>\n\n<b>Система быстрых платежей</b> - мгновенные переводы 24/7\n\n🎬 <b>1 видео = 10 кредитов</b>\n💰 <b>Выгодные цены:</b>\n• 1 генерация - 79₽ (7.9₽ за кредит)\n• 5 генераций - 399₽ (7.98₽ за кредит) 🔥\n• 10 генераций - 749₽ (7.49₽ за кредит)\n• 50 генераций - 3499₽ (7₽ за кредит) + 🎁 бонус!\n\nВыберите пакет кредитов:\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_credit_packages_keyboard(\"sbp\")\n        )\n    await callback.answer()\n\n@router.callback_query(F.data.startswith(\"buy_stars_\"))\nasync def process_stars_payment(callback: CallbackQuery):\n    \"\"\"Process Telegram Stars payment\"\"\"\n    package_id = callback.data.replace(\"buy_stars_\", \"\")\n    package = CREDIT_PACKAGES.get(package_id)\n    \n    if not package:\n        await callback.answer(\"❌ Неверный пакет\")\n        return\n    \n    # Create invoice for Telegram Stars\n    title = f\"💰 {package['title']}\"\n    description = f\"Покупка {package['credits']} кредитов для генерации AI видео\"\n    \n    if package.get('bonus'):\n        description += f\" + {package['bonus']} бонусных кредитов!\"\n    \n    prices = [{\"label\": \"XTR\", \"amount\": package['price_stars']}]\n    \n    try:\n        if callback.message:\n            await callback.message.answer_invoice(\n                title=title,\n                description=description,\n                payload=f\"credits_{package_id}_{callback.from_user.id}\",\n                provider_token=\"\",  # Empty for Telegram Stars\n                currency=\"XTR\",\n                prices=[{\"label\": \"XTR\", \"amount\": package['price_stars']}]\n            )\n        await callback.answer(\"✅ Счет создан!\")\n    except Exception as e:\n        logger.error(f\"Error creating Stars invoice: {e}\")\n        await callback.answer(\"❌ Ошибка создания счета\")\n\n@router.callback_query(F.data.startswith(\"buy_card_\"))\nasync def process_card_payment(callback: CallbackQuery):\n    \"\"\"Process card/SBP payment through YooKassa\"\"\"\n    package_id = callback.data.replace(\"buy_card_\", \"\")\n    package = CREDIT_PACKAGES.get(package_id)\n    \n    if not package:\n        await callback.answer(\"❌ Неверный пакет\")\n        return\n    \n    # Create payment through YooKassa\n    payment_api = PaymentAPI()\n    \n    description = f\"Покупка {package['credits']} кредитов\"\n    if package.get('bonus'):\n        description += f\" + {package['bonus']} бонусных кредитов\"\n    \n    payment_url = await payment_api.create_yookassa_payment(\n        amount=package['price_rub'],\n        description=description,\n        user_id=callback.from_user.id,\n        package_id=package_id,\n        payment_method=\"bank_card\"\n    )\n    \n    if payment_url:\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"💳 Оплатить\", url=payment_url)],\n            [InlineKeyboardButton(text=\"🔙 Назад\", callback_data=\"buy_credits\")]\n        ])\n        \n        await callback.message.edit_text(\n            f\"💳 <b>Оплата банковской картой</b>\\n\\n\"\n            f\"📦 <b>Пакет:</b> {package['title']}\\n\"\n            f\"💰 <b>Стоимость:</b> {package['price_rub']} ₽\\n\\n\"\n            f\"Нажмите кнопку ниже для перехода к оплате:\",\n            parse_mode=\"HTML\",\n            reply_markup=keyboard\n        )\n    else:\n        await callback.message.edit_text(\n            \"❌ Ошибка создания платежа. Попробуйте позже.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n    \n    await callback.answer()\n\n@router.callback_query(F.data.startswith(\"buy_sbp_\"))\nasync def process_sbp_payment(callback: CallbackQuery):\n    \"\"\"Process SBP payment through YooKassa\"\"\"\n    package_id = callback.data.replace(\"buy_sbp_\", \"\")\n    package = CREDIT_PACKAGES.get(package_id)\n    \n    if not package:\n        await callback.answer(\"❌ Неверный пакет\")\n        return\n    \n    # Create payment through YooKassa with SBP method\n    payment_api = PaymentAPI()\n    \n    description = f\"Покупка {package['credits']} кредитов\"\n    if package.get('bonus'):\n        description += f\" + {package['bonus']} бонусных кредитов\"\n    \n    payment_url = await payment_api.create_yookassa_payment(\n        amount=package['price_rub'],\n        description=description,\n        user_id=callback.from_user.id,\n        package_id=package_id,\n        payment_method=\"sbp\"\n    )\n    \n    if payment_url:\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"🏦 Оплатить через СБП\", url=payment_url)],\n            [InlineKeyboardButton(text=\"🔙 Назад\", callback_data=\"buy_credits\")]\n        ])\n        \n        await callback.message.edit_text(\n            f\"🏦 <b>Оплата через СБП</b>\\n\\n\"\n            f\"📦 <b>Пакет:</b> {package['title']}\\n\"\n            f\"💰 <b>Стоимость:</b> {package['price_rub']} ₽\\n\\n\"\n            f\"<b>Система быстрых платежей</b> - мгновенные переводы 24/7\\n\"\n            f\"Нажмите кнопку ниже для перехода к оплате:\",\n            parse_mode=\"HTML\",\n            reply_markup=keyboard\n        )\n    else:\n        await callback.message.edit_text(\n            \"❌ Ошибка создания платежа. Попробуйте позже.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n    \n    await callback.answer()\n\n@router.pre_checkout_query()\nasync def process_pre_checkout_query(pre_checkout_query: PreCheckoutQuery):\n    \"\"\"Process pre-checkout query for Telegram Stars\"\"\"\n    await pre_checkout_query.answer(ok=True)\n\n@router.message(F.successful_payment)\nasync def process_successful_payment(message: Message):\n    \"\"\"Process successful Telegram Stars payment with enhanced validation\"\"\"\n    payment = message.successful_payment\n    \n    # SECURITY: Validate that payment is from the actual user who initiated it\n    actual_user_id = message.from_user.id\n    \n    # Parse and validate payload format\n    try:\n        payload_parts = payment.invoice_payload.split('_')\n        if len(payload_parts) < 3 or payload_parts[0] != \"credits\":\n            logger.error(f\"Invalid payment payload format: {payment.invoice_payload}\")\n            return\n        \n        package_id = payload_parts[1]\n        claimed_user_id = int(payload_parts[2])\n        \n        # SECURITY: Ensure user_id in payload matches actual payment sender\n        if claimed_user_id != actual_user_id:\n            logger.error(f\"Payment fraud attempt: payload claims user {claimed_user_id} but payment from {actual_user_id}\")\n            return\n        \n    except (ValueError, IndexError) as e:\n        logger.error(f\"Error parsing payment payload: {e}\")\n        return\n    \n    user_id = actual_user_id  # Use verified user ID\n    \n    # Validate package exists and payment amount matches\n    package = CREDIT_PACKAGES.get(package_id)\n    if not package:\n        logger.error(f\"Invalid package_id in payment: {package_id}\")\n        return\n    \n    # SECURITY: Verify payment amount matches expected package price\n    expected_amount = package['price_stars']\n    actual_amount = payment.total_amount\n    \n    if actual_amount != expected_amount:\n        logger.error(f\"Payment amount mismatch: expected {expected_amount} XTR, got {actual_amount} XTR\")\n        return\n    \n    # Check for duplicate payment processing\n    payment_id = payment.telegram_payment_charge_id\n    if await db.payment_exists(payment_id):\n        logger.warning(f\"Duplicate Telegram Stars payment detected: {payment_id}\")\n        return\n    \n    # Process the validated payment\n    # Calculate total credits (including bonus)\n    total_credits = package['credits']\n    if package.get('bonus'):\n        total_credits += package['bonus']\n    \n    # Update user credits\n    user = await db.get_user(user_id)\n    if user:\n        new_credits = user.credits + total_credits\n        await db.update_user_credits(user_id, new_credits)\n        \n        # Create transaction record\n        transaction = Transaction(\n            user_id=user_id,\n            type=TransactionType.CREDIT_PURCHASE,\n            amount=total_credits,\n            description=f\"Purchase via Telegram Stars: {package['title']}\",\n            payment_method=PaymentMethod.TELEGRAM_STARS,\n            payment_id=payment.telegram_payment_charge_id\n        )\n        await db.create_transaction(transaction)\n        \n        success_text = f\"\"\"\n✅ <b>Платеж успешно завершен!</b>\n\n💰 <b>Добавлено кредитов:</b> {total_credits}\n💳 <b>Ваш баланс:</b> {new_credits} кредитов\n\nТеперь вы можете генерировать видео! 🎬\n        \"\"\"\n        \n        from keyboards.inline import get_main_menu_keyboard\n        await message.answer(\n            success_text,\n            parse_mode=\"HTML\",\n            reply_markup=get_main_menu_keyboard()\n        )\n        \n        logger.info(f\"Stars payment completed: user {user_id}, credits {total_credits}\")\n    else:\n        logger.error(f\"User {user_id} not found for payment processing\")\n\n# Webhook handler for YooKassa payments would be implemented here\n# This requires a separate web server endpoint\n","size_bytes":14022},"handlers/start.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import CommandStart\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\n\nfrom database.database import db\nfrom database.models import User, UserStatus\nfrom keyboards.inline import get_main_menu_keyboard\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nrouter = Router()\n\n@router.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext):\n    \"\"\"Handle /start command\"\"\"\n    try:\n        user_id = message.from_user.id\n        \n        # Get or create user\n        user = await db.get_user(user_id)\n        if not user:\n            user = User(\n                telegram_id=user_id,\n                username=message.from_user.username,\n                first_name=message.from_user.first_name,\n                last_name=message.from_user.last_name\n            )\n            await db.create_user(user)\n            logger.info(f\"New user created: {user_id}\")\n        \n        # Clear any existing state\n        await state.clear()\n        \n        # Check if this is a return from payment\n        start_param = message.text.split(' ', 1)[1] if ' ' in message.text else None\n        if start_param == \"payment_success\":\n            welcome_text = f\"\"\"\n✅ <b>Добро пожаловать обратно!</b>\n\nПривет, {message.from_user.first_name}! 👋\n\n💰 <b>Ваш текущий баланс:</b> {user.credits} кредитов\n\nЕсли вы только что совершили оплату, кредиты будут зачислены в течение нескольких минут.\n\nВыберите действие из меню ниже:\n            \"\"\"\n        else:\n            # Regular welcome message\n            welcome_text = f\"\"\"\n🎬 <b>Добро пожаловать в AI Video Generator!</b>\n\nПривет, {message.from_user.first_name}! 👋\n\nЭтот бот поможет вам создавать потрясающие видео с помощью искусственного интеллекта Veo 3.\n\n💰 <b>Ваш баланс:</b> {user.credits} кредитов\n\nВыберите действие из меню ниже:\n            \"\"\"\n        \n        await message.answer(\n            welcome_text,\n            parse_mode=\"HTML\",\n            reply_markup=get_main_menu_keyboard()\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error in start command: {e}\")\n        await message.answer(\n            \"❌ Произошла ошибка при запуске бота. Попробуйте позже.\",\n            reply_markup=get_main_menu_keyboard()\n        )\n\n@router.callback_query(F.data == \"main_menu\")\nasync def back_to_main_menu(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Handle back to main menu\"\"\"\n    await state.clear()\n    \n    user = await db.get_user(callback.from_user.id)\n    credits = user.credits if user else 0\n    \n    welcome_text = f\"\"\"\n🎬 <b>AI Video Generator</b>\n\n💰 <b>Ваш баланс:</b> {credits} кредитов\n\nВыберите действие из меню ниже:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        welcome_text,\n        parse_mode=\"HTML\",\n        reply_markup=get_main_menu_keyboard()\n    )\n    await callback.answer()\n\n@router.callback_query(F.data == \"help\")\nasync def help_command(callback: CallbackQuery):\n    \"\"\"Handle help callback\"\"\"\n    help_text = \"\"\"\n📖 Помощь по использованию бота\n\nВажные советы по составлению запросов:\nhttps://t.me/CatiAiPromt/51\n\nПримеры хороших запросов можно найти здесь:\nhttps://t.me/CatiAiPromt\n\nКак пользоваться ботом:\n\n🎥 Генерация видео:\n• Выберите тип генерации (из текста или изображения)\n• Опишите детально, что вы хотите видеть в видео\n• Дождитесь завершения генерации (1-5 минут)\n\n💰 Кредиты:\n• 1 видео = 10 кредитов (79₽)\n• Покупайте кредиты через Telegram Stars или банковскую карту\n• Избегайте сложных сцен с множеством объектов\n    \"\"\"\n    \n    from keyboards.inline import get_back_to_menu_keyboard\n    await callback.message.edit_text(\n        help_text,\n        parse_mode=\"HTML\",\n        reply_markup=get_back_to_menu_keyboard(),\n        disable_web_page_preview=True\n    )\n    await callback.answer()\n","size_bytes":4608},"keyboards/inline.py":{"content":"from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\ndef get_main_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Main menu inline keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"🎬 Генерировать видео\", callback_data=\"generate_video\")],\n        [InlineKeyboardButton(text=\"💰 Купить кредиты\", callback_data=\"buy_credits\")],\n        [InlineKeyboardButton(text=\"📖 Помощь\", callback_data=\"help\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_generation_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Video generation menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"📝 Видео из текста\", callback_data=\"text_to_video\")],\n        [InlineKeyboardButton(text=\"🖼 Видео из изображения\", callback_data=\"image_to_video\")],\n        [InlineKeyboardButton(text=\"🔙 Назад в меню\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_payment_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Payment method selection keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"⭐️ Telegram Stars\", callback_data=\"pay_stars\")],\n        [InlineKeyboardButton(text=\"💳 Банковская карта\", callback_data=\"pay_card\")],\n        [InlineKeyboardButton(text=\"🏦 СБП (Система быстрых платежей)\", callback_data=\"pay_sbp\")],\n        [InlineKeyboardButton(text=\"🔙 Назад в меню\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_credit_packages_keyboard(payment_method: str) -> InlineKeyboardMarkup:\n    \"\"\"Credit packages keyboard\"\"\"\n    # Import here to avoid circular import\n    from handlers.payments import CREDIT_PACKAGES\n    \n    keyboard = []\n    \n    for package_id, package in CREDIT_PACKAGES.items():\n        # Format package button text\n        text = f\"💎 {package['title']}\"\n        \n        if payment_method == \"stars\":\n            text += f\" - {package['price_stars']} ⭐️\"\n        else:\n            text += f\" - {package['price_rub']} ₽\"\n        \n        # Add bonus indicator\n        if package.get('bonus'):\n            text += f\" (+{package['bonus']} бонус!)\"\n        \n        # Add popular indicator\n        if package.get('popular'):\n            text = \"🔥 \" + text\n        \n        callback_data = f\"buy_{payment_method}_{package_id}\"\n        keyboard.append([InlineKeyboardButton(text=text, callback_data=callback_data)])\n    \n    # Back button\n    keyboard.append([InlineKeyboardButton(text=\"🔙 Назад\", callback_data=\"buy_credits\")])\n    \n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_back_to_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Simple back to main menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"🔙 Главное меню\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_admin_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Admin menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"📊 Статистика пользователей\", callback_data=\"admin_stats\")],\n        [InlineKeyboardButton(text=\"💰 Проверить кредиты\", callback_data=\"admin_check_credits\"),\n         InlineKeyboardButton(text=\"💎 Выдать кредиты\", callback_data=\"admin_grant_credits\")],\n        [InlineKeyboardButton(text=\"📢 Рассылка сообщений\", callback_data=\"admin_broadcast\")],\n        [InlineKeyboardButton(text=\"🔍 Проверка платежа\", callback_data=\"admin_check_payment\")],\n        [InlineKeyboardButton(text=\"📨 Отправить уведомление\", callback_data=\"admin_send_notification\")],\n        [InlineKeyboardButton(text=\"🔙 Главное меню\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_back_to_admin_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Back to admin menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"🔙 Админ-панель\", callback_data=\"admin_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_video_result_keyboard(video_url: str = None) -> InlineKeyboardMarkup:\n    \"\"\"Keyboard for video generation result\"\"\"\n    keyboard = []\n    \n    if video_url:\n        keyboard.append([InlineKeyboardButton(text=\"📥 Скачать видео\", url=video_url)])\n    \n    keyboard.extend([\n        [InlineKeyboardButton(text=\"🎬 Создать еще видео\", callback_data=\"generate_video\")],\n        [InlineKeyboardButton(text=\"🔙 Главное меню\", callback_data=\"main_menu\")]\n    ])\n    \n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_confirm_payment_keyboard(payment_url: str) -> InlineKeyboardMarkup:\n    \"\"\"Keyboard with payment confirmation button\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"💳 Оплатить\", url=payment_url)],\n        [InlineKeyboardButton(text=\"🔙 Назад\", callback_data=\"buy_credits\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n","size_bytes":5213},"middlewares/rate_limit.py":{"content":"from aiogram import BaseMiddleware\nfrom aiogram.types import Message, CallbackQuery, TelegramObject\nfrom typing import Callable, Dict, Any, Awaitable, Union\nimport time\nimport asyncio\n\nfrom utils.rate_limiter import rate_limiter\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass RateLimitMiddleware(BaseMiddleware):\n    \"\"\"Rate limiting middleware for aiogram\"\"\"\n    \n    def __init__(self):\n        self.rate_limiter = rate_limiter\n    \n    async def __call__(\n        self,\n        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],\n        event: TelegramObject,\n        data: Dict[str, Any]\n    ) -> Any:\n        \n        # Get user ID from different event types\n        user_id = None\n        if isinstance(event, Message):\n            user_id = event.from_user.id if event.from_user else None\n            # Skip rate limiting for users in generation states (uploading images/prompts)\n            if hasattr(data.get('state'), 'get_state'):\n                try:\n                    current_state = await data['state'].get_state()\n                    if current_state and ('waiting_image' in current_state or 'waiting_text_prompt' in current_state):\n                        return await handler(event, data)\n                except:\n                    pass  # Continue with normal rate limiting if state check fails\n        elif isinstance(event, CallbackQuery):\n            user_id = event.from_user.id if event.from_user else None\n            # Skip rate limiting for navigation callback queries\n            navigation_callbacks = [\n                \"main_menu\", \"buy_credits\", \"pay_stars\", \"pay_card\", \n                \"generate_video\", \"text_to_video\", \"image_to_video\",\n                \"admin_panel\", \"user_stats\", \"broadcast_menu\", \"back_to_menu\"\n            ]\n            if event.data in navigation_callbacks:\n                return await handler(event, data)\n        \n        # Skip rate limiting if no user ID found\n        if not user_id:\n            return await handler(event, data)\n        \n        # Check rate limit\n        if not self.rate_limiter.is_allowed(user_id):\n            reset_time = self.rate_limiter.get_reset_time(user_id)\n            current_time = time.time()\n            \n            if reset_time > current_time:\n                wait_seconds = int(reset_time - current_time) + 1\n                \n                rate_limit_message = (\n                    f\"🚫 <b>Превышен лимит запросов!</b>\\n\\n\"\n                    f\"⏱ Попробуйте снова через {wait_seconds} секунд.\\n\\n\"\n                    f\"💡 Это ограничение помогает поддерживать качество сервиса для всех пользователей.\"\n                )\n                \n                if isinstance(event, Message):\n                    await event.answer(rate_limit_message)\n                elif isinstance(event, CallbackQuery):\n                    await event.answer(\n                        f\"Превышен лимит! Ждите {wait_seconds} сек.\",\n                        show_alert=True\n                    )\n                \n                logger.warning(f\"Rate limit exceeded for user {user_id}\")\n                return  # Don't proceed to handler\n        \n        # Proceed to handler if rate limit not exceeded\n        return await handler(event, data)\n","size_bytes":3416},"utils/helpers.py":{"content":"import re\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Optional, List, Dict, Any\nimport hashlib\nimport uuid\n\ndef validate_prompt(prompt: str) -> tuple[bool, str]:\n    \"\"\"Validate video generation prompt\"\"\"\n    if not prompt or not prompt.strip():\n        return False, \"Промпт не может быть пустым\"\n    \n    prompt = prompt.strip()\n    \n    if len(prompt) < 10:\n        return False, \"Промпт слишком короткий. Минимум 10 символов.\"\n    \n    if len(prompt) > 1000:\n        return False, \"Промпт слишком длинный. Максимум 1000 символов.\"\n    \n    # Check for potentially harmful content\n    forbidden_keywords = [\n        \"nsfw\", \"nude\", \"naked\", \"sexual\", \"porn\", \"xxx\",\n        \"violence\", \"kill\", \"death\", \"suicide\", \"harm\",\n        \"drugs\", \"illegal\", \"weapon\", \"bomb\", \"terror\"\n    ]\n    \n    prompt_lower = prompt.lower()\n    for keyword in forbidden_keywords:\n        if keyword in prompt_lower:\n            return False, \"Промпт содержит запрещенный контент\"\n    \n    return True, \"OK\"\n\ndef format_duration(seconds: int) -> str:\n    \"\"\"Format duration in human-readable format\"\"\"\n    if seconds < 60:\n        return f\"{seconds}с\"\n    elif seconds < 3600:\n        minutes = seconds // 60\n        remaining_seconds = seconds % 60\n        if remaining_seconds == 0:\n            return f\"{minutes}м\"\n        return f\"{minutes}м {remaining_seconds}с\"\n    else:\n        hours = seconds // 3600\n        remaining_minutes = (seconds % 3600) // 60\n        if remaining_minutes == 0:\n            return f\"{hours}ч\"\n        return f\"{hours}ч {remaining_minutes}м\"\n\ndef format_credits(credits: int) -> str:\n    \"\"\"Format credits with proper plural form\"\"\"\n    if credits % 10 == 1 and credits % 100 != 11:\n        return f\"{credits} кредит\"\n    elif credits % 10 in [2, 3, 4] and credits % 100 not in [12, 13, 14]:\n        return f\"{credits} кредита\"\n    else:\n        return f\"{credits} кредитов\"\n\ndef escape_html(text: str) -> str:\n    \"\"\"Escape HTML special characters\"\"\"\n    if not text:\n        return \"\"\n    \n    return (text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace('\"', \"&quot;\")\n            .replace(\"'\", \"&#x27;\"))\n\ndef truncate_text(text: str, max_length: int = 100, suffix: str = \"...\") -> str:\n    \"\"\"Truncate text to specified length\"\"\"\n    if not text:\n        return \"\"\n    \n    if len(text) <= max_length:\n        return text\n    \n    return text[:max_length - len(suffix)] + suffix\n\ndef generate_task_id(prefix: str = \"veo\") -> str:\n    \"\"\"Generate unique task ID\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    random_part = uuid.uuid4().hex[:8]\n    return f\"{prefix}_{timestamp}_{random_part}\"\n\ndef is_valid_url(url: str) -> bool:\n    \"\"\"Check if URL is valid\"\"\"\n    url_pattern = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url_pattern.match(url) is not None\n\ndef hash_string(text: str) -> str:\n    \"\"\"Generate SHA-256 hash of string\"\"\"\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef parse_callback_data(callback_data: str) -> Dict[str, str]:\n    \"\"\"Parse callback data into dictionary\"\"\"\n    parts = callback_data.split('_')\n    if len(parts) < 2:\n        return {\"action\": callback_data}\n    \n    result = {\"action\": parts[0]}\n    for i, part in enumerate(parts[1:], 1):\n        result[f\"param{i}\"] = part\n    \n    return result\n\ndef format_file_size(size_bytes: int) -> str:\n    \"\"\"Format file size in human-readable format\"\"\"\n    if size_bytes == 0:\n        return \"0 B\"\n    \n    size_names = [\"B\", \"KB\", \"MB\", \"GB\"]\n    i = 0\n    while size_bytes >= 1024 and i < len(size_names) - 1:\n        size_bytes /= 1024\n        i += 1\n    \n    return f\"{size_bytes:.1f} {size_names[i]}\"\n\ndef get_user_display_name(user) -> str:\n    \"\"\"Get user display name from Telegram user object\"\"\"\n    if hasattr(user, 'first_name') and user.first_name:\n        name = user.first_name\n        if hasattr(user, 'last_name') and user.last_name:\n            name += f\" {user.last_name}\"\n        return name\n    elif hasattr(user, 'username') and user.username:\n        return f\"@{user.username}\"\n    else:\n        return f\"User {user.id}\"\n\ndef is_recent_timestamp(timestamp: datetime, hours: int = 24) -> bool:\n    \"\"\"Check if timestamp is within recent hours\"\"\"\n    if not timestamp:\n        return False\n    \n    now = datetime.now()\n    time_diff = now - timestamp\n    return time_diff < timedelta(hours=hours)\n\ndef batch_list(items: List[Any], batch_size: int) -> List[List[Any]]:\n    \"\"\"Split list into batches\"\"\"\n    return [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\n\nasync def retry_async(func, max_retries: int = 3, delay: float = 1.0):\n    \"\"\"Retry async function with exponential backoff\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return await func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise e\n            \n            wait_time = delay * (2 ** attempt)  # Exponential backoff\n            await asyncio.sleep(wait_time)\n    \n    return None\n\ndef clean_filename(filename: str) -> str:\n    \"\"\"Clean filename from invalid characters\"\"\"\n    # Remove invalid characters for filenames\n    invalid_chars = '<>:\"/\\\\|?*'\n    for char in invalid_chars:\n        filename = filename.replace(char, '_')\n    \n    # Limit length\n    filename = filename[:100]\n    \n    return filename\n\ndef format_timestamp(timestamp: datetime, format_type: str = \"short\") -> str:\n    \"\"\"Format timestamp for display\"\"\"\n    if not timestamp:\n        return \"N/A\"\n    \n    now = datetime.now()\n    diff = now - timestamp\n    \n    if format_type == \"relative\":\n        if diff.days > 0:\n            return f\"{diff.days} дней назад\"\n        elif diff.seconds > 3600:\n            hours = diff.seconds // 3600\n            return f\"{hours} часов назад\"\n        elif diff.seconds > 60:\n            minutes = diff.seconds // 60\n            return f\"{minutes} минут назад\"\n        else:\n            return \"Только что\"\n    elif format_type == \"short\":\n        return timestamp.strftime(\"%d.%m.%Y %H:%M\")\n    elif format_type == \"long\":\n        return timestamp.strftime(\"%d %B %Y, %H:%M:%S\")\n    else:\n        return timestamp.isoformat()\n\ndef extract_numbers(text: str) -> List[int]:\n    \"\"\"Extract all numbers from text\"\"\"\n    numbers = re.findall(r'\\d+', text)\n    return [int(num) for num in numbers]\n\ndef is_valid_telegram_id(user_id: str) -> bool:\n    \"\"\"Check if string is valid Telegram user ID\"\"\"\n    try:\n        user_id_int = int(user_id)\n        return 1 <= user_id_int <= 999999999999\n    except ValueError:\n        return False\n","size_bytes":7130},"utils/logger.py":{"content":"import logging\nimport sys\nfrom datetime import datetime\nfrom logging.handlers import RotatingFileHandler\nimport os\n\ndef setup_logger(name: str = \"telegram_bot\", level: str = \"INFO\") -> logging.Logger:\n    \"\"\"Setup logging configuration\"\"\"\n    \n    # Create logger\n    logger = logging.getLogger(name)\n    logger.setLevel(getattr(logging, level.upper()))\n    \n    # Prevent duplicate handlers\n    if logger.handlers:\n        logger.handlers.clear()\n    \n    # Create formatters\n    detailed_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'\n    )\n    \n    simple_formatter = logging.Formatter(\n        '%(asctime)s - %(levelname)s - %(message)s'\n    )\n    \n    # Console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging.INFO)\n    console_handler.setFormatter(simple_formatter)\n    logger.addHandler(console_handler)\n    \n    # Simplified file handler without rotation to avoid threading issues\n    try:\n        # Create logs directory if it doesn't exist\n        os.makedirs(\"logs\", exist_ok=True)\n        \n        file_handler = logging.FileHandler(\"logs/bot.log\")\n        file_handler.setLevel(logging.DEBUG)\n        file_handler.setFormatter(detailed_formatter)\n        logger.addHandler(file_handler)\n        \n    except Exception as e:\n        logger.warning(f\"Could not setup file logging: {e}\")\n    \n    return logger\n\ndef get_logger(name: str = None) -> logging.Logger:\n    \"\"\"Get logger instance\"\"\"\n    if name:\n        return logging.getLogger(f\"telegram_bot.{name}\")\n    return logging.getLogger(\"telegram_bot\")\n\ndef log_user_action(user_id: int, action: str, details: str = \"\"):\n    \"\"\"Log user actions for monitoring\"\"\"\n    logger = get_logger(\"user_actions\")\n    logger.info(f\"User {user_id}: {action} | {details}\")\n\ndef log_api_call(api_name: str, success: bool, duration: float = None, error: str = None):\n    \"\"\"Log API calls for monitoring\"\"\"\n    logger = get_logger(\"api_calls\")\n    status = \"SUCCESS\" if success else \"FAILED\"\n    duration_str = f\" | Duration: {duration:.2f}s\" if duration else \"\"\n    error_str = f\" | Error: {error}\" if error else \"\"\n    logger.info(f\"API {api_name}: {status}{duration_str}{error_str}\")\n\ndef log_payment(user_id: int, amount: int, method: str, success: bool, payment_id: str = None):\n    \"\"\"Log payment transactions\"\"\"\n    logger = get_logger(\"payments\")\n    status = \"SUCCESS\" if success else \"FAILED\"\n    payment_str = f\" | PaymentID: {payment_id}\" if payment_id else \"\"\n    logger.info(f\"Payment {status}: User {user_id} | Amount {amount} | Method {method}{payment_str}\")\n\ndef sanitize_log_data(data: str) -> str:\n    \"\"\"Sanitize sensitive data from logs\"\"\"\n    # Remove API keys, tokens, and other sensitive information\n    sensitive_patterns = [\n        r'Bearer [A-Za-z0-9\\-_]+',\n        r'token[\"\\s]*[:=][\"\\s]*[A-Za-z0-9\\-_]+',\n        r'key[\"\\s]*[:=][\"\\s]*[A-Za-z0-9\\-_]+',\n        r'password[\"\\s]*[:=][\"\\s]*\\S+',\n    ]\n    \n    sanitized = data\n    for pattern in sensitive_patterns:\n        import re\n        sanitized = re.sub(pattern, '[REDACTED]', sanitized, flags=re.IGNORECASE)\n    \n    return sanitized\n","size_bytes":3194},"utils/rate_limiter.py":{"content":"import time\nfrom typing import Dict, List\nfrom dataclasses import dataclass, field\nfrom config import Config\n\nconfig = Config()\n\n@dataclass\nclass UserLimitData:\n    \"\"\"User rate limit tracking data\"\"\"\n    requests: List[float] = field(default_factory=list)\n    blocked_until: float = 0.0\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self):\n        self.users: Dict[int, UserLimitData] = {}\n        self.max_requests = config.RATE_LIMIT_MESSAGES\n        self.time_window = config.RATE_LIMIT_WINDOW\n        self.block_duration = 300  # 5 minutes block\n    \n    def is_allowed(self, user_id: int) -> bool:\n        \"\"\"Check if user is allowed to make a request\"\"\"\n        current_time = time.time()\n        \n        # Get or create user data\n        if user_id not in self.users:\n            self.users[user_id] = UserLimitData()\n        \n        user_data = self.users[user_id]\n        \n        # Check if user is currently blocked\n        if user_data.blocked_until > current_time:\n            return False\n        \n        # Clean old requests\n        cutoff_time = current_time - self.time_window\n        user_data.requests = [req_time for req_time in user_data.requests if req_time > cutoff_time]\n        \n        # Check rate limit\n        if len(user_data.requests) >= self.max_requests:\n            # Block user\n            user_data.blocked_until = current_time + self.block_duration\n            return False\n        \n        # Record request\n        user_data.requests.append(current_time)\n        return True\n    \n    def get_reset_time(self, user_id: int) -> float:\n        \"\"\"Get time when user's rate limit resets\"\"\"\n        if user_id not in self.users:\n            return 0.0\n        \n        user_data = self.users[user_id]\n        current_time = time.time()\n        \n        if user_data.blocked_until > current_time:\n            return user_data.blocked_until\n        \n        if user_data.requests:\n            return user_data.requests[0] + self.time_window\n        \n        return 0.0\n    \n    def cleanup_old_data(self):\n        \"\"\"Clean up old user data to prevent memory leaks\"\"\"\n        current_time = time.time()\n        cutoff_time = current_time - (self.time_window * 2)  # Keep data for 2x window\n        \n        users_to_remove = []\n        for user_id, user_data in self.users.items():\n            if (user_data.blocked_until < current_time and \n                not user_data.requests):\n                users_to_remove.append(user_id)\n            else:\n                # Clean old requests\n                user_data.requests = [req for req in user_data.requests if req > cutoff_time]\n        \n        for user_id in users_to_remove:\n            del self.users[user_id]\n\n# Global rate limiter instance\nrate_limiter = RateLimiter()\n","size_bytes":2796},"debug_last_request.py":{"content":"#!/usr/bin/env python3\nimport asyncio\nimport aiosqlite\nimport os\nimport json\n\nasync def debug_last_request():\n    \"\"\"Debug the last generation request\"\"\"\n    \n    try:\n        async with aiosqlite.connect('bot_database.db') as db:\n            # Get the latest generation\n            async with db.execute('''\n                SELECT task_id, veo_task_id, prompt, image_url, generation_type, created_at\n                FROM video_generations \n                ORDER BY created_at DESC LIMIT 1\n            ''') as cursor:\n                row = await cursor.fetchone()\n                \n                if row:\n                    task_id, veo_task_id, prompt, image_url, generation_type, created_at = row\n                    print(f\"Latest generation:\")\n                    print(f\"  Task ID: {task_id}\")\n                    print(f\"  Veo Task ID: {veo_task_id}\")\n                    print(f\"  Type: {generation_type}\")\n                    print(f\"  Prompt: {prompt}\")\n                    print(f\"  Image URL: {image_url}\")\n                    print(f\"  Created: {created_at}\")\n                    \n                    # Check if image file exists\n                    if image_url and \"attached_assets\" in image_url:\n                        # Extract local path\n                        import re\n                        path_match = re.search(r'attached_assets/[^\"]+\\.jpg', image_url)\n                        if path_match:\n                            local_path = path_match.group(0)\n                            if os.path.exists(local_path):\n                                file_size = os.path.getsize(local_path)\n                                print(f\"  ✅ Image file exists: {local_path} ({file_size} bytes)\")\n                            else:\n                                print(f\"  ❌ Image file NOT found: {local_path}\")\n                        else:\n                            print(f\"  ❌ Can't extract path from URL: {image_url}\")\n                    \n                    # Check what API endpoints return for this task\n                    if veo_task_id:\n                        await test_api_response(veo_task_id)\n                else:\n                    print(\"No generations found\")\n                    \n    except Exception as e:\n        print(f\"Error: {e}\")\n\nasync def test_api_response(veo_task_id):\n    \"\"\"Test API response for task\"\"\"\n    import aiohttp\n    \n    api_key = os.getenv(\"VEO_API_KEY\")\n    if not api_key:\n        print(\"No API key available\")\n        return\n        \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Test the main generation endpoint to see if we can get task info\n    async with aiohttp.ClientSession() as session:\n        # Try a simple API test\n        try:\n            async with session.post(\n                \"https://api.kie.ai/api/v1/veo/generate\",\n                headers=headers,\n                json={\"prompt\": \"test\"},\n                timeout=aiohttp.ClientTimeout(total=10)\n            ) as response:\n                print(f\"\\n  API Test with minimal request:\")\n                print(f\"  Status: {response.status}\")\n                text = await response.text()\n                print(f\"  Response: {text[:200]}...\")\n                \n                if response.status == 200:\n                    try:\n                        data = json.loads(text)\n                        print(f\"  ✅ API is working, got: {data}\")\n                    except:\n                        pass\n                        \n        except Exception as e:\n            print(f\"  API test error: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(debug_last_request())","size_bytes":3675},"webhook_server.py":{"content":"import asyncio\nimport logging\nimport ipaddress\nimport time\nfrom collections import defaultdict\nfrom aiohttp import web, ClientSession\nfrom config import Config\nfrom database.database import db\nfrom api_integrations.veo_api import VeoAPI\nfrom api_integrations.payment_api import PaymentAPI\nfrom utils.logger import get_logger\nimport json\n\nlogger = get_logger(__name__)\nconfig = Config()\n\n# Rate limiting for webhooks (simple in-memory implementation)\nWEBHOOK_RATE_LIMITS = defaultdict(list)  # {ip: [timestamp1, timestamp2, ...]}\nWEBHOOK_RATE_LIMIT_WINDOW = 60  # seconds\nWEBHOOK_RATE_LIMIT_MAX_REQUESTS = 10  # max requests per window\n\ndef check_webhook_rate_limit(ip: str) -> bool:\n    \"\"\"Check if IP is within webhook rate limits\"\"\"\n    now = time.time()\n    \n    # Clean old timestamps\n    WEBHOOK_RATE_LIMITS[ip] = [\n        ts for ts in WEBHOOK_RATE_LIMITS[ip] \n        if now - ts < WEBHOOK_RATE_LIMIT_WINDOW\n    ]\n    \n    # Check if limit exceeded\n    if len(WEBHOOK_RATE_LIMITS[ip]) >= WEBHOOK_RATE_LIMIT_MAX_REQUESTS:\n        return False\n    \n    # Add current request\n    WEBHOOK_RATE_LIMITS[ip].append(now)\n    return True\n\n# YooKassa official IP ranges for webhook security (updated 2024)\nYOOKASSA_IP_RANGES = [\n    '185.71.76.0/27',\n    '185.71.77.0/27', \n    '77.75.153.0/25',\n    '77.75.154.0/25',\n    '77.75.154.128/25',  # Added correct range for IP 77.75.154.206 (covers .128-.255)\n    '77.75.156.11/32',\n    '77.75.156.35/32',\n    '2a02:5180:0:1509::/64',\n    '2a02:5180:0:2655::/64'\n]\n\ndef is_yookassa_ip(ip_address: str) -> bool:\n    \"\"\"Check if IP address is from YooKassa official ranges\"\"\"\n    try:\n        client_ip = ipaddress.ip_address(ip_address)\n        for ip_range in YOOKASSA_IP_RANGES:\n            if client_ip in ipaddress.ip_network(ip_range, strict=False):\n                return True\n        return False\n    except ValueError:\n        logger.error(f\"Invalid IP address format: {ip_address}\")\n        return False\n\nasync def handle_veo_callback(request):\n    \"\"\"Handle Veo API completion callbacks\"\"\"\n    try:\n        # Get task ID from URL path\n        task_id = request.match_info.get('task_id')\n        if not task_id:\n            logger.error(\"No task_id in callback URL\")\n            return web.Response(text=\"Missing task_id\", status=400)\n        \n        # Parse callback data\n        callback_data = await request.json()\n        logger.info(f\"Received Veo callback for task {task_id}: {callback_data}\")\n        \n        # Extract video information from callback\n        status = callback_data.get(\"status\", \"unknown\")\n        video_url = callback_data.get(\"video_url\") or callback_data.get(\"videoUrl\") or callback_data.get(\"url\")\n        error_message = callback_data.get(\"error\") or callback_data.get(\"message\")\n        \n        # Get user ID from database using task_id\n        async with db.get_sqlite_connection() as conn:\n            cursor = await conn.execute(\n                \"SELECT user_id FROM video_generations WHERE task_id = ?\",\n                (task_id,)\n            )\n            row = await cursor.fetchone()\n            if not row:\n                logger.error(f\"Video task not found: {task_id}\")\n                return web.Response(text=\"Task not found\", status=404)\n            \n            user_id = row[0]\n        \n        # Initialize VeoAPI for user notification\n        veo_api = VeoAPI()\n        \n        if status == \"completed\" or status == \"success\":\n            if video_url:\n                # Update database\n                await db.update_video_generation(task_id, \"completed\", video_url=video_url)\n                \n                # Notify user\n                await veo_api._notify_user_completion(user_id, video_url, task_id)\n                logger.info(f\"Video completed via callback: {task_id}\")\n            else:\n                logger.error(f\"Completed status but no video URL for task {task_id}\")\n                \n        elif status == \"failed\" or status == \"error\":\n            # Update database\n            error_msg = error_message or \"Generation failed\"\n            await db.update_video_generation(task_id, \"failed\", error_message=error_msg)\n            \n            # Notify user\n            await veo_api._notify_user_failure(user_id, error_msg)\n            logger.error(f\"Video failed via callback: {task_id} - {error_msg}\")\n        \n        return web.Response(text=\"OK\", status=200)\n        \n    except Exception as e:\n        logger.error(f\"Error handling Veo callback: {e}\")\n        return web.Response(text=\"Internal error\", status=500)\n\ndef get_real_ip(request):\n    \"\"\"Get real client IP address from request headers\"\"\"\n    # Check for forwarded IP headers (common in proxy setups)\n    forwarded_for = request.headers.get('X-Forwarded-For')\n    if forwarded_for:\n        # X-Forwarded-For can contain multiple IPs, take the first one\n        return forwarded_for.split(',')[0].strip()\n    \n    real_ip = request.headers.get('X-Real-IP')\n    if real_ip:\n        return real_ip\n    \n    # Fallback to direct connection IP\n    return request.remote\n\nasync def handle_yookassa_webhook(request):\n    \"\"\"Handle YooKassa payment webhook notifications with security checks\"\"\"\n    try:\n        # Get client IP and validate it's from YooKassa\n        client_ip = get_real_ip(request)\n        logger.info(f\"Received YooKassa webhook from IP: {client_ip}\")\n        \n        # SECURITY: Check rate limiting first\n        if not check_webhook_rate_limit(client_ip):\n            logger.warning(f\"Rate limit exceeded for webhook from IP: {client_ip}\")\n            return web.Response(text=\"Rate limit exceeded\", status=429)\n        \n        # Логируем все входящие запросы для отладки\n        logger.info(f\"Webhook request from IP: {client_ip}\")\n        logger.info(f\"Request headers: {dict(request.headers)}\")\n        \n        # Проверяем IP для дополнительной безопасности (убрали обход для localhost)\n        if not is_yookassa_ip(client_ip):\n            logger.warning(f\"Unauthorized webhook attempt from IP: {client_ip}\")\n            return web.Response(text=\"Forbidden\", status=403)\n        \n        # Get raw payload and signature for HMAC verification\n        raw_payload = await request.read()\n        signature = request.headers.get('X-Yookassa-Signature', '')\n        \n        # Parse webhook data\n        try:\n            webhook_data = await request.json()\n        except Exception as e:\n            logger.error(f\"Invalid JSON in YooKassa webhook: {e}\")\n            return web.Response(text=\"Invalid JSON\", status=400)\n        \n        logger.info(f\"Processing YooKassa webhook: {webhook_data.get('event', 'unknown')}\")\n        \n        # Process webhook using PaymentAPI with HMAC verification\n        payment_api = PaymentAPI()\n        success = await payment_api.process_yookassa_webhook(webhook_data, raw_payload, signature)\n        \n        if success:\n            logger.info(\"YooKassa webhook processed successfully\")\n        else:\n            logger.error(\"Failed to process YooKassa webhook\")\n        \n        # Always return 200 OK to YooKassa regardless of processing result\n        # This prevents them from retrying the webhook\n        return web.Response(text=\"OK\", status=200)\n        \n    except Exception as e:\n        logger.error(f\"Error handling YooKassa webhook: {e}\")\n        # Still return 200 to prevent retries\n        return web.Response(text=\"OK\", status=200)\n\nasync def init_webhook_server():\n    \"\"\"Initialize and start the webhook server\"\"\"\n    app = web.Application()\n    \n    # Add webhook routes\n    app.router.add_post('/webhook/veo-complete/{task_id}', handle_veo_callback)\n    app.router.add_post('/webhook/yookassa', handle_yookassa_webhook)\n    \n    # Health check endpoint\n    async def health(request):\n        return web.Response(text=\"OK\")\n    \n    # Root endpoint for basic connectivity\n    async def root(request):\n        return web.Response(text=\"Telegram Bot Server Running\", status=200)\n    \n    app.router.add_get('/health', health)\n    app.router.add_get('/', root)\n    \n    return app\n\nif __name__ == \"__main__\":\n    # This file is now imported by main.py, not run directly\n    print(\"This module should be imported by main.py, not run directly\")","size_bytes":8288},"utils/payment_monitor.py":{"content":"\"\"\"\nPayment monitoring utility to check successful payments and notify users\n\"\"\"\n\nimport asyncio\nfrom typing import List\nfrom datetime import datetime, timedelta\nimport re\n\nfrom api_integrations.payment_api import PaymentAPI\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass PaymentMonitor:\n    def __init__(self):\n        self.payment_api = PaymentAPI()\n        self.processed_payments = set()  # Keep track of processed payment IDs\n        self.check_interval = 15  # Check every 15 seconds for faster processing\n        \n    async def check_recent_payments(self, lookback_minutes: int = 60):\n        \"\"\"Check recent log entries for payment IDs and verify their status\"\"\"\n        try:\n            import os\n            \n            # Look for payment creation logs in recent output\n            # This is a simple approach - in production you'd store payment IDs in DB\n            \n            # Read recent logs to find payment IDs\n            payment_ids = []\n            \n            # Try to find payment IDs from recent bot activity\n            # In a real system, you'd have a proper payment tracking table\n            \n            logger.info(f\"Checking recent payments from last {lookback_minutes} minutes\")\n            \n            # Get recent payment IDs from database instead of hardcoded list\n            from database.database import db\n            \n            # Get recent payment IDs that might need checking\n            recent_payment_ids = await self.get_recent_payment_ids_from_db(lookback_minutes)\n            \n            for payment_id in recent_payment_ids:\n                if payment_id not in self.processed_payments:\n                    await self.check_and_process_payment(payment_id)\n                    \n        except Exception as e:\n            logger.error(f\"Error checking recent payments: {e}\")\n    \n    async def get_recent_payment_ids_from_db(self, lookback_minutes: int = 60) -> List[str]:\n        \"\"\"Get recent payment IDs from database that might need verification\"\"\"\n        try:\n            from database.database import db\n            from datetime import datetime, timedelta\n            \n            # Get payment IDs from recent transactions that might not be completed\n            cutoff_time = datetime.now() - timedelta(minutes=lookback_minutes)\n            \n            if db.use_postgres:\n                pool = await db.get_postgres_pool()\n                async with pool.acquire() as conn:\n                    rows = await conn.fetch(\"\"\"\n                        SELECT DISTINCT payment_id FROM transactions \n                        WHERE payment_id IS NOT NULL \n                        AND created_at > $1 \n                        AND type = 'credit_purchase'\n                        AND payment_method = 'yookassa'\n                    \"\"\", cutoff_time)\n                    \n                    return [row[0] for row in rows if row[0]]\n            else:\n                async with db.get_sqlite_connection() as conn:\n                    cursor = await conn.execute(\"\"\"\n                        SELECT DISTINCT payment_id FROM transactions \n                        WHERE payment_id IS NOT NULL \n                        AND created_at > ? \n                        AND type = 'credit_purchase'\n                        AND payment_method = 'yookassa'\n                    \"\"\", (cutoff_time.isoformat(),))\n                    \n                    rows = await cursor.fetchall()\n                    return [row[0] for row in rows if row[0]]\n                \n        except Exception as e:\n            logger.error(f\"Error getting recent payment IDs from DB: {e}\")\n            return []\n    \n    async def check_and_process_payment(self, payment_id: str):\n        \"\"\"Check specific payment and process if successful\"\"\"\n        try:\n            result = await self.payment_api.verify_yookassa_payment(payment_id)\n            \n            if result.get('paid', False):\n                # Payment is successful, check if it was already processed\n                from database.database import db\n                payment_exists = await db.payment_exists(payment_id)\n                \n                if not payment_exists:\n                    # Process the payment\n                    metadata = result.get('metadata', {})\n                    user_id = metadata.get('user_id')\n                    package_id = metadata.get('package_id')\n                    amount = result.get('amount')\n                    \n                    if user_id and package_id and amount:\n                        logger.info(f\"Processing untracked successful payment: {payment_id}\")\n                        \n                        success = await self.payment_api._process_successful_card_payment(\n                            user_id=int(user_id),\n                            package_id=package_id,\n                            payment_id=payment_id,\n                            amount=float(amount)\n                        )\n                        \n                        if success:\n                            logger.info(f\"Successfully processed payment {payment_id}\")\n                            self.processed_payments.add(payment_id)\n                        else:\n                            logger.error(f\"Failed to process payment {payment_id}\")\n                else:\n                    # Payment already processed, just mark as seen to avoid re-notifications\n                    self.processed_payments.add(payment_id)\n            else:\n                logger.info(f\"Payment {payment_id} status: {result.get('status')}\")\n                \n        except Exception as e:\n            logger.error(f\"Error checking payment {payment_id}: {e}\")\n    \n    async def start_monitoring(self):\n        \"\"\"Start the payment monitoring loop\"\"\"\n        logger.info(\"Starting payment monitoring...\")\n        \n        while True:\n            try:\n                await self.check_recent_payments()\n                await asyncio.sleep(self.check_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in payment monitoring: {e}\")\n                await asyncio.sleep(self.check_interval)\n\n# Global instance\npayment_monitor = PaymentMonitor()","size_bytes":6218},"PAYMENT_SETUP_GUIDE.md":{"content":"# 🔧 Руководство по настройке уведомлений об оплате\n\n## 📋 Проблема\nВаш бот не получает уведомления об успешных оплатах через ЮКасса. Пользователи совершают платежи, но кредиты не зачисляются автоматически.\n\n## 🔍 Причины проблемы\n1. **Не настроены webhook'и в ЮКасса** - основная проблема\n2. **Ошибки в коде мониторинга платежей** - исправлены\n3. **Платежи отменяются** - нужно проверить настройки\n\n## ✅ Пошаговое решение\n\n### Шаг 1: Проверьте API ключи\nУбедитесь, что у вас правильно настроены переменные окружения:\n\n```bash\n# В Replit Secrets добавьте:\nYOOKASSA_API_KEY=your_api_key_here\nYOOKASSA_SHOP_ID=your_shop_id_here\n```\n\n**Где найти эти данные:**\n1. Войдите в личный кабинет ЮКасса: https://yookassa.ru/my\n2. Перейдите в **Настройки → API ключи**\n3. Скопируйте:\n   - **Shop ID** (идентификатор магазина)\n   - **Секретный ключ** (API Key)\n\n### Шаг 2: Настройте webhook URL\n1. Откройте файл `utils/setup_webhooks.py`\n2. Найдите строку с `replit_url` (строка 20)\n3. Замените на URL вашего приложения:\n\n```python\n# Замените это:\nreplit_url = \"https://your-repl-name.your-username.repl.co\"\n\n# На ваш реальный URL, например:\nreplit_url = \"https://telegram-bot.your-username.repl.co\"\n```\n\n**Как найти ваш URL:**\n- Откройте ваш Repl в браузере\n- Скопируйте URL из адресной строки\n- Уберите все после `.repl.co`\n\n### Шаг 3: Запустите настройку webhooks\nВыполните команды в терминале:\n\n```bash\n# Установите зависимости (если нужно)\npip install aiohttp\n\n# Запустите настройку webhooks\npython utils/setup_webhooks.py\n```\n\nВы должны увидеть:\n```\n✅ Webhook created for event: payment.succeeded\n✅ Webhook created for event: payment.canceled\n✅ Webhook created for event: payment.waiting_for_capture\n✅ Webhook created for event: refund.succeeded\n🎉 All webhooks configured successfully!\n```\n\n### Шаг 4: Проверьте настройки в ЮКасса\n1. Войдите в личный кабинет ЮКасса\n2. Перейдите в **Настройки → HTTP уведомления**\n3. Проверьте, что webhook'и добавились с правильным URL\n\n### Шаг 5: Перезапустите бота\n```bash\n# Перезапустите workflow\npython main.py\n```\n\n## 🧪 Тестирование\n\n### 1. Проверьте работу webhook endpoint'а\nОткройте в браузере: `https://your-app-url.repl.co/health`\nДолжно показать: `OK`\n\n### 2. Тестовый платеж\n1. Создайте тестовый платеж через бота\n2. Проследите логи на предмет:\n   ```\n   INFO - Received YooKassa webhook from IP: [IP]\n   INFO - Processing YooKassa webhook: payment.succeeded\n   INFO - YooKassa webhook processed successfully\n   ```\n\n### 3. Проверьте статус платежа\n```bash\n# В логах должно быть:\nINFO - Payment processed successfully: user=123, payment_id=xxx, credits=10\n```\n\n## ❗ Возможные проблемы и решения\n\n### Проблема: \"Webhook creation error 400\"\n**Решение:** Проверьте URL webhook'а - он должен быть доступен по HTTPS\n\n### Проблема: \"YooKassa credentials not configured\"\n**Решение:** \n1. Убедитесь, что API ключи добавлены в Replit Secrets\n2. Перезапустите приложение\n\n### Проблема: Платежи все еще отменяются\n**Возможные причины:**\n1. **Неправильный email в чеке** - проверьте строку 68 в `payment_api.py`\n2. **Проблемы с 54-ФЗ** - убедитесь что у вас правильная категория товара\n3. **Тестовый режим** - проверьте что используете правильные ключи\n\n### Проблема: Webhook'и не приходят\n1. Проверьте что ваш Repl работает (не засыпает)\n2. Убедитесь что порт 5000 открыт\n3. Проверьте логи на ошибки запуска webhook сервера\n\n## 🔧 Дополнительные настройки\n\n### Увеличение времени жизни Repl\nДобавьте в `main.py` keep-alive механизм:\n```python\n# Уже есть в коде - webhook server работает 24/7\n```\n\n### Настройка мониторинга\nPayment monitor теперь работает правильно и проверяет платежи из базы данных каждые 15 секунд.\n\n## 📞 Поддержка\n\nЕсли проблемы остаются:\n1. Проверьте логи бота на ошибки\n2. Убедитесь что все environment variables установлены\n3. Протестируйте webhook URL вручную\n\n**Важно:** После настройки webhook'ов платежи должны обрабатываться автоматически без задержек!","size_bytes":5813},"utils/setup_webhooks.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nUtility to setup YooKassa webhooks for payment notifications\nRun this script once to configure webhooks in your YooKassa account\n\"\"\"\n\nimport asyncio\nimport aiohttp\nimport base64\nimport json\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass YooKassaWebhookSetup:\n    def __init__(self):\n        self.yookassa_api_key = config.YOOKASSA_API_KEY\n        self.yookassa_shop_id = config.YOOKASSA_SHOP_ID\n        self.yookassa_base_url = \"https://api.yookassa.ru/v3\"\n        \n    def get_webhook_url(self):\n        \"\"\"Get the webhook URL for your Replit app\"\"\"\n        # Replace with your actual Replit app URL\n        replit_url = \"https://your-repl-name.your-username.repl.co\"  # Update this!\n        return f\"{replit_url}/webhook/yookassa\"\n    \n    async def setup_webhooks(self):\n        \"\"\"Setup webhooks for payment notifications\"\"\"\n        \n        if not self.yookassa_api_key or not self.yookassa_shop_id:\n            logger.error(\"❌ YooKassa credentials not configured!\")\n            logger.error(\"Please set YOOKASSA_API_KEY and YOOKASSA_SHOP_ID environment variables\")\n            return False\n            \n        webhook_url = self.get_webhook_url()\n        logger.info(f\"Setting up webhook URL: {webhook_url}\")\n        \n        # Events we want to receive notifications for\n        events = [\n            \"payment.succeeded\",\n            \"payment.canceled\", \n            \"payment.waiting_for_capture\",\n            \"refund.succeeded\"\n        ]\n        \n        success = True\n        \n        for event in events:\n            if await self.create_webhook(event, webhook_url):\n                logger.info(f\"✅ Webhook created for event: {event}\")\n            else:\n                logger.error(f\"❌ Failed to create webhook for event: {event}\")\n                success = False\n        \n        if success:\n            logger.info(\"🎉 All webhooks configured successfully!\")\n            logger.info(\"💡 Make sure your app is running on the webhook URL\")\n        else:\n            logger.error(\"⚠️ Some webhooks failed to configure\")\n            \n        return success\n    \n    async def create_webhook(self, event: str, webhook_url: str) -> bool:\n        \"\"\"Create a single webhook for specific event\"\"\"\n        try:\n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\",\n                \"Idempotence-Key\": f\"webhook-{event}-setup\"\n            }\n            \n            webhook_data = {\n                \"event\": event,\n                \"url\": webhook_url\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.yookassa_base_url}/webhooks\",\n                    headers=headers,\n                    json=webhook_data,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status in [200, 201]:\n                        result = await response.json()\n                        logger.debug(f\"Webhook created: {result}\")\n                        return True\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"YooKassa webhook creation error {response.status}: {error_text}\")\n                        return False\n                        \n        except Exception as e:\n            logger.error(f\"Error creating webhook for {event}: {e}\")\n            return False\n    \n    async def list_webhooks(self):\n        \"\"\"List existing webhooks\"\"\"\n        try:\n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.get(\n                    f\"{self.yookassa_base_url}/webhooks\",\n                    headers=headers,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        logger.info(\"📋 Current webhooks:\")\n                        \n                        webhooks = result.get(\"items\", [])\n                        if not webhooks:\n                            logger.info(\"   No webhooks configured\")\n                        else:\n                            for webhook in webhooks:\n                                logger.info(f\"   {webhook['event']} -> {webhook['url']}\")\n                        \n                        return webhooks\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"Error listing webhooks {response.status}: {error_text}\")\n                        return []\n                        \n        except Exception as e:\n            logger.error(f\"Error listing webhooks: {e}\")\n            return []\n\nasync def main():\n    \"\"\"Main function to run webhook setup\"\"\"\n    print(\"🔧 YooKassa Webhook Setup Utility\")\n    print(\"=\" * 40)\n    \n    setup = YooKassaWebhookSetup()\n    \n    # First, list existing webhooks\n    print(\"\\n📋 Checking existing webhooks...\")\n    await setup.list_webhooks()\n    \n    # Setup new webhooks\n    print(f\"\\n🔗 Setting up webhooks for URL: {setup.get_webhook_url()}\")\n    print(\"⚠️  IMPORTANT: Update the webhook URL in this script with your actual Replit app URL!\")\n    \n    success = await setup.setup_webhooks()\n    \n    if success:\n        print(\"\\n✅ Webhook setup completed successfully!\")\n        print(\"\\n📝 Next steps:\")\n        print(\"1. Make sure your bot is running on the webhook URL\")\n        print(\"2. Test a payment to verify webhooks work\")\n        print(\"3. Check logs for incoming webhook notifications\")\n    else:\n        print(\"\\n❌ Webhook setup failed!\")\n        print(\"Please check your YooKassa API credentials and try again\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":6478},"WEBHOOK_SETUP.md":{"content":"# 🔧 Настройка Webhook URLs для YooKassa\n\n## Проблема\nПри локальном запуске webhooks работают, но при деплое не приходят уведомления о платежах.\n\n## Причина\nYooKassa отправляет webhooks на URL, который был настроен при создании платежа. При переходе с локального запуска на деплой URL меняется:\n\n- **Локальный запуск**: `https://xxx.replit.dev/webhook/yookassa`  \n- **Продакшн деплой**: `https://xxx.replit.app/webhook/yookassa`\n\n## ✅ Решение\n\n### 1. Узнайте URL вашего деплоя\nПосле деплоя ваш URL будет в формате: `https://your-app-name.replit.app`\n\n### 2. Обновите Webhook URL в YooKassa\n1. Войдите в личный кабинет YooKassa\n2. Перейдите в настройки магазина\n3. Найдите раздел \"HTTP уведомления\" или \"Webhooks\"\n4. Обновите URL на: `https://your-app-name.replit.app/webhook/yookassa`\n\n### 3. Важные настройки\n- **Метод**: POST\n- **Формат**: JSON\n- **События**: `payment.succeeded`, `payment.canceled`\n\n## 🔄 Альтернативное решение\nМожно использовать один URL для всех окружений, настроив переадресацию.\n\n## 📝 Примечание\n15-секундная задержка уведомлений - это нормально для обработки платежей YooKassa.","size_bytes":1658},"admin_tools/credit_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nИнструмент для ручного управления кредитами пользователей\n\"\"\"\nimport asyncio\nimport sys\nimport os\n\n# Добавляем корневую папку в путь\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom database.database import db, init_database\nfrom database.models import Transaction, TransactionType\n\nasync def add_credits_to_user(telegram_id: int, credits: int, description: str = \"Manual credit adjustment\"):\n    \"\"\"Добавить кредиты пользователю\"\"\"\n    await init_database()\n    \n    # Получаем пользователя\n    user = await db.get_user(telegram_id)\n    if not user:\n        print(f\"🤖 Пользователь с ID {telegram_id} не найден в базе данных\")\n        print(f\"📝 Создаю профиль пользователя...\")\n        \n        # Создаем пользователя\n        from database.models import User, UserStatus\n        new_user = User(\n            telegram_id=telegram_id,\n            credits=0,\n            status=UserStatus.REGULAR,\n            first_name=\"Неизвестно\",\n            username=None\n        )\n        \n        created = await db.create_user(new_user)\n        if not created:\n            print(f\"❌ Ошибка при создании пользователя\")\n            return False\n        \n        user = await db.get_user(telegram_id)\n        print(f\"✅ Пользователь создан\")\n    else:\n        print(f\"👤 Найден пользователь: {user.first_name} (@{user.username})\")\n    \n    print(f\"💰 Текущий баланс: {user.credits} кредитов\")\n    \n    # Обновляем кредиты\n    new_credits = user.credits + credits\n    success = await db.update_user_credits(telegram_id, new_credits)\n    \n    if success:\n        # Создаем запись транзакции\n        transaction = Transaction(\n            user_id=telegram_id,\n            type=TransactionType.ADMIN_GRANT,\n            amount=credits,\n            description=description\n        )\n        await db.create_transaction(transaction)\n        \n        print(f\"✅ Успешно добавлено {credits} кредитов\")\n        print(f\"💳 Новый баланс: {new_credits} кредитов\")\n        return True\n    else:\n        print(f\"❌ Ошибка при обновлении кредитов\")\n        return False\n\nasync def find_recent_payments(amount: int = 399):\n    \"\"\"Найти недавние платежи на определенную сумму\"\"\"\n    await init_database()\n    \n    print(f\"🔍 Поиск платежей на сумму {amount} рублей...\")\n    \n    # Здесь можно добавить логику поиска по транзакциям\n    # Пока что просто выводим инструкцию\n    print(\"💡 Для поиска пользователя используйте:\")\n    print(\"   - Telegram ID пользователя\")\n    print(\"   - Username пользователя\")\n\nasync def main():\n    \"\"\"Главная функция\"\"\"\n    if len(sys.argv) < 3:\n        print(\"📋 Использование:\")\n        print(f\"   python {sys.argv[0]} <telegram_id> <credits> [описание]\")\n        print(\"\\n🔍 Примеры:\")\n        print(f\"   python {sys.argv[0]} 123456789 35 'Компенсация за пакет 399₽'\")\n        print(f\"   python {sys.argv[0]} 123456789 -10 'Возврат ошибочного начисления'\")\n        return\n    \n    try:\n        telegram_id = int(sys.argv[1])\n        credits = int(sys.argv[2])\n        description = sys.argv[3] if len(sys.argv) > 3 else \"Manual credit adjustment\"\n        \n        print(f\"🎯 Начисление {credits} кредитов пользователю {telegram_id}\")\n        \n        success = await add_credits_to_user(telegram_id, credits, description)\n        \n        if success:\n            print(\"🎉 Операция выполнена успешно!\")\n        else:\n            print(\"💥 Операция не выполнена!\")\n            \n    except ValueError:\n        print(\"❌ Неверный формат данных. Telegram ID и количество кредитов должны быть числами.\")\n    except Exception as e:\n        print(f\"❌ Ошибка: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":4533},"admin_tools/credit_management.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nБезопасная система управления кредитами для администратора\nРаботает только на production (deploy), не на локальном запуске\n\"\"\"\n\nimport os\nimport asyncio\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any\nfrom database.database import db\nfrom database.models import User, Transaction, TransactionType, UserStatus, AdminLog\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass CreditManager:\n    \"\"\"Безопасный менеджер кредитов для администраторов\"\"\"\n    \n    def __init__(self):\n        self.is_production = self._is_production_environment()\n        \n    def _is_production_environment(self) -> bool:\n        \"\"\"Определяет, запущено ли приложение в production (на деплое)\"\"\"\n        # Проверяем наличие DATABASE_URL (означает Replit production)\n        database_url = os.getenv('DATABASE_URL')\n        replit_deployment = os.getenv('REPLIT_DEPLOYMENT') == '1'\n        \n        # Production если есть DATABASE_URL или явно указан деплой\n        return bool(database_url) or replit_deployment\n    \n    async def check_admin_permissions(self, admin_id: int) -> bool:\n        \"\"\"Проверяет права администратора\"\"\"\n        try:\n            admin = await db.get_user(admin_id)\n            if not admin or admin.status != UserStatus.ADMIN:\n                logger.warning(f\"Unauthorized credit management attempt by user {admin_id}\")\n                return False\n            return True\n        except Exception as e:\n            logger.error(f\"Error checking admin permissions for {admin_id}: {e}\")\n            return False\n    \n    async def get_user_credits(self, admin_id: int, target_user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Проверяет баланс кредитов пользователя\n        \n        Args:\n            admin_id: ID администратора\n            target_user_id: ID пользователя для проверки\n            \n        Returns:\n            Dict с информацией о кредитах или None при ошибке\n        \"\"\"\n        try:\n            # Проверяем права администратора\n            if not await self.check_admin_permissions(admin_id):\n                return {\"error\": \"Недостаточно прав для выполнения операции\"}\n            \n            # Получаем информацию о пользователе\n            user = await db.get_user(target_user_id)\n            if not user:\n                return {\"error\": f\"Пользователь {target_user_id} не найден\"}\n            \n            # Логируем проверку\n            await db.log_admin_action(AdminLog(\n                admin_id=admin_id,\n                action=\"check_credits\",\n                target_user_id=target_user_id,\n                description=f\"Проверка баланса пользователя {target_user_id}\"\n            ))\n            \n            return {\n                \"user_id\": user.telegram_id,\n                \"username\": user.username,\n                \"first_name\": user.first_name,\n                \"credits\": user.credits,\n                \"status\": user.status.value,\n                \"created_at\": user.created_at.isoformat() if user.created_at else None,\n                \"updated_at\": user.updated_at.isoformat() if user.updated_at else None\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error checking credits for user {target_user_id}: {e}\")\n            return {\"error\": f\"Ошибка при проверке кредитов: {str(e)}\"}\n    \n    async def grant_credits(self, admin_id: int, target_user_id: int, credits_amount: int, reason: str = \"\", bot=None) -> Dict[str, Any]:\n        \"\"\"\n        Выдает кредиты пользователю (только на production)\n        \n        Args:\n            admin_id: ID администратора\n            target_user_id: ID пользователя\n            credits_amount: Количество кредитов для выдачи\n            reason: Причина выдачи кредитов\n            \n        Returns:\n            Dict с результатом операции\n        \"\"\"\n        try:\n            # КРИТИЧЕСКАЯ ПРОВЕРКА: только на production!\n            if not self.is_production:\n                logger.warning(f\"Credit grant attempt in non-production environment by admin {admin_id}\")\n                return {\n                    \"error\": \"Выдача кредитов доступна только на production (после deploy)\",\n                    \"environment\": \"local/development\"\n                }\n            \n            # Проверяем права администратора\n            if not await self.check_admin_permissions(admin_id):\n                return {\"error\": \"Недостаточно прав для выполнения операции\"}\n            \n            # Валидация количества кредитов\n            if not isinstance(credits_amount, int) or credits_amount <= 0:\n                return {\"error\": \"Количество кредитов должно быть положительным целым числом\"}\n            \n            if credits_amount > 1000:  # Лимит безопасности\n                return {\"error\": \"Максимальное количество кредитов за раз: 1000\"}\n            \n            # Получаем пользователя\n            user = await db.get_user(target_user_id)\n            if not user:\n                return {\"error\": f\"Пользователь {target_user_id} не найден\"}\n            \n            old_credits = user.credits\n            new_credits = old_credits + credits_amount\n            \n            # Обновляем кредиты\n            success = await db.update_user_credits(target_user_id, new_credits)\n            if not success:\n                return {\"error\": \"Ошибка при обновлении кредитов в базе данных\"}\n            \n            # Создаем транзакцию\n            transaction = Transaction(\n                user_id=target_user_id,\n                type=TransactionType.ADMIN_GRANT,\n                amount=credits_amount,\n                description=f\"Выдача кредитов администратором {admin_id}. Причина: {reason or 'Не указана'}\",\n                created_at=datetime.now()\n            )\n            \n            await db.create_transaction(transaction)\n            \n            # Логируем действие администратора\n            await db.log_admin_action(AdminLog(\n                admin_id=admin_id,\n                action=\"grant_credits\",\n                target_user_id=target_user_id,\n                description=f\"Выдано {credits_amount} кредитов. Баланс: {old_credits} → {new_credits}. Причина: {reason}\"\n            ))\n            \n            logger.info(f\"Admin {admin_id} granted {credits_amount} credits to user {target_user_id}. Balance: {old_credits} → {new_credits}\")\n            \n            # Отправляем уведомление пользователю, если есть бот\n            if bot:\n                try:\n                    notification_text = f\"\"\"\n🎉 <b>Вам начислены кредиты!</b>\n\n💎 <b>Получено кредитов:</b> {credits_amount}\n💰 <b>Ваш баланс:</b> {new_credits} кредитов\n\n📝 <b>Комментарий администратора:</b>\n{reason if reason else 'Без комментария'}\n\nТеперь вы можете создать {new_credits // 10} видео!\n                    \"\"\"\n                    \n                    await bot.send_message(target_user_id, notification_text)\n                    logger.info(f\"Notification sent to user {target_user_id} about credit grant\")\n                except Exception as e:\n                    logger.warning(f\"Failed to send notification to user {target_user_id}: {e}\")\n            \n            return {\n                \"success\": True,\n                \"user_id\": target_user_id,\n                \"credits_granted\": credits_amount,\n                \"old_balance\": old_credits,\n                \"new_balance\": new_credits,\n                \"reason\": reason,\n                \"timestamp\": datetime.now().isoformat(),\n                \"notification_sent\": bot is not None\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error granting credits to user {target_user_id}: {e}\")\n            return {\"error\": f\"Ошибка при выдаче кредитов: {str(e)}\"}\n\n# Глобальный экземпляр менеджера\ncredit_manager = CreditManager()\n\nasync def check_user_credits(admin_id: int, user_id: int) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Публичная функция для проверки кредитов пользователя\n    \n    Args:\n        admin_id: ID администратора\n        user_id: ID пользователя для проверки\n        \n    Returns:\n        Информация о кредитах пользователя\n    \"\"\"\n    return await credit_manager.get_user_credits(admin_id, user_id)\n\nasync def grant_user_credits(admin_id: int, user_id: int, credits: int, reason: str = \"\", bot=None) -> Dict[str, Any]:\n    \"\"\"\n    Публичная функция для выдачи кредитов пользователю\n    РАБОТАЕТ ТОЛЬКО НА PRODUCTION!\n    \n    Args:\n        admin_id: ID администратора\n        user_id: ID пользователя\n        credits: Количество кредитов\n        reason: Причина выдачи\n        \n    Returns:\n        Результат операции\n    \"\"\"\n    return await credit_manager.grant_credits(admin_id, user_id, credits, reason, bot)\n\n# Функция для быстрого восстановления кредитов при deploy\nasync def emergency_credit_restore(admin_id: int, user_id: int, credits: int, payment_id: str = \"\", bot=None) -> Dict[str, Any]:\n    \"\"\"\n    Экстренное восстановление кредитов (например, после технических проблем)\n    \n    Args:\n        admin_id: ID администратора\n        user_id: ID пользователя\n        credits: Количество кредитов\n        payment_id: ID платежа (если есть)\n        \n    Returns:\n        Результат операции\n    \"\"\"\n    reason = f\"Экстренное восстановление кредитов\"\n    if payment_id:\n        reason += f\" для платежа {payment_id}\"\n    \n    return await grant_user_credits(admin_id, user_id, credits, reason, bot)\n\nif __name__ == \"__main__\":\n    # Пример использования (только для тестирования)\n    async def main():\n        print(\"🔒 Credit Management System\")\n        print(f\"Production mode: {credit_manager.is_production}\")\n        \n        if credit_manager.is_production:\n            print(\"✅ Система готова к выдаче кредитов\")\n        else:\n            print(\"⚠️  Локальная среда - выдача кредитов заблокирована\")\n    \n    asyncio.run(main())","size_bytes":11830},"admin_tools/deploy_credit_tools.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nИнструменты для выдачи кредитов при deploy\nИспользуется для быстрого восстановления кредитов пользователей\n\"\"\"\n\nimport asyncio\nimport sys\nfrom typing import List, Dict, Any\nfrom credit_management import check_user_credits, grant_user_credits, emergency_credit_restore\nfrom database.database import db, init_database\nfrom config import Config\n\nconfig = Config()\n\nclass DeployCreditTools:\n    \"\"\"Инструменты для работы с кредитами при deploy\"\"\"\n    \n    def __init__(self):\n        self.admin_id = config.ADMIN_USER_ID\n        \n    async def batch_check_credits(self, user_ids: List[int]) -> Dict[int, Dict[str, Any]]:\n        \"\"\"Проверяет кредиты нескольких пользователей\"\"\"\n        results = {}\n        \n        print(f\"🔍 Проверяем кредиты {len(user_ids)} пользователей...\")\n        \n        for user_id in user_ids:\n            try:\n                result = await check_user_credits(self.admin_id, user_id)\n                results[user_id] = result\n                \n                if \"error\" not in result:\n                    print(f\"👤 {user_id}: {result['credits']} кредитов\")\n                else:\n                    print(f\"❌ {user_id}: {result['error']}\")\n                    \n            except Exception as e:\n                print(f\"❌ Ошибка при проверке {user_id}: {e}\")\n                results[user_id] = {\"error\": str(e)}\n        \n        return results\n    \n    async def batch_grant_credits(self, credit_assignments: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        Массовая выдача кредитов\n        \n        Args:\n            credit_assignments: список словарей с ключами:\n                - user_id: ID пользователя\n                - credits: количество кредитов\n                - reason: причина (опционально)\n                - payment_id: ID платежа (опционально)\n        \"\"\"\n        results = {\n            \"success\": [],\n            \"failed\": [],\n            \"total_credits_granted\": 0\n        }\n        \n        print(f\"💰 Начинаем массовую выдачу кредитов для {len(credit_assignments)} пользователей...\")\n        \n        for assignment in credit_assignments:\n            user_id = assignment.get(\"user_id\")\n            credits = assignment.get(\"credits\")\n            reason = assignment.get(\"reason\", \"Массовая выдача при deploy\")\n            payment_id = assignment.get(\"payment_id\", \"\")\n            \n            if not user_id or not credits:\n                print(f\"❌ Пропуск неверного задания: {assignment}\")\n                results[\"failed\"].append({\n                    \"assignment\": assignment,\n                    \"error\": \"Отсутствует user_id или credits\"\n                })\n                continue\n            \n            try:\n                if payment_id:\n                    result = await emergency_credit_restore(self.admin_id, user_id, credits, payment_id)\n                else:\n                    result = await grant_user_credits(self.admin_id, user_id, credits, reason)\n                \n                if result.get(\"success\"):\n                    print(f\"✅ {user_id}: +{credits} кредитов\")\n                    results[\"success\"].append(result)\n                    results[\"total_credits_granted\"] += credits\n                else:\n                    print(f\"❌ {user_id}: {result.get('error', 'Неизвестная ошибка')}\")\n                    results[\"failed\"].append({\n                        \"user_id\": user_id,\n                        \"credits\": credits,\n                        \"error\": result.get(\"error\")\n                    })\n                    \n            except Exception as e:\n                print(f\"❌ Ошибка при выдаче кредитов {user_id}: {e}\")\n                results[\"failed\"].append({\n                    \"user_id\": user_id,\n                    \"credits\": credits,\n                    \"error\": str(e)\n                })\n        \n        print(f\"\\n📊 Итоги массовой выдачи:\")\n        print(f\"✅ Успешно: {len(results['success'])}\")\n        print(f\"❌ Ошибок: {len(results['failed'])}\")\n        print(f\"💰 Всего выдано кредитов: {results['total_credits_granted']}\")\n        \n        return results\n    \n    async def restore_lost_payment(self, user_id: int, credits: int, payment_id: str) -> Dict[str, Any]:\n        \"\"\"Восстанавливает кредиты для потерянного платежа\"\"\"\n        print(f\"🚨 Восстанавливаем потерянный платеж...\")\n        print(f\"👤 Пользователь: {user_id}\")\n        print(f\"💰 Кредиты: {credits}\")\n        print(f\"💳 Платеж: {payment_id}\")\n        \n        result = await emergency_credit_restore(self.admin_id, user_id, credits, payment_id)\n        \n        if result.get(\"success\"):\n            print(f\"✅ УСПЕШНО! Восстановлено {credits} кредитов\")\n        else:\n            print(f\"❌ ОШИБКА: {result.get('error')}\")\n        \n        return result\n\nasync def main():\n    \"\"\"Основная функция для интерактивного использования\"\"\"\n    print(\"🚀 Deploy Credit Tools\")\n    print(\"=\" * 40)\n    \n    # Инициализируем базу данных\n    await init_database()\n    \n    tools = DeployCreditTools()\n    \n    if len(sys.argv) < 2:\n        print(\"Использование:\")\n        print(\"  python deploy_credit_tools.py check <user_id>\")\n        print(\"  python deploy_credit_tools.py grant <user_id> <credits> [reason]\")\n        print(\"  python deploy_credit_tools.py restore <user_id> <credits> <payment_id>\")\n        return\n    \n    command = sys.argv[1].lower()\n    \n    if command == \"check\" and len(sys.argv) >= 3:\n        user_id = int(sys.argv[2])\n        result = await check_user_credits(config.ADMIN_USER_ID, user_id)\n        print(f\"Результат: {result}\")\n        \n    elif command == \"grant\" and len(sys.argv) >= 4:\n        user_id = int(sys.argv[2])\n        credits = int(sys.argv[3])\n        reason = sys.argv[4] if len(sys.argv) > 4 else \"Deploy credit grant\"\n        \n        result = await grant_user_credits(config.ADMIN_USER_ID, user_id, credits, reason)\n        print(f\"Результат: {result}\")\n        \n    elif command == \"restore\" and len(sys.argv) >= 5:\n        user_id = int(sys.argv[2])\n        credits = int(sys.argv[3])\n        payment_id = sys.argv[4]\n        \n        result = await tools.restore_lost_payment(user_id, credits, payment_id)\n        print(f\"Результат: {result}\")\n        \n    else:\n        print(\"❌ Неверная команда или недостаточно аргументов\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":7174},"auto_migrate.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nАвтоматическая миграция данных при деплое\nЗапускается автоматически в build процессе\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport os\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\n# Настройка логирования\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - AUTO-MIGRATE - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# Импорт asyncpg только если доступен\ntry:\n    import asyncpg\n    POSTGRES_AVAILABLE = True\nexcept ImportError:\n    POSTGRES_AVAILABLE = False\n\nclass AutoMigrator:\n    def __init__(self):\n        self.sqlite_path = \"bot_database.db\"\n        self.postgres_url = os.getenv('DATABASE_URL')\n        \n        # Проверяем среду выполнения\n        self.is_deployment = os.getenv('REPLIT_DEPLOYMENT') == '1'\n        \n        logger.info(f\"AutoMigrator initialized:\")\n        logger.info(f\"  - Is deployment: {self.is_deployment}\")\n        logger.info(f\"  - PostgreSQL available: {POSTGRES_AVAILABLE}\")\n        logger.info(f\"  - DATABASE_URL present: {bool(self.postgres_url)}\")\n        logger.info(f\"  - SQLite file exists: {os.path.exists(self.sqlite_path)}\")\n    \n    async def should_migrate(self) -> bool:\n        \"\"\"Определить нужно ли делать миграцию\"\"\"\n        # Миграция нужна если:\n        # 1. Это deployment среда\n        # 2. Есть PostgreSQL\n        # 3. Есть SQLite файл с данными\n        # 4. PostgreSQL база пустая или содержит меньше данных\n        \n        if not self.is_deployment:\n            logger.info(\"Not in deployment - skipping migration\")\n            return False\n            \n        if not POSTGRES_AVAILABLE or not self.postgres_url:\n            logger.info(\"PostgreSQL not available - skipping migration\")\n            return False\n            \n        if not os.path.exists(self.sqlite_path):\n            logger.info(\"No SQLite file found - skipping migration\")\n            return False\n        \n        # Проверяем количество пользователей в SQLite\n        sqlite_users = await self.count_sqlite_users()\n        if sqlite_users == 0:\n            logger.info(\"No users in SQLite - skipping migration\")\n            return False\n        \n        # Проверяем количество пользователей в PostgreSQL\n        postgres_users = await self.count_postgres_users()\n        \n        logger.info(f\"Users count: SQLite={sqlite_users}, PostgreSQL={postgres_users}\")\n        \n        # Мигрируем если в SQLite больше пользователей\n        should_migrate = sqlite_users > postgres_users\n        \n        if should_migrate:\n            logger.info(\"Migration needed - SQLite has more data\")\n        else:\n            logger.info(\"Migration not needed - PostgreSQL is up to date\")\n            \n        return should_migrate\n    \n    async def count_sqlite_users(self) -> int:\n        \"\"\"Подсчитать пользователей в SQLite\"\"\"\n        try:\n            async with aiosqlite.connect(self.sqlite_path) as db:\n                cursor = await db.execute(\"SELECT COUNT(*) FROM users\")\n                result = await cursor.fetchone()\n                return result[0] if result else 0\n        except Exception as e:\n            logger.warning(f\"Could not count SQLite users: {e}\")\n            return 0\n    \n    async def count_postgres_users(self) -> int:\n        \"\"\"Подсчитать пользователей в PostgreSQL\"\"\"\n        try:\n            conn = await asyncpg.connect(self.postgres_url)\n            try:\n                # Создаем таблицу если её нет\n                await self.create_postgres_tables(conn)\n                result = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n                return result if result else 0\n            finally:\n                await conn.close()\n        except Exception as e:\n            logger.warning(f\"Could not count PostgreSQL users: {e}\")\n            return 0\n    \n    async def create_postgres_tables(self, conn):\n        \"\"\"Создание таблиц в PostgreSQL\"\"\"\n        # Users table  \n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                telegram_id BIGINT PRIMARY KEY,\n                username TEXT,\n                first_name TEXT,\n                last_name TEXT,\n                credits INTEGER DEFAULT 0,\n                status TEXT DEFAULT 'regular',\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Transactions table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS transactions (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                type TEXT NOT NULL,\n                amount INTEGER NOT NULL,\n                description TEXT,\n                payment_method TEXT,\n                payment_id TEXT UNIQUE,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Video generations table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS video_generations (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                task_id TEXT UNIQUE,\n                veo_task_id TEXT,\n                prompt TEXT NOT NULL,\n                generation_type TEXT NOT NULL,\n                image_url TEXT,\n                model TEXT DEFAULT 'veo3_fast',\n                aspect_ratio TEXT DEFAULT '16:9',\n                status TEXT DEFAULT 'pending',\n                video_url TEXT,\n                error_message TEXT,\n                credits_spent INTEGER DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                completed_at TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Admin logs table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS admin_logs (\n                id SERIAL PRIMARY KEY,\n                admin_id BIGINT,\n                action TEXT NOT NULL,\n                target_user_id BIGINT,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Create indexes\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_payment_id ON transactions(payment_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_task_id ON video_generations(task_id)')\n    \n    async def migrate_data(self):\n        \"\"\"Автоматическая миграция данных\"\"\"\n        logger.info(\"Starting automatic data migration...\")\n        \n        try:\n            # Экспорт из SQLite\n            data = await self.export_sqlite_data()\n            \n            if not any(data.values()):\n                logger.warning(\"No data to migrate!\")\n                return\n            \n            # Импорт в PostgreSQL\n            await self.import_to_postgres(data)\n            \n            logger.info(\"✅ Automatic migration completed successfully!\")\n            \n        except Exception as e:\n            logger.error(f\"❌ Migration failed: {e}\")\n            # Не прерываем деплой из-за ошибки миграции\n            pass\n    \n    async def export_sqlite_data(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"Экспорт данных из SQLite\"\"\"\n        logger.info(\"Exporting data from SQLite...\")\n        \n        data = {\n            'users': [],\n            'transactions': [],\n            'video_generations': [],\n            'admin_logs': []\n        }\n        \n        async with aiosqlite.connect(self.sqlite_path) as db:\n            # Экспорт пользователей\n            async with db.execute(\"SELECT * FROM users\") as cursor:\n                async for row in cursor:\n                    data['users'].append({\n                        'telegram_id': row[0],\n                        'username': row[1],\n                        'first_name': row[2],\n                        'last_name': row[3],\n                        'credits': row[4],\n                        'status': row[5],\n                        'created_at': row[6],\n                        'updated_at': row[7]\n                    })\n            \n            # Экспорт транзакций\n            async with db.execute(\"SELECT * FROM transactions\") as cursor:\n                async for row in cursor:\n                    data['transactions'].append({\n                        'user_id': row[1],\n                        'type': row[2],\n                        'amount': row[3],\n                        'description': row[4],\n                        'payment_method': row[5],\n                        'payment_id': row[6],\n                        'created_at': row[7]\n                    })\n            \n            # Экспорт видео генераций\n            async with db.execute(\"SELECT * FROM video_generations\") as cursor:\n                async for row in cursor:\n                    data['video_generations'].append({\n                        'user_id': row[1],\n                        'task_id': row[2],\n                        'veo_task_id': row[3] if len(row) > 3 else None,\n                        'prompt': row[4] if len(row) > 4 else row[3],\n                        'generation_type': row[5] if len(row) > 5 else row[4],\n                        'image_url': row[6] if len(row) > 6 else row[5],\n                        'model': row[7] if len(row) > 7 else row[6],\n                        'aspect_ratio': row[8] if len(row) > 8 else row[7],\n                        'status': row[9] if len(row) > 9 else row[8],\n                        'video_url': row[10] if len(row) > 10 else row[9],\n                        'error_message': row[11] if len(row) > 11 else row[10],\n                        'credits_spent': row[12] if len(row) > 12 else row[11],\n                        'created_at': row[13] if len(row) > 13 else row[12],\n                        'completed_at': row[14] if len(row) > 14 else row[13]\n                    })\n            \n            # Экспорт админ логов\n            try:\n                async with db.execute(\"SELECT * FROM admin_logs\") as cursor:\n                    async for row in cursor:\n                        data['admin_logs'].append({\n                            'admin_id': row[1],\n                            'action': row[2],\n                            'target_user_id': row[3],\n                            'description': row[4],\n                            'created_at': row[5]\n                        })\n            except Exception as e:\n                logger.warning(f\"Could not export admin_logs: {e}\")\n        \n        logger.info(f\"Exported: {len(data['users'])} users, \"\n                   f\"{len(data['transactions'])} transactions, \"\n                   f\"{len(data['video_generations'])} videos, \"\n                   f\"{len(data['admin_logs'])} admin logs\")\n        \n        return data\n    \n    async def import_to_postgres(self, data: Dict[str, List[Dict[str, Any]]]):\n        \"\"\"Импорт данных в PostgreSQL\"\"\"\n        logger.info(\"Importing data to PostgreSQL...\")\n        \n        conn = await asyncpg.connect(self.postgres_url)\n        try:\n            # Создаем таблицы\n            await self.create_postgres_tables(conn)\n            \n            # Импорт пользователей\n            for user in data['users']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                        ON CONFLICT (telegram_id) DO UPDATE SET\n                        username = EXCLUDED.username,\n                        first_name = EXCLUDED.first_name,\n                        last_name = EXCLUDED.last_name,\n                        credits = EXCLUDED.credits,\n                        status = EXCLUDED.status,\n                        updated_at = EXCLUDED.updated_at\n                    ''', \n                        user['telegram_id'],\n                        user['username'],\n                        user['first_name'],\n                        user['last_name'],\n                        user['credits'],\n                        user['status'],\n                        datetime.fromisoformat(user['created_at']) if isinstance(user['created_at'], str) else user['created_at'],\n                        datetime.fromisoformat(user['updated_at']) if isinstance(user['updated_at'], str) else user['updated_at']\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import user {user['telegram_id']}: {e}\")\n            \n            # Импорт транзакций\n            for transaction in data['transactions']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                        ON CONFLICT (payment_id) DO NOTHING\n                    ''', \n                        transaction['user_id'],\n                        transaction['type'],\n                        transaction['amount'],\n                        transaction['description'],\n                        transaction['payment_method'],\n                        transaction['payment_id'],\n                        datetime.fromisoformat(transaction['created_at']) if isinstance(transaction['created_at'], str) else transaction['created_at']\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import transaction: {e}\")\n            \n            # Импорт видео генераций\n            for video in data['video_generations']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, video_url, error_message, credits_spent, created_at, completed_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\n                        ON CONFLICT (task_id) DO NOTHING\n                    ''', \n                        video['user_id'],\n                        video['task_id'],\n                        video['veo_task_id'],\n                        video['prompt'],\n                        video['generation_type'],\n                        video['image_url'],\n                        video['model'],\n                        video['aspect_ratio'],\n                        video['status'],\n                        video['video_url'],\n                        video['error_message'],\n                        video['credits_spent'],\n                        datetime.fromisoformat(video['created_at']) if isinstance(video['created_at'], str) else video['created_at'],\n                        datetime.fromisoformat(video['completed_at']) if isinstance(video['completed_at'], str) and video['completed_at'] else None\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import video generation: {e}\")\n            \n            # Импорт админ логов\n            for log in data['admin_logs']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES ($1, $2, $3, $4, $5)\n                    ''', \n                        log['admin_id'],\n                        log['action'],\n                        log['target_user_id'],\n                        log['description'],\n                        datetime.fromisoformat(log['created_at']) if isinstance(log['created_at'], str) else log['created_at']\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import admin log: {e}\")\n                    \n        finally:\n            await conn.close()\n        \n        logger.info(\"PostgreSQL import completed\")\n\nasync def main():\n    \"\"\"Главная функция автоматической миграции\"\"\"\n    migrator = AutoMigrator()\n    \n    if await migrator.should_migrate():\n        await migrator.migrate_data()\n    else:\n        logger.info(\"Migration not needed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":17365},"database_migration.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nDatabase Migration Tool\nПереносит данные из SQLite (development) в PostgreSQL (production)\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport asyncpg\nimport logging\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\n# Настройка логирования\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass DatabaseMigrator:\n    def __init__(self):\n        self.sqlite_path = \"bot_database.db\"\n        self.postgres_url = os.getenv('DATABASE_URL')\n        \n        if not self.postgres_url:\n            raise ValueError(\"DATABASE_URL environment variable is required\")\n    \n    async def export_sqlite_data(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"Экспорт данных из SQLite\"\"\"\n        logger.info(\"Начинаем экспорт данных из SQLite...\")\n        \n        data = {\n            'users': [],\n            'transactions': [],\n            'video_generations': [],\n            'admin_logs': []\n        }\n        \n        if not os.path.exists(self.sqlite_path):\n            logger.warning(f\"SQLite файл {self.sqlite_path} не найден!\")\n            return data\n        \n        async with aiosqlite.connect(self.sqlite_path) as db:\n            # Экспорт пользователей\n            async with db.execute(\"SELECT * FROM users\") as cursor:\n                async for row in cursor:\n                    data['users'].append({\n                        'telegram_id': row[0],\n                        'username': row[1],\n                        'first_name': row[2],\n                        'last_name': row[3],\n                        'credits': row[4],\n                        'status': row[5],\n                        'created_at': row[6],\n                        'updated_at': row[7]\n                    })\n            \n            # Экспорт транзакций\n            async with db.execute(\"SELECT * FROM transactions\") as cursor:\n                async for row in cursor:\n                    data['transactions'].append({\n                        'id': row[0],\n                        'user_id': row[1],\n                        'type': row[2],\n                        'amount': row[3],\n                        'description': row[4],\n                        'payment_method': row[5],\n                        'payment_id': row[6],\n                        'created_at': row[7]\n                    })\n            \n            # Экспорт видео генераций\n            async with db.execute(\"SELECT * FROM video_generations\") as cursor:\n                async for row in cursor:\n                    data['video_generations'].append({\n                        'id': row[0],\n                        'user_id': row[1],\n                        'task_id': row[2],\n                        'veo_task_id': row[3] if len(row) > 3 else None,\n                        'prompt': row[4] if len(row) > 4 else row[3],\n                        'generation_type': row[5] if len(row) > 5 else row[4],\n                        'image_url': row[6] if len(row) > 6 else row[5],\n                        'model': row[7] if len(row) > 7 else row[6],\n                        'aspect_ratio': row[8] if len(row) > 8 else row[7],\n                        'status': row[9] if len(row) > 9 else row[8],\n                        'video_url': row[10] if len(row) > 10 else row[9],\n                        'error_message': row[11] if len(row) > 11 else row[10],\n                        'credits_spent': row[12] if len(row) > 12 else row[11],\n                        'created_at': row[13] if len(row) > 13 else row[12],\n                        'completed_at': row[14] if len(row) > 14 else row[13]\n                    })\n            \n            # Экспорт логов администратора\n            try:\n                async with db.execute(\"SELECT * FROM admin_logs\") as cursor:\n                    async for row in cursor:\n                        data['admin_logs'].append({\n                            'id': row[0],\n                            'admin_id': row[1],\n                            'action': row[2],\n                            'target_user_id': row[3],\n                            'description': row[4],\n                            'created_at': row[5]\n                        })\n            except Exception as e:\n                logger.warning(f\"Не удалось экспортировать admin_logs: {e}\")\n        \n        logger.info(f\"Экспортировано: {len(data['users'])} пользователей, \"\n                   f\"{len(data['transactions'])} транзакций, \"\n                   f\"{len(data['video_generations'])} видео генераций, \"\n                   f\"{len(data['admin_logs'])} админ логов\")\n        \n        return data\n    \n    async def import_to_postgres(self, data: Dict[str, List[Dict[str, Any]]]):\n        \"\"\"Импорт данных в PostgreSQL\"\"\"\n        logger.info(\"Начинаем импорт данных в PostgreSQL...\")\n        \n        try:\n            conn = await asyncpg.connect(self.postgres_url)\n            \n            # Создаем таблицы если их нет\n            await self.create_postgres_tables(conn)\n            \n            # Очищаем существующие данные (опционально)\n            response = input(\"Очистить существующие данные в PostgreSQL? (y/N): \")\n            if response.lower() == 'y':\n                await conn.execute(\"DELETE FROM admin_logs\")\n                await conn.execute(\"DELETE FROM video_generations\") \n                await conn.execute(\"DELETE FROM transactions\")\n                await conn.execute(\"DELETE FROM users\")\n                logger.info(\"Существующие данные очищены\")\n            \n            # Импорт пользователей\n            for user in data['users']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                        ON CONFLICT (telegram_id) DO UPDATE SET\n                        username = EXCLUDED.username,\n                        first_name = EXCLUDED.first_name,\n                        last_name = EXCLUDED.last_name,\n                        credits = EXCLUDED.credits,\n                        status = EXCLUDED.status,\n                        updated_at = EXCLUDED.updated_at\n                    ''', \n                        user['telegram_id'],\n                        user['username'],\n                        user['first_name'],\n                        user['last_name'],\n                        user['credits'],\n                        user['status'],\n                        datetime.fromisoformat(user['created_at']) if isinstance(user['created_at'], str) else user['created_at'],\n                        datetime.fromisoformat(user['updated_at']) if isinstance(user['updated_at'], str) else user['updated_at']\n                    )\n                except Exception as e:\n                    logger.error(f\"Ошибка импорта пользователя {user['telegram_id']}: {e}\")\n            \n            # Импорт транзакций\n            for transaction in data['transactions']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                        ON CONFLICT (payment_id) DO NOTHING\n                    ''', \n                        transaction['user_id'],\n                        transaction['type'],\n                        transaction['amount'],\n                        transaction['description'],\n                        transaction['payment_method'],\n                        transaction['payment_id'],\n                        datetime.fromisoformat(transaction['created_at']) if isinstance(transaction['created_at'], str) else transaction['created_at']\n                    )\n                except Exception as e:\n                    logger.error(f\"Ошибка импорта транзакции: {e}\")\n            \n            # Импорт видео генераций\n            for video in data['video_generations']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, video_url, error_message, credits_spent, created_at, completed_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\n                        ON CONFLICT (task_id) DO NOTHING\n                    ''', \n                        video['user_id'],\n                        video['task_id'],\n                        video['veo_task_id'],\n                        video['prompt'],\n                        video['generation_type'],\n                        video['image_url'],\n                        video['model'],\n                        video['aspect_ratio'],\n                        video['status'],\n                        video['video_url'],\n                        video['error_message'],\n                        video['credits_spent'],\n                        datetime.fromisoformat(video['created_at']) if isinstance(video['created_at'], str) else video['created_at'],\n                        datetime.fromisoformat(video['completed_at']) if isinstance(video['completed_at'], str) and video['completed_at'] else None\n                    )\n                except Exception as e:\n                    logger.error(f\"Ошибка импорта видео генерации: {e}\")\n            \n            # Импорт админ логов\n            for log in data['admin_logs']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES ($1, $2, $3, $4, $5)\n                    ''', \n                        log['admin_id'],\n                        log['action'],\n                        log['target_user_id'],\n                        log['description'],\n                        datetime.fromisoformat(log['created_at']) if isinstance(log['created_at'], str) else log['created_at']\n                    )\n                except Exception as e:\n                    logger.error(f\"Ошибка импорта админ лога: {e}\")\n            \n            await conn.close()\n            logger.info(\"Импорт данных в PostgreSQL завершен успешно!\")\n            \n        except Exception as e:\n            logger.error(f\"Ошибка подключения к PostgreSQL: {e}\")\n            raise\n    \n    async def create_postgres_tables(self, conn):\n        \"\"\"Создание таблиц в PostgreSQL\"\"\"\n        # Users table  \n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                telegram_id BIGINT PRIMARY KEY,\n                username TEXT,\n                first_name TEXT,\n                last_name TEXT,\n                credits INTEGER DEFAULT 0,\n                status TEXT DEFAULT 'regular',\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Transactions table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS transactions (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                type TEXT NOT NULL,\n                amount INTEGER NOT NULL,\n                description TEXT,\n                payment_method TEXT,\n                payment_id TEXT UNIQUE,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Video generations table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS video_generations (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                task_id TEXT UNIQUE,\n                veo_task_id TEXT,\n                prompt TEXT NOT NULL,\n                generation_type TEXT NOT NULL,\n                image_url TEXT,\n                model TEXT DEFAULT 'veo3_fast',\n                aspect_ratio TEXT DEFAULT '16:9',\n                status TEXT DEFAULT 'pending',\n                video_url TEXT,\n                error_message TEXT,\n                credits_spent INTEGER DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                completed_at TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Admin logs table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS admin_logs (\n                id SERIAL PRIMARY KEY,\n                admin_id BIGINT,\n                action TEXT NOT NULL,\n                target_user_id BIGINT,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Create indexes\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_payment_id ON transactions(payment_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_task_id ON video_generations(task_id)')\n    \n    async def migrate(self):\n        \"\"\"Полная миграция данных\"\"\"\n        try:\n            # Экспорт из SQLite\n            data = await self.export_sqlite_data()\n            \n            if not any(data.values()):\n                logger.warning(\"Нет данных для миграции!\")\n                return\n            \n            # Импорт в PostgreSQL\n            await self.import_to_postgres(data)\n            \n            # Создание резервной копии SQLite\n            import shutil\n            backup_name = f\"bot_database_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db\"\n            shutil.copy2(self.sqlite_path, backup_name)\n            logger.info(f\"Создана резервная копия SQLite: {backup_name}\")\n            \n            logger.info(\"🎉 Миграция данных завершена успешно!\")\n            \n        except Exception as e:\n            logger.error(f\"Ошибка миграции: {e}\")\n            raise\n\nasync def main():\n    \"\"\"Главная функция\"\"\"\n    print(\"=\" * 60)\n    print(\"🔄 ИНСТРУМЕНТ МИГРАЦИИ БАЗЫ ДАННЫХ\")\n    print(\"=\" * 60)\n    print(\"Этот скрипт перенесет все данные из SQLite (development)\")\n    print(\"в PostgreSQL (production) базу данных.\")\n    print()\n    \n    # Проверяем наличие DATABASE_URL\n    if not os.getenv('DATABASE_URL'):\n        print(\"❌ Ошибка: DATABASE_URL не настроен!\")\n        print(\"Убедитесь, что вы находитесь в production среде.\")\n        return\n    \n    response = input(\"Продолжить миграцию? (y/N): \")\n    if response.lower() != 'y':\n        print(\"Миграция отменена.\")\n        return\n    \n    try:\n        migrator = DatabaseMigrator()\n        await migrator.migrate()\n        \n        print()\n        print(\"=\" * 60)\n        print(\"✅ МИГРАЦИЯ ЗАВЕРШЕНА УСПЕШНО!\")\n        print(\"=\" * 60)\n        print(\"Теперь ваши данные доступны в production базе данных.\")\n        print(\"Рекомендуется перезапустить бота для применения изменений.\")\n        \n    except Exception as e:\n        print(f\"❌ Ошибка миграции: {e}\")\n        print(\"Обратитесь к разработчику за помощью.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":16626},"deploy_setup.sh":{"content":"#!/bin/bash\n\necho \"🚀 АВТОМАТИЧЕСКАЯ НАСТРОЙКА ДЕПЛОЯ\"\necho \"==================================\"\n\n# Установка зависимостей\necho \"📦 Устанавливаем зависимости...\"\npip install -q aiogram aiosqlite aiohttp\n\n# Проверяем среду\nif [ \"$REPLIT_DEPLOYMENT\" = \"1\" ]; then\n    echo \"🌍 Обнаружена deployment среда\"\n    \n    # Устанавливаем PostgreSQL драйвер\n    echo \"🐘 Устанавливаем PostgreSQL драйвер...\"\n    pip install -q asyncpg\n    \n    # Запускаем автоматическую миграцию\n    echo \"🔄 Запускаем автоматическую миграцию данных...\"\n    python auto_migrate.py\n    \n    echo \"✅ Деплой настроен успешно!\"\nelse\n    echo \"🏠 Обнаружена development среда\"\n    echo \"ℹ️  Миграция будет выполнена при деплое\"\nfi\n\necho \"✅ Установка завершена!\"","size_bytes":1046},"force_postgres.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nПринудительное переключение на PostgreSQL в deployed среде\n\"\"\"\n\nimport asyncio\nimport os\nimport logging\nfrom database.database import Database\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def force_postgres_connection():\n    \"\"\"Принудительно проверить и настроить PostgreSQL подключение\"\"\"\n    \n    print(\"🔧 ПРИНУДИТЕЛЬНОЕ ПЕРЕКЛЮЧЕНИЕ НА POSTGRESQL\")\n    print(\"=\" * 50)\n    \n    # Проверяем переменные окружения\n    database_url = os.getenv('DATABASE_URL')\n    replit_deployment = os.getenv('REPLIT_DEPLOYMENT')\n    \n    print(f\"REPLIT_DEPLOYMENT: {replit_deployment}\")\n    print(f\"DATABASE_URL присутствует: {'ДА' if database_url else 'НЕТ'}\")\n    \n    if not database_url:\n        print(\"❌ DATABASE_URL не найден!\")\n        return False\n    \n    # Принудительно устанавливаем asyncpg если нужно\n    try:\n        import asyncpg\n        print(\"✅ asyncpg доступен\")\n    except ImportError:\n        print(\"📦 Устанавливаем asyncpg...\")\n        import subprocess\n        subprocess.run([\"pip\", \"install\", \"asyncpg\"], check=True)\n        import asyncpg\n        print(\"✅ asyncpg установлен\")\n    \n    # Тестируем подключение\n    try:\n        conn = await asyncpg.connect(database_url)\n        \n        # Проверяем данные\n        user_count = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n        print(f\"✅ Пользователей в PostgreSQL: {user_count}\")\n        \n        if user_count > 0:\n            users = await conn.fetch(\"SELECT telegram_id, credits FROM users LIMIT 5\")\n            for user in users:\n                print(f\"   - User {user['telegram_id']}: {user['credits']} credits\")\n        \n        await conn.close()\n        print(\"✅ PostgreSQL подключение работает!\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Ошибка PostgreSQL: {e}\")\n        return False\n\nasync def test_database_selection():\n    \"\"\"Тестируем какую базу выбирает система\"\"\"\n    \n    print(\"\\n🔍 ТЕСТИРОВАНИЕ ВЫБОРА БАЗЫ ДАННЫХ\")\n    print(\"=\" * 50)\n    \n    # Создаем Database объект\n    db = Database()\n    \n    print(f\"База данных выбрана: {'PostgreSQL' if db.use_postgres else 'SQLite'}\")\n    print(f\"DATABASE_URL настроен: {'ДА' if db.database_url else 'НЕТ'}\")\n    \n    # Проверяем реальное подключение\n    if db.use_postgres:\n        try:\n            user = await db.get_user(1864913930)  # Admin user\n            if user:\n                print(f\"✅ Найден admin: {user.credits} credits\")\n                return True\n            else:\n                print(\"❌ Admin пользователь не найден\")\n                return False\n        except Exception as e:\n            print(f\"❌ Ошибка получения пользователя: {e}\")\n            return False\n    else:\n        print(\"❌ Система не использует PostgreSQL\")\n        return False\n\nasync def main():\n    \"\"\"Главная функция\"\"\"\n    \n    # Шаг 1: Проверяем PostgreSQL\n    postgres_ok = await force_postgres_connection()\n    \n    # Шаг 2: Проверяем выбор базы\n    db_selection_ok = await test_database_selection()\n    \n    print(\"\\n📋 ИТОГ:\")\n    print(\"=\" * 50)\n    \n    if postgres_ok and db_selection_ok:\n        print(\"🎉 ВСЁ РАБОТАЕТ! Deployed бот использует PostgreSQL\")\n        print(\"📱 Ваши данные должны быть видны в боте\")\n    elif postgres_ok and not db_selection_ok:\n        print(\"⚠️  PostgreSQL работает, но система выбирает SQLite\")\n        print(\"🔧 Нужно исправить логику выбора базы\")\n    else:\n        print(\"❌ PostgreSQL подключение не работает\")\n        print(\"🔧 Нужно проверить настройки DATABASE_URL\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":4341},"migrate_data.sh":{"content":"#!/bin/bash\n\necho \"🔄 БЫСТРАЯ МИГРАЦИЯ ДАННЫХ\"\necho \"================================\"\necho \"Этот скрипт перенесет все данные из SQLite в PostgreSQL\"\necho \"\"\n\n# Проверяем, что мы в правильной среде\nif [ -z \"$DATABASE_URL\" ]; then\n    echo \"❌ ОШИБКА: DATABASE_URL не найден!\"\n    echo \"Убедитесь, что вы запускаете это в production (deployed) среде.\"\n    echo \"\"\n    echo \"Чтобы запустить миграцию:\"\n    echo \"1. Нажмите 'Deploy' в Replit\"\n    echo \"2. Откройте консоль в deployed версии\"\n    echo \"3. Запустите: bash migrate_data.sh\"\n    exit 1\nfi\n\n# Устанавливаем зависимости если нужно\necho \"📦 Проверяем зависимости...\"\npip install asyncpg aiosqlite > /dev/null 2>&1\n\n# Запускаем миграцию\necho \"🚀 Запускаем миграцию данных...\"\npython database_migration.py\n\necho \"\"\necho \"✅ Готово! Теперь перезапустите бота для применения изменений.\"","size_bytes":1181},"sync_from_production.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nСинхронизация данных из Production (PostgreSQL) в Development (SQLite)\nДля удобной работы с данными локально\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport asyncpg\nimport os\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass ProductionSync:\n    def __init__(self):\n        self.sqlite_path = \"bot_database.db\"\n        self.postgres_url = os.getenv('DATABASE_URL')\n        \n        if not self.postgres_url:\n            raise ValueError(\"❌ DATABASE_URL не найден! Убедитесь что PostgreSQL настроен.\")\n    \n    async def export_from_postgres(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"Экспорт данных из PostgreSQL\"\"\"\n        logger.info(\"📤 Экспортируем данные из Production PostgreSQL...\")\n        \n        data = {\n            'users': [],\n            'transactions': [],\n            'video_generations': [],\n            'admin_logs': []\n        }\n        \n        try:\n            conn = await asyncpg.connect(self.postgres_url)\n            \n            # Экспорт пользователей\n            rows = await conn.fetch(\"SELECT * FROM users ORDER BY created_at\")\n            for row in rows:\n                data['users'].append({\n                    'telegram_id': row['telegram_id'],\n                    'username': row['username'],\n                    'first_name': row['first_name'],\n                    'last_name': row['last_name'],\n                    'credits': row['credits'],\n                    'status': row['status'],\n                    'created_at': row['created_at'],\n                    'updated_at': row['updated_at']\n                })\n            \n            # Экспорт транзакций\n            rows = await conn.fetch(\"SELECT * FROM transactions ORDER BY created_at\")\n            for row in rows:\n                data['transactions'].append({\n                    'user_id': row['user_id'],\n                    'type': row['type'],\n                    'amount': row['amount'],\n                    'description': row['description'],\n                    'payment_method': row['payment_method'],\n                    'payment_id': row['payment_id'],\n                    'created_at': row['created_at']\n                })\n            \n            # Экспорт видео генераций\n            rows = await conn.fetch(\"SELECT * FROM video_generations ORDER BY created_at\")\n            for row in rows:\n                data['video_generations'].append({\n                    'user_id': row['user_id'],\n                    'task_id': row['task_id'],\n                    'veo_task_id': row['veo_task_id'],\n                    'prompt': row['prompt'],\n                    'generation_type': row['generation_type'],\n                    'image_url': row['image_url'],\n                    'model': row['model'],\n                    'aspect_ratio': row['aspect_ratio'],\n                    'status': row['status'],\n                    'video_url': row['video_url'],\n                    'error_message': row['error_message'],\n                    'credits_spent': row['credits_spent'],\n                    'created_at': row['created_at'],\n                    'completed_at': row['completed_at']\n                })\n            \n            # Экспорт админ логов\n            try:\n                rows = await conn.fetch(\"SELECT * FROM admin_logs ORDER BY created_at\")\n                for row in rows:\n                    data['admin_logs'].append({\n                        'admin_id': row['admin_id'],\n                        'action': row['action'],\n                        'target_user_id': row['target_user_id'],\n                        'description': row['description'],\n                        'created_at': row['created_at']\n                    })\n            except Exception as e:\n                logger.warning(f\"Не удалось экспортировать admin_logs: {e}\")\n            \n            await conn.close()\n            \n            logger.info(f\"✅ Экспортировано: {len(data['users'])} пользователей, \"\n                       f\"{len(data['transactions'])} транзакций, \"\n                       f\"{len(data['video_generations'])} видео генераций, \"\n                       f\"{len(data['admin_logs'])} админ логов\")\n            \n        except Exception as e:\n            logger.error(f\"❌ Ошибка экспорта из PostgreSQL: {e}\")\n            raise\n        \n        return data\n    \n    async def import_to_sqlite(self, data: Dict[str, List[Dict[str, Any]]]):\n        \"\"\"Импорт данных в SQLite\"\"\"\n        logger.info(\"📥 Импортируем данные в Development SQLite...\")\n        \n        # Удаляем старый файл\n        if os.path.exists(self.sqlite_path):\n            os.remove(self.sqlite_path)\n            logger.info(\"🗑️ Удален старый SQLite файл\")\n        \n        async with aiosqlite.connect(self.sqlite_path) as db:\n            # Создаем таблицы\n            await self.create_sqlite_tables(db)\n            \n            # Импорт пользователей\n            for user in data['users']:\n                await db.execute('''\n                    INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n                ''', (\n                    user['telegram_id'],\n                    user['username'],\n                    user['first_name'],\n                    user['last_name'],\n                    user['credits'],\n                    user['status'],\n                    user['created_at'].isoformat() if user['created_at'] else None,\n                    user['updated_at'].isoformat() if user['updated_at'] else None\n                ))\n            \n            # Импорт транзакций\n            for transaction in data['transactions']:\n                await db.execute('''\n                    INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\n                ''', (\n                    transaction['user_id'],\n                    transaction['type'],\n                    transaction['amount'],\n                    transaction['description'],\n                    transaction['payment_method'],\n                    transaction['payment_id'],\n                    transaction['created_at'].isoformat() if transaction['created_at'] else None\n                ))\n            \n            # Импорт видео генераций\n            for video in data['video_generations']:\n                await db.execute('''\n                    INSERT INTO video_generations \n                    (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, video_url, error_message, credits_spent, created_at, completed_at)\n                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n                ''', (\n                    video['user_id'],\n                    video['task_id'],\n                    video['veo_task_id'],\n                    video['prompt'],\n                    video['generation_type'],\n                    video['image_url'],\n                    video['model'],\n                    video['aspect_ratio'],\n                    video['status'],\n                    video['video_url'],\n                    video['error_message'],\n                    video['credits_spent'],\n                    video['created_at'].isoformat() if video['created_at'] else None,\n                    video['completed_at'].isoformat() if video['completed_at'] else None\n                ))\n            \n            # Импорт админ логов\n            for log in data['admin_logs']:\n                await db.execute('''\n                    INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                    VALUES (?, ?, ?, ?, ?)\n                ''', (\n                    log['admin_id'],\n                    log['action'],\n                    log['target_user_id'],\n                    log['description'],\n                    log['created_at'].isoformat() if log['created_at'] else None\n                ))\n            \n            await db.commit()\n            logger.info(\"✅ Все данные успешно импортированы в SQLite!\")\n    \n    async def create_sqlite_tables(self, db):\n        \"\"\"Создание таблиц в SQLite\"\"\"\n        # Users table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                telegram_id INTEGER PRIMARY KEY,\n                username TEXT,\n                first_name TEXT,\n                last_name TEXT,\n                credits INTEGER DEFAULT 0,\n                status TEXT DEFAULT 'regular',\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Transactions table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS transactions (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                user_id INTEGER,\n                type TEXT NOT NULL,\n                amount INTEGER NOT NULL,\n                description TEXT,\n                payment_method TEXT,\n                payment_id TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Video generations table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS video_generations (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                user_id INTEGER,\n                task_id TEXT UNIQUE,\n                veo_task_id TEXT,\n                prompt TEXT NOT NULL,\n                generation_type TEXT NOT NULL,\n                image_url TEXT,\n                model TEXT DEFAULT 'veo3_fast',\n                aspect_ratio TEXT DEFAULT '16:9',\n                status TEXT DEFAULT 'pending',\n                video_url TEXT,\n                error_message TEXT,\n                credits_spent INTEGER DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                completed_at TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Admin logs table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS admin_logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                admin_id INTEGER,\n                action TEXT NOT NULL,\n                target_user_id INTEGER,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n            )\n        ''')\n    \n    async def sync(self):\n        \"\"\"Полная синхронизация данных\"\"\"\n        try:\n            print(\"🔄 СИНХРОНИЗАЦИЯ ДАННЫХ ИЗ PRODUCTION\")\n            print(\"=\" * 50)\n            \n            # Экспорт из PostgreSQL\n            data = await self.export_from_postgres()\n            \n            if not any(data.values()):\n                logger.warning(\"⚠️ Нет данных для синхронизации в PostgreSQL!\")\n                return\n            \n            # Импорт в SQLite\n            await self.import_to_sqlite(data)\n            \n            print(\"=\" * 50)\n            print(\"🎉 СИНХРОНИЗАЦИЯ ЗАВЕРШЕНА УСПЕШНО!\")\n            print(\"=\" * 50)\n            print(\"Теперь ваши production данные доступны в development среде.\")\n            print(\"Можете работать с ними локально через интерфейс базы данных.\")\n            \n        except Exception as e:\n            logger.error(f\"❌ Ошибка синхронизации: {e}\")\n            print(f\"\\n❌ Ошибка: {e}\")\n            print(\"Обратитесь к разработчику за помощью.\")\n\nasync def main():\n    \"\"\"Главная функция\"\"\"\n    sync = ProductionSync()\n    await sync.sync()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":12654},"test_db_connection.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nТест подключения к базе данных\n\"\"\"\nimport asyncio\nimport os\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def test_connection():\n    print(\"🔍 ТЕСТИРОВАНИЕ ПОДКЛЮЧЕНИЯ К БАЗЕ ДАННЫХ\")\n    print(\"=\" * 50)\n    \n    # Проверяем переменные окружения\n    database_url = os.getenv('DATABASE_URL')\n    print(f\"DATABASE_URL: {'Настроен ✅' if database_url else 'НЕ настроен ❌'}\")\n    \n    # Проверяем импорт asyncpg\n    try:\n        import asyncpg\n        print(\"asyncpg: Доступен ✅\")\n        postgres_available = True\n    except ImportError:\n        print(\"asyncpg: НЕ доступен ❌\")\n        postgres_available = False\n    \n    # Тестируем создание Database объекта\n    from database.database import Database\n    db = Database()\n    \n    print(f\"База данных выбрана: {'PostgreSQL ✅' if db.use_postgres else 'SQLite ❌'}\")\n    \n    # Проверяем подключение к PostgreSQL\n    if db.use_postgres and postgres_available and database_url:\n        try:\n            import asyncpg\n            conn = await asyncpg.connect(database_url)\n            \n            # Проверяем данные в PostgreSQL\n            result = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n            print(f\"Пользователей в PostgreSQL: {result}\")\n            \n            users = await conn.fetch(\"SELECT telegram_id, credits FROM users\")\n            for user in users:\n                print(f\"  - User {user['telegram_id']}: {user['credits']} credits\")\n            \n            await conn.close()\n            print(\"Подключение к PostgreSQL: РАБОТАЕТ ✅\")\n            \n        except Exception as e:\n            print(f\"Ошибка подключения к PostgreSQL: {e} ❌\")\n    \n    # Проверяем SQLite\n    import aiosqlite\n    sqlite_path = \"bot_database.db\"\n    \n    if os.path.exists(sqlite_path):\n        print(f\"SQLite файл существует: {sqlite_path}\")\n        \n        try:\n            async with aiosqlite.connect(sqlite_path) as sqlite_db:\n                cursor = await sqlite_db.execute(\"SELECT COUNT(*) FROM users\")\n                result = await cursor.fetchone()\n                print(f\"Пользователей в SQLite: {result[0] if result else 0}\")\n        except Exception as e:\n            print(f\"Ошибка чтения SQLite: {e}\")\n    else:\n        print(\"SQLite файл не существует\")\n    \n    print(\"=\" * 50)\n    print(\"🎯 РЕКОМЕНДАЦИЯ:\")\n    \n    if db.use_postgres:\n        print(\"✅ Система правильно настроена на PostgreSQL\")\n        print(\"📱 Перезапустите deployed бота для применения изменений\")\n    else:\n        print(\"❌ Система использует SQLite вместо PostgreSQL\") \n        print(\"🔧 Проверьте настройки DATABASE_URL в deployed среде\")\n\nif __name__ == \"__main__\":\n    asyncio.run(test_connection())","size_bytes":3220},"utils/async_logger.py":{"content":"\"\"\"\nАсинхронное логирование для улучшения производительности\n\"\"\"\nimport asyncio\nimport logging\nimport threading\nfrom queue import Queue\nfrom typing import Optional\n\n\nclass AsyncLogHandler(logging.Handler):\n    \"\"\"Асинхронный обработчик логов для высоких нагрузок\"\"\"\n    \n    def __init__(self, base_handler: logging.Handler):\n        super().__init__()\n        self.base_handler = base_handler\n        self.log_queue = Queue()\n        self.running = True\n        \n        # Запускаем фоновый поток для записи логов\n        self.log_thread = threading.Thread(target=self._log_worker, daemon=True)\n        self.log_thread.start()\n    \n    def emit(self, record):\n        \"\"\"Добавить запись в очередь для асинхронной обработки\"\"\"\n        if self.running:\n            self.log_queue.put(record)\n    \n    def _log_worker(self):\n        \"\"\"Фоновый поток для записи логов\"\"\"\n        while self.running:\n            try:\n                record = self.log_queue.get(timeout=1)\n                if record is None:  # Сигнал завершения\n                    break\n                self.base_handler.emit(record)\n                self.log_queue.task_done()\n            except:\n                # Игнорируем ошибки в фоновом потоке\n                pass\n    \n    def close(self):\n        \"\"\"Закрыть обработчик\"\"\"\n        self.running = False\n        self.log_queue.put(None)  # Сигнал завершения\n        self.log_thread.join(timeout=5)\n        self.base_handler.close()\n        super().close()\n\n\ndef setup_async_logging():\n    \"\"\"Настроить асинхронное логирование\"\"\"\n    # Получить root logger\n    root_logger = logging.getLogger()\n    \n    # Заменить обработчики на асинхронные версии\n    for handler in root_logger.handlers[:]:\n        async_handler = AsyncLogHandler(handler)\n        async_handler.setLevel(handler.level)\n        async_handler.setFormatter(handler.formatter)\n        \n        root_logger.removeHandler(handler)\n        root_logger.addHandler(async_handler)","size_bytes":2314},"utils/cache_manager.py":{"content":"\"\"\"\nЦентральный менеджер кэша для оптимизации производительности\n\"\"\"\nimport time\nfrom typing import Any, Dict, Optional, TypeVar, Generic\nimport asyncio\nfrom functools import wraps\n\nT = TypeVar('T')\n\nclass CacheManager(Generic[T]):\n    \"\"\"Универсальный менеджер кэша с TTL\"\"\"\n    \n    def __init__(self, default_ttl: int = 300):\n        self.cache: Dict[str, Dict[str, Any]] = {}\n        self.default_ttl = default_ttl\n        self._lock = asyncio.Lock()\n    \n    def _is_expired(self, entry: Dict[str, Any]) -> bool:\n        \"\"\"Проверить, истек ли кэш\"\"\"\n        return time.time() - entry['timestamp'] > entry['ttl']\n    \n    async def get(self, key: str) -> Optional[T]:\n        \"\"\"Получить значение из кэша\"\"\"\n        async with self._lock:\n            if key in self.cache:\n                entry = self.cache[key]\n                if not self._is_expired(entry):\n                    return entry['value']\n                else:\n                    # Удалить истекшую запись\n                    del self.cache[key]\n            return None\n    \n    async def set(self, key: str, value: T, ttl: Optional[int] = None) -> None:\n        \"\"\"Установить значение в кэш\"\"\"\n        async with self._lock:\n            self.cache[key] = {\n                'value': value,\n                'timestamp': time.time(),\n                'ttl': ttl or self.default_ttl\n            }\n    \n    async def delete(self, key: str) -> None:\n        \"\"\"Удалить значение из кэша\"\"\"\n        async with self._lock:\n            if key in self.cache:\n                del self.cache[key]\n    \n    async def clear(self) -> None:\n        \"\"\"Очистить весь кэш\"\"\"\n        async with self._lock:\n            self.cache.clear()\n    \n    async def cleanup_expired(self) -> int:\n        \"\"\"Очистить истекшие записи и вернуть количество удаленных\"\"\"\n        expired_keys = []\n        async with self._lock:\n            for key, entry in self.cache.items():\n                if self._is_expired(entry):\n                    expired_keys.append(key)\n            \n            for key in expired_keys:\n                del self.cache[key]\n        \n        return len(expired_keys)\n    \n    def size(self) -> int:\n        \"\"\"Размер кэша\"\"\"\n        return len(self.cache)\n\n\ndef cached(ttl: int = 300, key_prefix: str = \"\"):\n    \"\"\"Декоратор для кэширования результатов функций\"\"\"\n    def decorator(func):\n        cache = CacheManager(ttl)\n        \n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Создать ключ на основе аргументов\n            cache_key = f\"{key_prefix}{func.__name__}_{hash(str(args) + str(sorted(kwargs.items())))}\"\n            \n            # Попробовать получить из кэша\n            cached_result = await cache.get(cache_key)\n            if cached_result is not None:\n                return cached_result\n            \n            # Выполнить функцию и кэшировать результат\n            result = await func(*args, **kwargs)\n            await cache.set(cache_key, result)\n            return result\n        \n        # Добавить методы управления кэшем к функции\n        wrapper.cache_clear = cache.clear\n        wrapper.cache_info = lambda: {\"size\": cache.size()}\n        \n        return wrapper\n    return decorator\n\n\n# Глобальные экземпляры кэша\nuser_cache = CacheManager(ttl=300)  # 5 минут для пользователей\nstats_cache = CacheManager(ttl=600)  # 10 минут для статистики","size_bytes":3858}},"version":1}