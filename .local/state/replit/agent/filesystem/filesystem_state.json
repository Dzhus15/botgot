{"file_contents":{"config.py":{"content":"import os\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Config:\n    \"\"\"Configuration class for the Telegram bot\"\"\"\n    \n    # Telegram Bot Configuration\n    TELEGRAM_BOT_TOKEN: str = os.getenv(\"TELEGRAM_BOT_TOKEN\", \"\")\n    \n    # Veo API Configuration\n    VEO_API_KEY: str = os.getenv(\"VEO_API_KEY\", \"\")\n    VEO_API_BASE_URL: str = \"https://api.kie.ai\"\n    \n    # Payment Configuration\n    YOOKASSA_API_KEY: str = os.getenv(\"YOOKASSA_API_KEY\", \"\")\n    YOOKASSA_SHOP_ID: str = os.getenv(\"YOOKASSA_SHOP_ID\", \"\")\n    YOOKASSA_WEBHOOK_SECRET: str = os.getenv(\"YOOKASSA_WEBHOOK_SECRET\", \"\")\n    TELEGRAM_PAYMENTS_TOKEN: str = os.getenv(\"TELEGRAM_PAYMENTS_TOKEN\", \"\")\n    \n    # Admin Configuration\n    ADMIN_USER_ID: int = 1864913930\n    INITIAL_ADMIN_CREDITS: int = 100\n    \n    # Database Configuration  \n    DATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"\")\n    \n    # Rate Limiting Configuration\n    RATE_LIMIT_MESSAGES: int = 100  # messages per period (increased)\n    RATE_LIMIT_WINDOW: int = 60   # seconds\n    \n    # Video Generation Configuration\n    DEFAULT_MODEL: str = \"veo3_fast\"  # Cost-efficient model\n    DEFAULT_ASPECT_RATIO: str = \"16:9\"\n    \n    # Credits Configuration\n    VIDEO_GENERATION_COST: int = 10  # credits per video\n    \n    def __post_init__(self):\n        \"\"\"Validate configuration after initialization\"\"\"\n        if not self.TELEGRAM_BOT_TOKEN:\n            raise ValueError(\"TELEGRAM_BOT_TOKEN environment variable is required\")\n        \n        if not self.VEO_API_KEY:\n            raise ValueError(\"VEO_API_KEY environment variable is required\")\n","size_bytes":1610},"main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom aiohttp import web\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\nfrom aiogram.fsm.storage.memory import MemoryStorage\n\nfrom config import Config\nfrom database.database import init_database\nfrom handlers import start, generate, payments, admin\nfrom middlewares.rate_limit import RateLimitMiddleware\nfrom webhook_server import init_webhook_server\nfrom utils.async_logger import setup_async_logging\n\n# Setup async logging for better performance\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nsetup_async_logging()\nlogger = logging.getLogger(__name__)\n\nasync def start_bot_polling():\n    \"\"\"Start Telegram bot polling in background\"\"\"\n    try:\n        # Initialize configuration\n        config = Config()\n        logger.info(f\"Starting bot with Veo model: {config.DEFAULT_MODEL}\")\n        \n        # Initialize bot and dispatcher\n        bot = Bot(\n            token=config.TELEGRAM_BOT_TOKEN,\n            default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n        )\n        \n        dp = Dispatcher(storage=MemoryStorage())\n        \n        # Register middleware\n        dp.message.middleware(RateLimitMiddleware())\n        dp.callback_query.middleware(RateLimitMiddleware())\n        \n        # Register handlers\n        dp.include_router(start.router)\n        dp.include_router(generate.router)\n        dp.include_router(payments.router)\n        dp.include_router(admin.router)\n        \n        logger.info(\"Bot starting polling...\")\n        \n        # Start polling\n        await dp.start_polling(bot, skip_updates=True)\n        \n    except Exception as e:\n        logger.error(f\"Error starting bot: {e}\")\n        import traceback\n        logger.error(traceback.format_exc())\n        raise\n\nasync def main():\n    \"\"\"Main function to start the web server on port 5000\"\"\"\n    try:\n        # Initialize database\n        await init_database()\n        logger.info(\"Database initialized successfully\")\n        \n        # Initialize webhook web application\n        app = await init_webhook_server()\n        \n        # Start bot polling in background\n        bot_task = asyncio.create_task(start_bot_polling())\n        logger.info(\"Bot polling started in background...\")\n        \n        # Start payment monitoring in background\n        from utils.payment_monitor import payment_monitor\n        monitor_task = asyncio.create_task(payment_monitor.start_monitoring())\n        logger.info(\"Payment monitoring started in background...\")\n        \n        # Start web server on port 5000 (main process)\n        runner = web.AppRunner(app)\n        await runner.setup()\n        \n        site = web.TCPSite(runner, '0.0.0.0', 5000)\n        await site.start()\n        \n        logger.info(\"Web server started on port 5000\")\n        logger.info(\"Application endpoints:\")\n        logger.info(\"  POST /webhook/veo-complete/{task_id} - Veo completion callbacks\")\n        logger.info(\"  POST /webhook/yookassa - YooKassa payment notifications\")\n        logger.info(\"  GET /health - Health check\")\n        \n        # Keep the server running indefinitely\n        try:\n            # Create a future that will never complete to keep the event loop running\n            stop_event = asyncio.Event()\n            await stop_event.wait()\n        except asyncio.CancelledError:\n            logger.info(\"Application shutdown requested\")\n        finally:\n            # Cleanup tasks\n            bot_task.cancel()\n            monitor_task.cancel()\n            await runner.cleanup()\n        \n    except Exception as e:\n        logger.error(f\"Error starting application: {e}\")\n        import traceback\n        logger.error(traceback.format_exc())\n        raise\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logger.info(\"Application stopped by user\")\n    except Exception as e:\n        logger.error(f\"Fatal error: {e}\")\n","size_bytes":4026},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":143},"replit.md":{"content":"# Overview\n\nThis is a Telegram bot that generates AI videos using Google's Veo 3 API through the kie.ai platform. The bot provides text-to-video and image-to-video generation capabilities with a credit-based payment system. Users can purchase credits using Telegram Stars or traditional payment methods (YooKassa), and each video generation costs 10 credits. The bot includes comprehensive admin functionality for user management and broadcasting.\n\n# Recent Changes\n\n**2025-08-26**: \n- ‚úÖ Fixed tokenomics: 399‚ÇΩ package now gives 50 credits (5 video generations)\n- ‚úÖ Fixed database connection issues in payment monitoring system\n- ‚úÖ Increased rate limiting from 15 to 100 messages per minute\n- ‚úÖ Added manual credit management tool (admin_tools/credit_manager.py)\n- ‚úÖ Hybrid database system: SQLite (current) + PostgreSQL ready for production\n- ‚úÖ User 848867375 compensated with 35 credits for incorrect 399‚ÇΩ package\n- ‚úÖ **NEW**: Secure admin credit management system with production-only restrictions\n- ‚úÖ **NEW**: Automatic user notifications when admin grants credits with custom comments\n- ‚úÖ **NEW**: Complete audit trail for all admin credit operations\n- ‚úÖ **NEW**: Fully automated database migration system - data auto-transfers on every deploy\n- ‚úÖ **NEW**: Smart migration detection - only migrates when needed\n- ‚úÖ **SECURITY**: Fixed all critical payment vulnerabilities - HMAC verification, rate limiting, race conditions\n- ‚úÖ **SECURITY**: Enhanced Telegram Stars payment validation against fraud attempts\n- ‚úÖ **SECURITY**: Strengthened webhook IP validation (removed localhost bypass)\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework and Communication\nBuilt on aiogram (asynchronous Telegram bot framework) with handler-based routing for different bot commands and interactions. Uses inline keyboards for user navigation and FSM (Finite State Machine) for managing user conversation states during video generation and payment flows.\n\n## Database Layer\nHybrid database system with SQLite-based persistence layer using aiosqlite (currently active) and PostgreSQL support ready for production deployment. Automatically switches to PostgreSQL when asyncpg is available and DATABASE_URL is configured. Core entities include:\n- Users: Telegram ID, credits balance, admin status, user metadata\n- Transactions: Credit purchases and spending with audit trail\n- Video Generations: Task tracking for AI video creation\n- Admin Logs: Activity tracking for administrative actions\n\nDefault admin user (ID: 1864913930) receives 100 credits and admin privileges on first registration. Database persists data during redeploys when using PostgreSQL.\n\n## Credit System and Payments\nDual payment integration supporting:\n- Telegram Stars for in-app purchases\n- YooKassa for traditional payment methods (cards, SBP)\nFixed pricing at 10 credits per video generation with configurable credit packages.\n\n## AI Video Generation\nIntegration with Veo 3 API through kie.ai platform supporting:\n- Text-to-video generation from prompts\n- Image-to-video generation (with image upload handling)\n- Configurable models (default: veo3_fast for cost efficiency)\n- Standard 16:9 aspect ratio output\n\n## Security and Rate Limiting\n- **Enhanced Payment Security**: HMAC signature verification for YooKassa webhooks with configurable secret\n- **Fraud Prevention**: Multi-layer validation for Telegram Stars payments including amount verification and user ID matching\n- **Rate Limiting**: Dual-layer protection - user rate limiting (100 msg/60s) + webhook rate limiting (10 req/60s per IP)\n- **Race Condition Protection**: Atomic payment processing with database constraints to prevent duplicate credit grants\n- **Webhook Security**: Strict IP validation for YooKassa webhooks without localhost bypass vulnerabilities\n- Environment variable configuration for all API keys and secrets\n- Input validation for prompts with content filtering\n- Parameterized database queries for SQL injection prevention\n- Comprehensive logging without sensitive data exposure\n\n## Administrative Features\nAdmin-only functionality includes:\n- User statistics and analytics dashboard\n- Broadcast messaging system with media support\n- **Advanced credit management system:**\n  - Check user credits balance by Telegram ID\n  - Grant credits with custom reason/comment (production only)\n  - Automatic user notifications with admin comments\n  - Complete audit logging and transaction records\n  - Environment-aware security (local vs production)\n- Activity monitoring and comprehensive audit trails\n- Payment verification and manual credit recovery tools\n- **Database Migration Tools:**\n  - Automated data transfer from SQLite to PostgreSQL\n  - Complete backup and recovery system for data loss scenarios\n  - One-command migration: `bash migrate_data.sh`\n  - Safe data export/import with conflict resolution\n\n## Error Handling and Resilience\nComprehensive error handling with user-friendly messages, structured logging with rotation, graceful degradation for API failures, and async architecture for handling concurrent requests.\n\n# External Dependencies\n\n## Primary APIs\n- **Telegram Bot API**: Core bot functionality via aiogram library\n- **Veo 3 AI API**: Video generation through kie.ai platform (api.kie.ai)\n- **YooKassa Payment API**: Russian payment processing for cards and SBP\n- **Telegram Payments API**: Telegram Stars integration\n\n## Database\n- **SQLite**: Local persistent storage with async operations via aiosqlite (development)\n- **PostgreSQL**: Production database with automatic migration tools\n- **Migration System**: Universal tool for transferring data between environments\n\n## Python Libraries\n- **aiogram**: Telegram bot framework with async support\n- **aiosqlite**: Async SQLite database operations\n- **aiohttp**: HTTP client for API integrations\n- **logging**: Built-in Python logging with rotation\n\n## Infrastructure\n- **Replit Environment**: Hosting platform with secrets management\n- **File Storage**: Local filesystem for database and logs\n\n## Authentication Requirements\n- TELEGRAM_BOT_TOKEN: Bot authentication with Telegram\n- VEO_API_KEY: Access to Veo 3 video generation API\n- YOOKASSA_API_KEY & YOOKASSA_SHOP_ID: Payment processing credentials\n- TELEGRAM_PAYMENTS_TOKEN: Telegram Stars payment processing","size_bytes":6376},"api_integrations/payment_api.py":{"content":"import aiohttp\nimport logging\nimport uuid\nimport hmac\nimport hashlib\nfrom typing import Optional\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass PaymentAPI:\n    \"\"\"Payment API integrations\"\"\"\n    \n    def __init__(self):\n        self.yookassa_api_key = config.YOOKASSA_API_KEY\n        self.yookassa_shop_id = config.YOOKASSA_SHOP_ID\n        self.yookassa_base_url = \"https://api.yookassa.ru/v3\"\n    \n    async def create_yookassa_payment(\n        self, \n        amount: int, \n        description: str, \n        user_id: int,\n        package_id: str,\n        payment_method: str = \"bank_card\"\n    ) -> Optional[str]:\n        \"\"\"Create YooKassa payment and return payment URL\"\"\"\n        \n        if not self.yookassa_api_key or not self.yookassa_shop_id:\n            logger.error(\"YooKassa credentials not configured\")\n            return None\n        \n        try:\n            import base64\n            \n            # Prepare authentication\n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\",\n                \"Idempotence-Key\": str(uuid.uuid4())\n            }\n            \n            # Payment data with receipt (required by 54-FZ)\n            payment_data = {\n                \"amount\": {\n                    \"value\": f\"{amount}.00\",\n                    \"currency\": \"RUB\"\n                },\n                \"confirmation\": {\n                    \"type\": \"redirect\",\n                    \"return_url\": \"https://t.me/VideoAnalizAiBot?start=payment_success\"\n                },\n                \"capture\": True,\n                \"description\": description,\n                \"metadata\": {\n                    \"user_id\": str(user_id),\n                    \"package_id\": package_id,\n                    \"source\": \"telegram_bot\"\n                },\n                \"payment_method_data\": {\n                    \"type\": payment_method\n                },\n                \"receipt\": {\n                    \"customer\": {\n                        \"email\": \"customer@example.com\"\n                    },\n                    \"items\": [\n                        {\n                            \"description\": description,\n                            \"quantity\": \"1.00\",\n                            \"amount\": {\n                                \"value\": f\"{amount}.00\",\n                                \"currency\": \"RUB\"\n                            },\n                            \"vat_code\": 1  # –ù–î–° –Ω–µ –æ–±–ª–∞–≥–∞–µ—Ç—Å—è\n                        }\n                    ]\n                }\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.yookassa_base_url}/payments\",\n                    headers=headers,\n                    json=payment_data,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        \n                        confirmation_url = result.get(\"confirmation\", {}).get(\"confirmation_url\")\n                        payment_id = result.get(\"id\")\n                        \n                        if confirmation_url and payment_id:\n                            logger.info(f\"YooKassa payment created: {payment_id} for user {user_id}\")\n                            \n                            # Store payment info for webhook processing\n                            # In a real implementation, you'd store this in database\n                            # await self.store_pending_payment(payment_id, user_id, package_id, amount)\n                            \n                            return confirmation_url\n                        else:\n                            logger.error(f\"Invalid YooKassa response: {result}\")\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"YooKassa API error {response.status}: {error_text}\")\n                        \n        except Exception as e:\n            logger.error(f\"Error creating YooKassa payment: {e}\")\n        \n        return None\n    \n    async def verify_yookassa_payment(self, payment_id: str) -> dict:\n        \"\"\"Verify YooKassa payment status\"\"\"\n        \n        if not self.yookassa_api_key or not self.yookassa_shop_id:\n            logger.error(\"YooKassa credentials not configured\")\n            return {\"status\": \"error\", \"message\": \"Not configured\"}\n        \n        try:\n            import base64\n            \n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.get(\n                    f\"{self.yookassa_base_url}/payments/{payment_id}\",\n                    headers=headers,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        return {\n                            \"status\": result.get(\"status\"),\n                            \"amount\": result.get(\"amount\", {}).get(\"value\"),\n                            \"currency\": result.get(\"amount\", {}).get(\"currency\"),\n                            \"metadata\": result.get(\"metadata\", {}),\n                            \"paid\": result.get(\"status\") == \"succeeded\"\n                        }\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"YooKassa verify error {response.status}: {error_text}\")\n                        return {\"status\": \"error\", \"message\": error_text}\n                        \n        except Exception as e:\n            logger.error(f\"Error verifying YooKassa payment {payment_id}: {e}\")\n            return {\"status\": \"error\", \"message\": str(e)}\n    \n    def verify_webhook_signature(self, payload: bytes, signature: str) -> bool:\n        \"\"\"Verify YooKassa webhook HMAC signature for security\"\"\"\n        if not config.YOOKASSA_WEBHOOK_SECRET:\n            logger.warning(\"YOOKASSA_WEBHOOK_SECRET not configured - skipping signature verification\")\n            return True  # Allow if secret not configured (backward compatibility)\n        \n        if not signature:\n            logger.error(\"Missing webhook signature\")\n            return False\n        \n        try:\n            # YooKassa sends signature as \"sha256=<hash>\"\n            if not signature.startswith('sha256='):\n                logger.error(f\"Invalid signature format: {signature[:20]}...\")\n                return False\n            \n            expected_signature = signature[7:]  # Remove \"sha256=\" prefix\n            \n            # Calculate HMAC\n            calculated_signature = hmac.new(\n                config.YOOKASSA_WEBHOOK_SECRET.encode('utf-8'),\n                payload,\n                hashlib.sha256\n            ).hexdigest()\n            \n            # Secure comparison\n            is_valid = hmac.compare_digest(expected_signature, calculated_signature)\n            \n            if not is_valid:\n                logger.error(\"Webhook signature verification failed\")\n            \n            return is_valid\n            \n        except Exception as e:\n            logger.error(f\"Error verifying webhook signature: {e}\")\n            return False\n    \n    async def process_yookassa_webhook(self, webhook_data: dict, raw_payload: bytes = None, signature: str = None) -> bool:\n        \"\"\"Process YooKassa webhook notification with enhanced security\"\"\"\n        \n        try:\n            # Verify HMAC signature if provided\n            if raw_payload is not None and signature is not None:\n                if not self.verify_webhook_signature(raw_payload, signature):\n                    logger.error(\"Webhook signature verification failed - potential fraud attempt\")\n                    return False\n            # Validate webhook data structure\n            if not isinstance(webhook_data, dict):\n                logger.error(\"Invalid webhook data type\")\n                return False\n            \n            event_type = webhook_data.get(\"event\")\n            payment_object = webhook_data.get(\"object\", {})\n            \n            logger.info(f\"Processing YooKassa webhook: event={event_type}\")\n            \n            if event_type == \"payment.succeeded\":\n                # Validate required fields\n                payment_id = payment_object.get(\"id\")\n                if not payment_id:\n                    logger.error(\"Missing payment ID in webhook\")\n                    return False\n                \n                metadata = payment_object.get(\"metadata\", {})\n                amount_data = payment_object.get(\"amount\", {})\n                amount_value = amount_data.get(\"value\")\n                currency = amount_data.get(\"currency\")\n                \n                # Validate currency\n                if currency != \"RUB\":\n                    logger.error(f\"Invalid currency in payment {payment_id}: {currency}\")\n                    return False\n                \n                user_id = metadata.get(\"user_id\")\n                package_id = metadata.get(\"package_id\")\n                source = metadata.get(\"source\")\n                \n                # Validate metadata\n                if not all([user_id, package_id, amount_value]):\n                    logger.error(f\"Missing required fields in payment {payment_id}\")\n                    return False\n                \n                # Validate source\n                if source != \"telegram_bot\":\n                    logger.warning(f\"Unexpected payment source: {source}\")\n                \n                # Process successful payment\n                success = await self._process_successful_card_payment(\n                    user_id=int(user_id),\n                    package_id=package_id,\n                    payment_id=payment_id,\n                    amount=float(amount_value)\n                )\n                \n                logger.info(f\"YooKassa payment {payment_id} processed: {success}\")\n                return success\n                \n            elif event_type == \"payment.canceled\":\n                payment_id = payment_object.get(\"id\")\n                logger.info(f\"Payment canceled: {payment_id}\")\n                return True\n                \n            else:\n                logger.info(f\"Ignoring webhook event: {event_type}\")\n                return True\n                \n        except ValueError as e:\n            logger.error(f\"Data validation error in YooKassa webhook: {e}\")\n        except Exception as e:\n            logger.error(f\"Unexpected error processing YooKassa webhook: {e}\")\n        \n        return False\n    \n    async def _process_successful_card_payment(\n        self, \n        user_id: int, \n        package_id: str, \n        payment_id: str, \n        amount: float\n    ) -> bool:\n        \"\"\"Process successful card payment with duplicate protection\"\"\"\n        \n        try:\n            from handlers.payments import CREDIT_PACKAGES\n            from database.database import db\n            from database.models import Transaction, TransactionType, PaymentMethod\n            \n            # SECURITY: Atomic check and creation to prevent race conditions\n            # We'll rely on database constraints to prevent duplicates\n            \n            package = CREDIT_PACKAGES.get(package_id)\n            if not package:\n                logger.error(f\"Package {package_id} not found\")\n                return False\n            \n            # Validate payment amount matches package price\n            expected_amount = float(package['price_rub'])\n            if abs(float(amount) - expected_amount) > 0.01:  # Allow small floating point differences\n                logger.error(f\"Payment amount mismatch: expected {expected_amount}, got {amount}\")\n                return False\n            \n            # Calculate total credits (including bonus)\n            total_credits = package['credits']\n            if package.get('bonus'):\n                total_credits += package['bonus']\n            \n            # Verify user exists and get current credits\n            user = await db.get_user(user_id)\n            if not user:\n                logger.error(f\"User {user_id} not found for payment {payment_id}\")\n                return False\n            \n            # Create transaction record FIRST (atomic operation with duplicate check)\n            transaction = Transaction(\n                user_id=user_id,\n                type=TransactionType.CREDIT_PURCHASE,\n                amount=total_credits,\n                description=f\"YooKassa: {package['title']} ({payment_id})\",\n                payment_method=PaymentMethod.YOOKASSA,\n                payment_id=payment_id\n            )\n            \n            # Try to create transaction - will fail if payment_id already exists (race condition protection)\n            transaction_created = await db.create_transaction(transaction)\n            if not transaction_created:\n                # Check if it was a duplicate payment (race condition)\n                if await db.payment_exists(payment_id):\n                    logger.warning(f\"Duplicate payment processing attempt detected: {payment_id}\")\n                    return False  # Not an error, just already processed\n                else:\n                    logger.error(f\"Failed to create transaction record for payment {payment_id}\")\n                    return False\n            \n            # Update user credits\n            new_credits = user.credits + total_credits\n            credits_updated = await db.update_user_credits(user_id, new_credits)\n            \n            if not credits_updated:\n                logger.error(f\"Failed to update credits for user {user_id}, payment {payment_id}\")\n                # Note: Transaction is already recorded, manual intervention may be needed\n                return False\n            \n            # Notify user about successful payment\n            try:\n                await self._notify_payment_success(user_id, total_credits, new_credits)\n            except Exception as e:\n                logger.error(f\"Failed to notify user {user_id} about payment success: {e}\")\n                # Don't return False here - payment was processed successfully\n            \n            logger.info(f\"Payment processed successfully: user={user_id}, payment_id={payment_id}, credits={total_credits}\")\n            return True\n                \n        except ValueError as e:\n            logger.error(f\"Validation error processing payment {payment_id}: {e}\")\n        except Exception as e:\n            logger.error(f\"Unexpected error processing payment {payment_id}: {e}\")\n        \n        return False\n    \n    async def _notify_payment_success(self, user_id: int, credits_added: int, total_credits: int):\n        \"\"\"Notify user about successful payment\"\"\"\n        bot = None\n        try:\n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            \n            from keyboards.inline import get_main_menu_keyboard\n            \n            success_text = f\"\"\"\n‚úÖ <b>–û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\nüí∞ <b>–î–æ–±–∞–≤–ª–µ–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤:</b> {credits_added}\nüí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {total_credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ! üé¨\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_id,\n                text=success_text,\n                parse_mode=\"HTML\",\n                reply_markup=get_main_menu_keyboard()\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error notifying payment success to user {user_id}: {e}\")\n        finally:\n            # Properly close bot session to prevent unclosed client session error\n            if bot:\n                await bot.session.close()\n","size_bytes":16468},"api_integrations/veo_api.py":{"content":"import aiohttp\nimport asyncio\nimport logging\nimport os\nfrom typing import Optional\nfrom config import Config\nfrom database.database import db\nfrom database.models import GenerationType\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass VeoAPI:\n    \"\"\"Veo API integration for video generation\"\"\"\n    \n    def __init__(self):\n        self.base_url = config.VEO_API_BASE_URL\n        self.api_key = config.VEO_API_KEY\n        \n    async def generate_video(\n        self, \n        task_id: str,\n        prompt: str, \n        generation_type: GenerationType,\n        user_id: int,\n        image_file_id: Optional[str] = None\n    ) -> bool:\n        \"\"\"Generate video using Veo API\"\"\"\n        \n        try:\n            headers = {\n                \"Authorization\": f\"Bearer {self.api_key}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            # Prepare request data according to API documentation\n            request_data = {\n                \"prompt\": prompt,\n                \"model\": config.DEFAULT_MODEL,\n                \"aspectRatio\": config.DEFAULT_ASPECT_RATIO,\n                \"enableFallback\": True,  # Enable fallback for higher success rates\n            }\n            \n            # Callback URL temporarily disabled due to port conflict\n            # repl_slug = os.getenv('REPL_SLUG')\n            # repl_owner = os.getenv('REPL_OWNER')\n            # if repl_slug and repl_owner:\n            #     callback_url = f\"https://{repl_slug}.{repl_owner}.repl.co/webhook/veo-complete/{task_id}\"\n            #     request_data[\"callBackUrl\"] = callback_url\n            #     logger.info(f\"Using callback URL: {callback_url}\")\n            \n            # Handle image-to-video\n            if generation_type == GenerationType.IMAGE_TO_VIDEO and image_file_id:\n                # Upload image using kie.ai File Upload API\n                image_url = await self._upload_telegram_image(image_file_id)\n                if image_url:\n                    request_data[\"imageUrls\"] = [image_url]\n                    logger.info(f\"Using uploaded image URL: {image_url}\")\n                else:\n                    logger.error(f\"Failed to upload image for task {task_id}\")\n                    await db.update_video_generation(\n                        task_id, \"failed\", \n                        error_message=\"Failed to upload image to kie.ai\"\n                    )\n                    return False\n            \n            # Log request details for debugging\n            logger.info(f\"Sending API request for task {task_id}\")\n            logger.info(f\"URL: {self.base_url}/api/v1/veo/generate\")\n            logger.info(f\"Prompt: {prompt[:100]}...\")\n            \n            # Make API request\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.base_url}/api/v1/veo/generate\",\n                    headers=headers,\n                    json=request_data,\n                    timeout=aiohttp.ClientTimeout(total=30)\n                ) as response:\n                    \n                    logger.info(f\"API Response status: {response.status}\")\n                    response_text = await response.text()\n                    logger.info(f\"API Response: {response_text[:500]}...\")\n                    \n                    if response.status == 200:\n                        try:\n                            result = await response.json()\n                            logger.info(f\"Parsed response: {result}\")\n                            \n                            if result.get(\"code\") == 200:\n                                veo_task_id = result.get(\"data\", {}).get(\"taskId\")\n                                if veo_task_id:\n                                    # Update database with Veo task ID and set processing status\n                                    await db.update_veo_task_id(task_id, veo_task_id)\n                                    \n                                    # Start polling for completion\n                                    asyncio.create_task(\n                                        self._poll_video_status(task_id, veo_task_id, user_id)\n                                    )\n                                    \n                                    logger.info(f\"Video generation started: {task_id} -> {veo_task_id}\")\n                                    return True\n                                else:\n                                    logger.error(f\"No task ID in response: {result}\")\n                            else:\n                                error_msg = result.get(\"msg\", \"Unknown API error\")\n                                logger.error(f\"API error for task {task_id}: {error_msg}\")\n                                await db.update_video_generation(\n                                    task_id, \"failed\", \n                                    error_message=error_msg\n                                )\n                        except Exception as json_error:\n                            logger.error(f\"JSON parsing error: {json_error}\")\n                            logger.error(f\"Raw response: {response_text}\")\n                    else:\n                        logger.error(f\"HTTP error {response.status} for task {task_id}: {response_text}\")\n                        await db.update_video_generation(\n                            task_id, \"failed\", \n                            error_message=f\"HTTP {response.status}: {response_text[:100]}\"\n                        )\n                        \n        except asyncio.TimeoutError:\n            logger.error(f\"Timeout error for task {task_id}\")\n            await db.update_video_generation(\n                task_id, \"failed\", \n                error_message=\"Request timeout\"\n            )\n        except Exception as e:\n            logger.error(f\"Exception in video generation for task {task_id}: {e}\")\n            await db.update_video_generation(\n                task_id, \"failed\", \n                error_message=str(e)\n            )\n        \n        return False\n    \n    async def _upload_telegram_image(self, file_id: str) -> Optional[str]:\n        \"\"\"Upload Telegram image using kie.ai File Upload API\"\"\"\n        try:\n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            \n            # Download file from Telegram\n            file_info = await bot.get_file(file_id)\n            if not file_info.file_path:\n                logger.error(f\"No file path for image {file_id}\")\n                return None\n            \n            file_data = await bot.download_file(file_info.file_path)\n            if not file_data:\n                logger.error(f\"Failed to download file data for {file_id}\")\n                return None\n            \n            # Convert file data to bytes\n            file_bytes = file_data.read()\n            \n            # Upload to kie.ai File Upload API\n            upload_url = f\"https://kieai.redpandaai.co/api/file-stream-upload\"\n            \n            # Prepare multipart form data\n            form_data = aiohttp.FormData()\n            form_data.add_field('file', \n                              file_bytes, \n                              filename=f\"{file_id}.jpg\",\n                              content_type='image/jpeg')\n            form_data.add_field('uploadPath', 'telegram-images')\n            form_data.add_field('fileName', f\"{file_id}.jpg\")\n            \n            headers = {\n                \"Authorization\": f\"Bearer {self.api_key}\"\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    upload_url,\n                    headers=headers,\n                    data=form_data,\n                    timeout=aiohttp.ClientTimeout(total=30)\n                ) as response:\n                    logger.info(f\"File upload response status: {response.status}\")\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        logger.info(f\"File upload response: {result}\")\n                        \n                        if result.get(\"success\") and result.get(\"data\"):\n                            # File Upload API returns downloadUrl field\n                            file_url = result[\"data\"].get(\"downloadUrl\") or result[\"data\"].get(\"fileUrl\")\n                            if file_url:\n                                logger.info(f\"Image uploaded successfully: {file_id} -> {file_url}\")\n                                return file_url\n                            else:\n                                logger.error(f\"No download URL in response: {result}\")\n                                return None\n                    \n                    # Log error response\n                    error_text = await response.text()\n                    logger.error(f\"File upload failed: {response.status} - {error_text}\")\n                    return None\n            \n        except Exception as e:\n            logger.error(f\"Error uploading image {file_id}: {e}\")\n            return None\n    \n    async def _poll_video_status(self, task_id: str, veo_task_id: str, user_id: int):\n        \"\"\"Poll video generation status with multiple endpoint attempts\"\"\"\n        max_attempts = 60  # 5 minutes with 5-second intervals (video generation takes time)\n        attempt = 0\n        \n        logger.info(f\"Starting polling for task {task_id} with Veo ID {veo_task_id}\")\n        \n        while attempt < max_attempts:\n            try:\n                await asyncio.sleep(5)  # Wait 5 seconds between checks\n                \n                # Try multiple possible endpoints for status checking\n                status_result = await self._get_video_status_multiple_endpoints(veo_task_id)\n                \n                if status_result:\n                    logger.info(f\"Status result for {task_id}: {status_result}\")\n                    \n                    status = status_result.get(\"status\")\n                    \n                    if status == \"completed\" or status == \"success\":\n                        video_url = status_result.get(\"video_url\") or status_result.get(\"videoUrl\") or status_result.get(\"url\")\n                        \n                        if video_url:\n                            await db.update_video_generation(\n                                task_id, \"completed\", video_url=video_url\n                            )\n                            \n                            # Notify user\n                            await self._notify_user_completion(user_id, video_url, task_id)\n                            logger.info(f\"Video generation completed: {task_id}\")\n                            return\n                        \n                    elif status == \"failed\" or status == \"error\":\n                        error_msg = status_result.get(\"error\") or status_result.get(\"message\") or \"Generation failed\"\n                        await db.update_video_generation(\n                            task_id, \"failed\", error_message=error_msg\n                        )\n                        \n                        # Notify user of failure\n                        await self._notify_user_failure(user_id, error_msg)\n                        logger.error(f\"Video generation failed: {task_id} - {error_msg}\")\n                        return\n                else:\n                    logger.warning(f\"No status result for {task_id}, attempt {attempt + 1}\")\n                \n                attempt += 1\n                \n            except Exception as e:\n                logger.error(f\"Error polling status for {task_id}: {e}\")\n                attempt += 1\n        \n        # Timeout - but don't mark as failed immediately\n        logger.warning(f\"Polling timeout for {task_id}, but task might still be processing\")\n        \n        # Just log timeout, don't mark as failed in case task is still processing\n        # The user can check manually or we can implement a longer polling strategy\n    \n    async def _get_video_status_multiple_endpoints(self, veo_task_id: str) -> Optional[dict]:\n        \"\"\"Try multiple possible endpoints for video status\"\"\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        # Use the correct Veo API endpoint according to official docs\n        # The primary endpoint uses GET with taskId as query parameter\n        record_info_url = f\"{self.base_url}/api/v1/veo/record-info?taskId={veo_task_id}\"\n        \n        async with aiohttp.ClientSession() as session:\n            try:\n                # Primary endpoint: GET with taskId as query parameter (official docs)\n                async with session.get(\n                    record_info_url,\n                    headers=headers,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    logger.info(f\"Trying GET {record_info_url}, status: {response.status}\")\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        logger.info(f\"Success response from record-info: {result}\")\n                        \n                        # Handle official Veo API response format\n                        if result.get(\"code\") == 200 and result.get(\"data\"):\n                            data = result[\"data\"]\n                            success_flag = data.get(\"successFlag\")\n                            \n                            # Convert successFlag to standard status format\n                            if success_flag == 0:\n                                # Still processing\n                                return {\"status\": \"processing\"}\n                            elif success_flag == 1:\n                                # Success - extract video URLs from correct location\n                                response_data = data.get(\"response\", {})\n                                result_urls = response_data.get(\"resultUrls\", [])\n                                \n                                if result_urls:\n                                    # resultUrls is already an array\n                                    video_url = result_urls[0] if result_urls and len(result_urls) > 0 else None\n                                    \n                                    if video_url:\n                                        return {\"status\": \"completed\", \"video_url\": video_url}\n                                \n                                logger.error(f\"Success status but no video URLs found. Response: {data}\")\n                            elif success_flag in [2, 3]:\n                                # Failed\n                                error_msg = data.get(\"errorMessage\", \"Video generation failed\")\n                                return {\"status\": \"failed\", \"error\": error_msg}\n                    else:\n                        text = await response.text()\n                        logger.warning(f\"Status {response.status} from record-info: {text[:200]}\")\n                        \n            except Exception as e:\n                logger.error(f\"Error checking status with official endpoint: {e}\")\n                \n            # Fallback: try alternative endpoints if main one fails\n            fallback_endpoints = [\n                f\"{self.base_url}/api/v1/veo/record-detail?taskId={veo_task_id}\",  # Alternative with query param\n                f\"{self.base_url}/api/v1/veo/status/{veo_task_id}\",  # GET with task ID in path\n            ]\n            \n            for endpoint in fallback_endpoints:\n                try:\n                    # For other endpoints, use GET\n                    async with session.get(\n                        endpoint,\n                        headers=headers,\n                        timeout=aiohttp.ClientTimeout(total=10)\n                    ) as response:\n                        \n                        logger.info(f\"Trying GET {endpoint}: status {response.status}\")\n                        \n                        if response.status == 200:\n                            result = await response.json()\n                            logger.info(f\"Success response from {endpoint}: {result}\")\n                            \n                            # Handle different response structures\n                            if \"data\" in result:\n                                return result[\"data\"]\n                            elif \"result\" in result:\n                                return result[\"result\"]\n                            else:\n                                return result\n                                \n                        elif response.status == 404:\n                            continue  # Try next endpoint\n                        else:\n                            text = await response.text()\n                            logger.warning(f\"Status {response.status} from {endpoint}: {text[:200]}\")\n                            \n                except Exception as e:\n                    logger.debug(f\"Error with endpoint {endpoint}: {e}\")\n                    continue\n        \n        return None\n    \n    async def _notify_user_completion(self, user_id: int, video_url: str, task_id: str):\n        \"\"\"Notify user about video completion\"\"\"\n        bot = None\n        try:\n            logger.info(f\"Notifying user {user_id} about completion: {task_id}\")\n            \n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            from keyboards.inline import get_main_menu_keyboard\n            \n            await bot.send_message(\n                chat_id=user_id,\n                text=f\"‚úÖ <b>–í–∞—à–µ –≤–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!</b>\\n\\n\"\n                     f\"üé¨ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∏ –≥–æ—Ç–æ–≤–æ –∫ –ø—Ä–æ—Å–º–æ—Ç—Ä—É.\\n\"\n                     f\"üì• –°–∫–∞—á–∞–π—Ç–µ –≤–∏–¥–µ–æ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ:\",\n                parse_mode=\"HTML\",\n                reply_markup=get_main_menu_keyboard()\n            )\n            \n            # Send video file\n            if video_url and video_url.startswith(\"http\"):\n                await bot.send_video(\n                    chat_id=user_id,\n                    video=video_url,\n                    caption=\"üé¨ –í–∞—à–µ AI-–≤–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!\"\n                )\n            \n        except Exception as e:\n            logger.error(f\"Error notifying user {user_id}: {e}\")\n        finally:\n            # Properly close bot session\n            if bot:\n                await bot.session.close()\n    \n    async def _notify_user_failure(self, user_id: int, error_message: str):\n        \"\"\"Notify user about generation failure\"\"\"\n        bot = None\n        try:\n            logger.info(f\"Notifying user {user_id} about failure: {error_message}\")\n            \n            from aiogram import Bot\n            bot = Bot(token=config.TELEGRAM_BOT_TOKEN)\n            from keyboards.inline import get_main_menu_keyboard\n            \n            user_friendly_error = self._get_user_friendly_error(error_message)\n            \n            await bot.send_message(\n                chat_id=user_id,\n                text=f\"‚ùå <b>–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ</b>\\n\\n\"\n                     f\"–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–µ –≤–∏–¥–µ–æ.\\n\\n\"\n                     f\"üí° <b>–ü—Ä–∏—á–∏–Ω–∞:</b> {user_friendly_error}\\n\\n\"\n                     f\"üí∞ –ö—Ä–µ–¥–∏—Ç—ã –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –Ω–∞ –≤–∞—à —Å—á–µ—Ç.\\n\"\n                     f\"üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —Å –¥—Ä—É–≥–∏–º –∑–∞–ø—Ä–æ—Å–æ–º.\",\n                parse_mode=\"HTML\",\n                reply_markup=get_main_menu_keyboard()\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error notifying user failure {user_id}: {e}\")\n        finally:\n            # Properly close bot session\n            if bot:\n                await bot.session.close()\n    \n    def _get_user_friendly_error(self, error_message: str) -> str:\n        \"\"\"Convert technical error to user-friendly message\"\"\"\n        error_lower = error_message.lower()\n        \n        if \"timeout\" in error_lower:\n            return \"–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –°–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω.\"\n        elif \"content policies\" in error_lower or \"flagged\" in error_lower:\n            return \"–ó–∞–ø—Ä–æ—Å –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –ò–∑–º–µ–Ω–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ.\"\n        elif \"insufficient credits\" in error_lower:\n            return \"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –Ω–∞ —Å—á–µ—Ç–µ.\"\n        elif \"rate limit\" in error_lower:\n            return \"–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ.\"\n        else:\n            return \"–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\"\n","size_bytes":20971},"database/database.py":{"content":"import aiosqlite\nimport logging\nimport os\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom config import Config\nfrom database.models import User, Transaction, VideoGeneration, AdminLog, UserStatus, TransactionType, PaymentMethod, GenerationType\nimport time\nfrom functools import lru_cache\n\n# Try to import asyncpg for PostgreSQL, fallback to SQLite\ntry:\n    import asyncpg\n    POSTGRES_AVAILABLE = True\nexcept ImportError:\n    POSTGRES_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\nconfig = Config()\n\nclass Database:\n    \"\"\"Database manager for PostgreSQL and SQLite operations\"\"\"\n    \n    def __init__(self, database_url: Optional[str] = None, sqlite_path: Optional[str] = None):\n        self.database_url = database_url or os.getenv('DATABASE_URL')\n        self.sqlite_path = sqlite_path or \"bot_database.db\" \n        self.use_postgres = POSTGRES_AVAILABLE and self.database_url is not None\n        \n        # Connection pool for PostgreSQL (performance optimization)\n        self._postgres_pool = None\n        \n        # In-memory cache for frequent queries (performance optimization)\n        self._user_cache = {}\n        self._cache_ttl = 300  # 5 minutes cache TTL\n        \n        if self.use_postgres:\n            logger.info(\"Using PostgreSQL database with connection pooling\")\n        else:\n            logger.info(\"Using SQLite database as fallback\")\n    \n    async def get_postgres_pool(self):\n        \"\"\"Get or create PostgreSQL connection pool\"\"\"\n        if self._postgres_pool is None:\n            self._postgres_pool = await asyncpg.create_pool(\n                self.database_url,\n                min_size=2,\n                max_size=10,\n                command_timeout=30\n            )\n        return self._postgres_pool\n    \n    async def get_postgres_connection(self):\n        \"\"\"Get PostgreSQL connection from pool\"\"\"\n        pool = await self.get_postgres_pool()\n        return pool\n    \n    def get_sqlite_connection(self):\n        \"\"\"Get SQLite connection\"\"\"\n        return aiosqlite.connect(self.sqlite_path)\n    \n    async def close_pool(self):\n        \"\"\"Close PostgreSQL connection pool\"\"\"\n        if self._postgres_pool:\n            await self._postgres_pool.close()\n            self._postgres_pool = None\n    \n    async def create_tables(self):\n        \"\"\"Create all necessary tables\"\"\"\n        if self.use_postgres:\n            pool = await self.get_postgres_pool()\n            async with pool.acquire() as conn:\n                # Users table  \n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS users (\n                        telegram_id BIGINT PRIMARY KEY,\n                        username TEXT,\n                        first_name TEXT,\n                        last_name TEXT,\n                        credits INTEGER DEFAULT 0,\n                        status TEXT DEFAULT 'regular',\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                    )\n                ''')\n                \n                # Transactions table\n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS transactions (\n                        id SERIAL PRIMARY KEY,\n                        user_id BIGINT,\n                        type TEXT NOT NULL,\n                        amount INTEGER NOT NULL,\n                        description TEXT,\n                        payment_method TEXT,\n                        payment_id TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Video generations table\n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS video_generations (\n                        id SERIAL PRIMARY KEY,\n                        user_id BIGINT,\n                        task_id TEXT UNIQUE,\n                        veo_task_id TEXT,\n                        prompt TEXT NOT NULL,\n                        generation_type TEXT NOT NULL,\n                        image_url TEXT,\n                        model TEXT DEFAULT 'veo3_fast',\n                        aspect_ratio TEXT DEFAULT '16:9',\n                        status TEXT DEFAULT 'pending',\n                        video_url TEXT,\n                        error_message TEXT,\n                        credits_spent INTEGER DEFAULT 0,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        completed_at TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Admin logs table\n                await conn.execute('''\n                    CREATE TABLE IF NOT EXISTS admin_logs (\n                        id SERIAL PRIMARY KEY,\n                        admin_id BIGINT,\n                        action TEXT NOT NULL,\n                        target_user_id BIGINT,\n                        description TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Create performance indexes\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_payment_id ON transactions(payment_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_created_at ON transactions(created_at)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_user_id ON video_generations(user_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_task_id ON video_generations(task_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_status ON video_generations(status)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_admin_logs_admin_id ON admin_logs(admin_id)')\n                await conn.execute('CREATE INDEX IF NOT EXISTS idx_admin_logs_target_user ON admin_logs(target_user_id)')\n                \n                logger.info(\"Database tables and indexes created successfully (PostgreSQL)\")\n        else:\n            # SQLite version\n            async with self.get_sqlite_connection() as db:\n                # Users table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS users (\n                        telegram_id INTEGER PRIMARY KEY,\n                        username TEXT,\n                        first_name TEXT,\n                        last_name TEXT,\n                        credits INTEGER DEFAULT 0,\n                        status TEXT DEFAULT 'regular',\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                    )\n                ''')\n                \n                # Transactions table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS transactions (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        user_id INTEGER,\n                        type TEXT NOT NULL,\n                        amount INTEGER NOT NULL,\n                        description TEXT,\n                        payment_method TEXT,\n                        payment_id TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Video generations table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS video_generations (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        user_id INTEGER,\n                        task_id TEXT UNIQUE,\n                        veo_task_id TEXT,\n                        prompt TEXT NOT NULL,\n                        generation_type TEXT NOT NULL,\n                        image_url TEXT,\n                        model TEXT DEFAULT 'veo3_fast',\n                        aspect_ratio TEXT DEFAULT '16:9',\n                        status TEXT DEFAULT 'pending',\n                        video_url TEXT,\n                        error_message TEXT,\n                        credits_spent INTEGER DEFAULT 0,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        completed_at TIMESTAMP,\n                        FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Admin logs table\n                await db.execute('''\n                    CREATE TABLE IF NOT EXISTS admin_logs (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        admin_id INTEGER,\n                        action TEXT NOT NULL,\n                        target_user_id INTEGER,\n                        description TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n                    )\n                ''')\n                \n                # Add veo_task_id column if it doesn't exist (migration)\n                try:\n                    await db.execute('ALTER TABLE video_generations ADD COLUMN veo_task_id TEXT')\n                    await db.commit()\n                    logger.info(\"Added veo_task_id column to video_generations table\")\n                except Exception:\n                    # Column already exists\n                    pass\n                \n                await db.commit()\n                logger.info(\"Database tables created successfully (SQLite)\")\n    \n    # User operations\n    def _is_cache_valid(self, cache_time: float) -> bool:\n        \"\"\"Check if cache entry is still valid\"\"\"\n        return time.time() - cache_time < self._cache_ttl\n    \n    def _cache_user(self, user: User):\n        \"\"\"Cache user data\"\"\"\n        self._user_cache[user.telegram_id] = {\n            'user': user,\n            'time': time.time()\n        }\n    \n    def _get_cached_user(self, telegram_id: int) -> Optional[User]:\n        \"\"\"Get user from cache if valid\"\"\"\n        if telegram_id in self._user_cache:\n            cache_entry = self._user_cache[telegram_id]\n            if self._is_cache_valid(cache_entry['time']):\n                return cache_entry['user']\n            else:\n                # Remove expired cache entry\n                del self._user_cache[telegram_id]\n        return None\n    \n    async def get_user(self, telegram_id: int) -> Optional[User]:\n        \"\"\"Get user by telegram ID with caching\"\"\"\n        # Check cache first\n        cached_user = self._get_cached_user(telegram_id)\n        if cached_user:\n            return cached_user\n        \n        if self.use_postgres:\n            pool = await self.get_postgres_pool()\n            async with pool.acquire() as conn:\n                row = await conn.fetchrow(\n                    \"SELECT * FROM users WHERE telegram_id = $1\",\n                    telegram_id\n                )\n                if row:\n                    user = User(\n                        telegram_id=row[0],\n                        username=row[1],\n                        first_name=row[2],\n                        last_name=row[3],\n                        credits=row[4],\n                        status=UserStatus(row[5]),\n                        created_at=row[6],\n                        updated_at=row[7]\n                    )\n                    # Cache the user\n                    self._cache_user(user)\n                    return user\n                return None\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute(\n                    \"SELECT * FROM users WHERE telegram_id = ?\",\n                    (telegram_id,)\n                )\n                row = await cursor.fetchone()\n                if row:\n                    return User(\n                        telegram_id=row[0],\n                        username=row[1],\n                        first_name=row[2],\n                        last_name=row[3],\n                        credits=row[4],\n                        status=UserStatus(row[5]),\n                        created_at=datetime.fromisoformat(row[6]) if row[6] else None,\n                        updated_at=datetime.fromisoformat(row[7]) if row[7] else None\n                    )\n                return None\n    \n    async def create_user(self, user: User) -> bool:\n        \"\"\"Create a new user\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                    ''', \n                        user.telegram_id,\n                        user.username,\n                        user.first_name,\n                        user.last_name,\n                        user.credits,\n                        user.status.value,\n                        user.created_at or datetime.now(),\n                        user.updated_at or datetime.now()\n                    )\n                    logger.info(f\"Created user {user.telegram_id}\")\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n                    ''', (\n                        user.telegram_id,\n                        user.username,\n                        user.first_name,\n                        user.last_name,\n                        user.credits,\n                        user.status.value,\n                        (user.created_at or datetime.now()).isoformat(),\n                        (user.updated_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    logger.info(f\"Created user {user.telegram_id}\")\n                    return True\n        except Exception as e:\n            logger.error(f\"Error creating user {user.telegram_id}: {e}\")\n            return False\n    \n    async def update_user_credits(self, telegram_id: int, credits: int) -> bool:\n        \"\"\"Update user credits\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute(\n                        \"UPDATE users SET credits = $1, updated_at = $2 WHERE telegram_id = $3\",\n                        credits, datetime.now(), telegram_id\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute(\n                        \"UPDATE users SET credits = ?, updated_at = ? WHERE telegram_id = ?\",\n                        (credits, datetime.now().isoformat(), telegram_id)\n                    )\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error updating credits for user {telegram_id}: {e}\")\n            return False\n    \n    # Transaction operations\n    async def create_transaction(self, transaction: Transaction) -> bool:\n        \"\"\"Create a new transaction\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                    ''', \n                        transaction.user_id,\n                        transaction.type.value,\n                        transaction.amount,\n                        transaction.description,\n                        transaction.payment_method.value if transaction.payment_method is not None else None,\n                        transaction.payment_id,\n                        transaction.created_at or datetime.now()\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES (?, ?, ?, ?, ?, ?, ?)\n                    ''', (\n                        transaction.user_id,\n                        transaction.type.value,\n                        transaction.amount,\n                        transaction.description,\n                        transaction.payment_method.value if transaction.payment_method is not None else None,\n                        transaction.payment_id,\n                        (transaction.created_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error creating transaction: {e}\")\n            return False\n    \n    async def payment_exists(self, payment_id: str) -> bool:\n        \"\"\"Check if payment_id already exists in transactions\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    result = await conn.fetchval(\n                        \"SELECT COUNT(*) FROM transactions WHERE payment_id = $1\",\n                        payment_id\n                    )\n                    return result > 0 if result else False\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    cursor = await db.execute(\n                        \"SELECT COUNT(*) FROM transactions WHERE payment_id = ?\",\n                        (payment_id,)\n                    )\n                    result = await cursor.fetchone()\n                    return result[0] > 0 if result else False\n        except Exception as e:\n            logger.error(f\"Error checking payment existence: {e}\")\n            return False\n    \n    # Video generation operations\n    async def create_video_generation(self, generation: VideoGeneration) -> bool:\n        \"\"\"Create a new video generation record\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, credits_spent, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\n                    ''', \n                        generation.user_id,\n                        generation.task_id,\n                        generation.veo_task_id,\n                        generation.prompt,\n                        generation.generation_type.value if generation.generation_type is not None else 'text_to_video',\n                        generation.image_url,\n                        generation.model,\n                        generation.aspect_ratio,\n                        generation.status,\n                        generation.credits_spent,\n                        generation.created_at or datetime.now()\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, credits_spent, created_at)\n                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n                    ''', (\n                        generation.user_id,\n                        generation.task_id,\n                        generation.veo_task_id,\n                        generation.prompt,\n                        generation.generation_type.value if generation.generation_type is not None else 'text_to_video',\n                        generation.image_url,\n                        generation.model,\n                        generation.aspect_ratio,\n                        generation.status,\n                        generation.credits_spent,\n                        (generation.created_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error creating video generation record: {e}\")\n            return False\n    \n    async def update_video_generation(self, task_id: str, status: str, video_url: Optional[str] = None, error_message: Optional[str] = None) -> bool:\n        \"\"\"Update video generation status\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    completed_at = datetime.now() if status in ['completed', 'failed'] else None\n                    await conn.execute('''\n                        UPDATE video_generations \n                        SET status = $1, video_url = $2, error_message = $3, completed_at = $4\n                        WHERE task_id = $5\n                    ''', status, video_url, error_message, completed_at, task_id)\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    completed_at = datetime.now().isoformat() if status in ['completed', 'failed'] else None\n                    await db.execute('''\n                        UPDATE video_generations \n                        SET status = ?, video_url = ?, error_message = ?, completed_at = ?\n                        WHERE task_id = ?\n                    ''', (status, video_url, error_message, completed_at, task_id))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error updating video generation {task_id}: {e}\")\n            return False\n    \n    async def update_veo_task_id(self, task_id: str, veo_task_id: str) -> bool:\n        \"\"\"Update the Veo API task ID for a generation\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        UPDATE video_generations \n                        SET veo_task_id = $1, status = 'processing'\n                        WHERE task_id = $2\n                    ''', veo_task_id, task_id)\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        UPDATE video_generations \n                        SET veo_task_id = ?, status = 'processing'\n                        WHERE task_id = ?\n                    ''', (veo_task_id, task_id))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error updating veo_task_id for {task_id}: {e}\")\n            return False\n            \n    async def get_video_generation_by_veo_id(self, veo_task_id: str) -> Optional[VideoGeneration]:\n        \"\"\"Get video generation by Veo task ID\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                row = await conn.fetchrow(\n                    \"SELECT * FROM video_generations WHERE veo_task_id = $1\",\n                    veo_task_id\n                )\n                if row:\n                    return VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=row[13],\n                        completed_at=row[14]\n                    )\n                return None\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute(\n                    \"SELECT * FROM video_generations WHERE veo_task_id = ?\",\n                    (veo_task_id,)\n                )\n                row = await cursor.fetchone()\n                if row:\n                    return VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=datetime.fromisoformat(row[13]) if row[13] else None,\n                        completed_at=datetime.fromisoformat(row[14]) if row[14] else None\n                    )\n                return None\n            \n    async def get_processing_generations(self) -> List[VideoGeneration]:\n        \"\"\"Get all processing video generations that have veo_task_id\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                rows = await conn.fetch('''\n                    SELECT * FROM video_generations \n                    WHERE status = 'processing' AND veo_task_id IS NOT NULL\n                ''')\n                generations = []\n                for row in rows:\n                    generation = VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=row[13],\n                        completed_at=row[14]\n                    )\n                    generations.append(generation)\n                return generations\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute('''\n                    SELECT * FROM video_generations \n                    WHERE status = 'processing' AND veo_task_id IS NOT NULL\n                ''')\n                rows = await cursor.fetchall()\n                generations = []\n                for row in rows:\n                    generation = VideoGeneration(\n                        id=row[0],\n                        user_id=row[1],\n                        task_id=row[2],\n                        veo_task_id=row[3],\n                        prompt=row[4],\n                        generation_type=GenerationType(row[5]),\n                        image_url=row[6],\n                        model=row[7],\n                        aspect_ratio=row[8],\n                        status=row[9],\n                        video_url=row[10],\n                        error_message=row[11],\n                        credits_spent=row[12],\n                        created_at=datetime.fromisoformat(row[13]) if row[13] else None,\n                        completed_at=datetime.fromisoformat(row[14]) if row[14] else None\n                    )\n                    generations.append(generation)\n                return generations\n    \n    # Admin operations\n    async def get_user_statistics(self) -> dict:\n        \"\"\"Get user statistics for admin\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                # Total users\n                total_users = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n                \n                # Active users (generated video in last 30 days)\n                active_users = await conn.fetchval('''\n                    SELECT COUNT(DISTINCT user_id) FROM video_generations \n                    WHERE created_at >= NOW() - INTERVAL '30 days'\n                ''')\n                \n                # Total credits in system\n                total_credits = await conn.fetchval(\"SELECT SUM(credits) FROM users\") or 0\n                \n                # Total videos generated\n                total_videos = await conn.fetchval(\"SELECT COUNT(*) FROM video_generations WHERE status = 'completed'\")\n                \n                return {\n                    'total_users': total_users or 0,\n                    'active_users': active_users or 0,\n                    'total_credits': total_credits or 0,\n                    'total_videos': total_videos or 0\n                }\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                # Total users\n                cursor = await db.execute(\"SELECT COUNT(*) FROM users\")\n                result = await cursor.fetchone()\n                total_users = result[0] if result else 0\n                \n                # Active users (generated video in last 30 days)\n                cursor = await db.execute('''\n                    SELECT COUNT(DISTINCT user_id) FROM video_generations \n                    WHERE created_at >= datetime('now', '-30 days')\n                ''')\n                result = await cursor.fetchone()\n                active_users = result[0] if result else 0\n                \n                # Total credits in system\n                cursor = await db.execute(\"SELECT SUM(credits) FROM users\")\n                result = await cursor.fetchone()\n                total_credits = result[0] if result else 0\n                \n                # Total videos generated\n                cursor = await db.execute(\"SELECT COUNT(*) FROM video_generations WHERE status = 'completed'\")\n                result = await cursor.fetchone()\n                total_videos = result[0] if result else 0\n                \n                return {\n                    'total_users': total_users,\n                    'active_users': active_users,\n                    'total_credits': total_credits,\n                    'total_videos': total_videos\n                }\n    \n    async def get_all_user_ids(self) -> List[int]:\n        \"\"\"Get all user IDs for broadcasting\"\"\"\n        if self.use_postgres:\n            conn = await self.get_postgres_connection()\n            try:\n                rows = await conn.fetch(\"SELECT telegram_id FROM users WHERE status != 'banned'\")\n                return [row[0] for row in rows]\n            finally:\n                await conn.close()\n        else:\n            async with self.get_sqlite_connection() as db:\n                cursor = await db.execute(\"SELECT telegram_id FROM users WHERE status != 'banned'\")\n                rows = await cursor.fetchall()\n                return [row[0] for row in rows]\n    \n    async def log_admin_action(self, log: AdminLog) -> bool:\n        \"\"\"Log admin action\"\"\"\n        try:\n            if self.use_postgres:\n                conn = await self.get_postgres_connection()\n                try:\n                    await conn.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES ($1, $2, $3, $4, $5)\n                    ''', \n                        log.admin_id,\n                        log.action,\n                        log.target_user_id,\n                        log.description,\n                        log.created_at or datetime.now()\n                    )\n                    return True\n                finally:\n                    await conn.close()\n            else:\n                async with self.get_sqlite_connection() as db:\n                    await db.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES (?, ?, ?, ?, ?)\n                    ''', (\n                        log.admin_id,\n                        log.action,\n                        log.target_user_id,\n                        log.description,\n                        (log.created_at or datetime.now()).isoformat()\n                    ))\n                    await db.commit()\n                    return True\n        except Exception as e:\n            logger.error(f\"Error logging admin action: {e}\")\n            return False\n\n# Create database instance directly\ndb = Database()\n\nasync def init_database():\n    \"\"\"Initialize database with tables and admin user\"\"\"\n    await db.create_tables()\n    \n    # Create admin user if not exists\n    admin_user = await db.get_user(config.ADMIN_USER_ID)\n    if not admin_user:\n        admin_user = User(\n            telegram_id=config.ADMIN_USER_ID,\n            credits=config.INITIAL_ADMIN_CREDITS,\n            status=UserStatus.ADMIN\n        )\n        await db.create_user(admin_user)\n        \n        # Log admin creation\n        transaction = Transaction(\n            user_id=config.ADMIN_USER_ID,\n            type=TransactionType.ADMIN_GRANT,\n            amount=config.INITIAL_ADMIN_CREDITS,\n            description=\"Initial admin credits\"\n        )\n        await db.create_transaction(transaction)\n        \n        logger.info(f\"Admin user created with {config.INITIAL_ADMIN_CREDITS} credits\")\n","size_bytes":35362},"database/models.py":{"content":"from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom enum import Enum\n\nclass UserStatus(Enum):\n    REGULAR = \"regular\"\n    ADMIN = \"admin\"\n    BANNED = \"banned\"\n\nclass TransactionType(Enum):\n    CREDIT_PURCHASE = \"credit_purchase\"\n    CREDIT_SPEND = \"credit_spend\"\n    ADMIN_GRANT = \"admin_grant\"\n\nclass PaymentMethod(Enum):\n    TELEGRAM_STARS = \"telegram_stars\"\n    YOOKASSA = \"yookassa\"\n\nclass GenerationType(Enum):\n    TEXT_TO_VIDEO = \"text_to_video\"\n    IMAGE_TO_VIDEO = \"image_to_video\"\n\n@dataclass\nclass User:\n    \"\"\"User model\"\"\"\n    telegram_id: int\n    username: Optional[str] = None\n    first_name: Optional[str] = None\n    last_name: Optional[str] = None\n    credits: int = 0\n    status: UserStatus = UserStatus.REGULAR\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.updated_at is None:\n            self.updated_at = datetime.now()\n\n@dataclass\nclass Transaction:\n    \"\"\"Transaction model for credit operations\"\"\"\n    id: Optional[int] = None\n    user_id: Optional[int] = None\n    type: Optional[TransactionType] = None\n    amount: int = 0\n    description: str = \"\"\n    payment_method: Optional[PaymentMethod] = None\n    payment_id: Optional[str] = None\n    created_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n@dataclass\nclass VideoGeneration:\n    \"\"\"Video generation task model\"\"\"\n    id: Optional[int] = None\n    user_id: Optional[int] = None\n    task_id: str = \"\"\n    veo_task_id: Optional[str] = None  # API task ID from Veo\n    prompt: str = \"\"\n    generation_type: Optional[GenerationType] = None\n    image_url: Optional[str] = None\n    model: str = \"veo3_fast\"\n    aspect_ratio: str = \"16:9\"\n    status: str = \"pending\"  # pending, processing, completed, failed\n    video_url: Optional[str] = None\n    error_message: Optional[str] = None\n    credits_spent: int = 0\n    created_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n@dataclass\nclass AdminLog:\n    \"\"\"Admin action log model\"\"\"\n    id: Optional[int] = None\n    admin_id: Optional[int] = None\n    action: str = \"\"\n    target_user_id: Optional[int] = None\n    description: str = \"\"\n    created_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n","size_bytes":2673},"handlers/admin.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nimport asyncio\n\nfrom database.database import db\nfrom database.models import AdminLog, UserStatus\nfrom keyboards.inline import get_admin_menu_keyboard, get_back_to_admin_keyboard\nfrom config import Config\nfrom utils.logger import get_logger\nfrom admin_tools.credit_management import check_user_credits, grant_user_credits, emergency_credit_restore\n\nlogger = get_logger(__name__)\nrouter = Router()\nconfig = Config()\n\nclass AdminStates(StatesGroup):\n    waiting_broadcast_message = State()\n    waiting_payment_id = State()\n    waiting_user_id_for_notification = State()\n    waiting_user_id_for_credits = State()\n    waiting_credits_amount = State()\n    waiting_credits_reason = State()\n\nasync def is_admin(user_id: int) -> bool:\n    \"\"\"Check if user is admin\"\"\"\n    user = await db.get_user(user_id)\n    return user and user.status == UserStatus.ADMIN\n\n@router.message(Command(\"admin\"))\nasync def admin_command(message: Message, state: FSMContext):\n    \"\"\"Handle /admin command\"\"\"\n    if not await is_admin(message.from_user.id):\n        await message.answer(\"‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\")\n        return\n    \n    await state.clear()\n    \n    admin_text = \"\"\"\nüëë <b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\n\nüìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b> - –ø—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\nüí∞ <b>–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫—Ä–µ–¥–∏—Ç—ã</b> - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID\nüíé <b>–í—ã–¥–∞—Ç—å –∫—Ä–µ–¥–∏—Ç—ã</b> - –Ω–∞—á–∏—Å–ª–∏—Ç—å –∫—Ä–µ–¥–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (—Ç–æ–ª—å–∫–æ –Ω–∞ production)\nüì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b> - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\nüîç <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞</b> - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∏ –Ω–∞—á–∏—Å–ª–∏—Ç—å –∫—Ä–µ–¥–∏—Ç—ã\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:\n    \"\"\"\n    \n    await message.answer(\n        admin_text,\n        reply_markup=get_admin_menu_keyboard()\n    )\n\n@router.callback_query(F.data == \"admin_stats\")\nasync def admin_statistics(callback: CallbackQuery):\n    \"\"\"Show admin statistics\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    try:\n        stats = await db.get_user_statistics()\n        \n        stats_text = f\"\"\"\nüìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\nüë• <b>–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b> {stats['total_users']}\nüî• <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (30 –¥–Ω–µ–π):</b> {stats['active_users']}\nüí∞ <b>–í—Å–µ–≥–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –≤ —Å–∏—Å—Ç–µ–º–µ:</b> {stats['total_credits']:,}\nüé¨ <b>–í—Å–µ–≥–æ —Å–æ–∑–¥–∞–Ω–æ –≤–∏–¥–µ–æ:</b> {stats['total_videos']}\n\nüìà <b>–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:</b>\n‚Ä¢ –ö–æ–Ω–≤–µ—Ä—Å–∏—è –≤ –∞–∫—Ç–∏–≤–Ω—ã—Ö: {(stats['active_users'] / max(stats['total_users'], 1) * 100):.1f}%\n‚Ä¢ –°—Ä–µ–¥–Ω–µ–µ –∫—Ä–µ–¥–∏—Ç–æ–≤ –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {(stats['total_credits'] / max(stats['total_users'], 1)):.1f}\n        \"\"\"\n        \n        await callback.message.edit_text(\n            stats_text,\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        \n        # Log admin action\n        admin_log = AdminLog(\n            admin_id=callback.from_user.id,\n            action=\"view_statistics\",\n            description=\"Viewed user statistics\"\n        )\n        await db.log_admin_action(admin_log)\n        \n    except Exception as e:\n        logger.error(f\"Error getting admin statistics: {e}\")\n        await callback.message.edit_text(\n            \"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n    \n    await callback.answer()\n\n@router.callback_query(F.data == \"admin_broadcast\")\nasync def admin_broadcast_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start broadcast message creation\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    broadcast_text = \"\"\"\nüì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\n\nüí° <b>–í—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å:</b>\n‚Ä¢ –¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ\n‚Ä¢ –°–æ–æ–±—â–µ–Ω–∏–µ —Å —Ñ–æ—Ç–æ\n‚Ä¢ –ü–µ—Ä–µ—Å–ª–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –¥—Ä—É–≥–æ–≥–æ —á–∞—Ç–∞\n\n‚ö†Ô∏è <b>–í–Ω–∏–º–∞–Ω–∏–µ:</b> –†–∞—Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –í–°–ï–ú –∞–∫—Ç–∏–≤–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –±–æ—Ç–∞!\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        broadcast_text,\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_broadcast_message)\n    await callback.answer()\n\n@router.message(AdminStates.waiting_broadcast_message)\nasync def admin_broadcast_process(message: Message, state: FSMContext):\n    \"\"\"Process broadcast message\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    await state.clear()\n    \n    # Get all user IDs\n    user_ids = await db.get_all_user_ids()\n    total_users = len(user_ids)\n    \n    if total_users == 0:\n        await message.answer(\n            \"‚ùå –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        return\n    \n    # Confirm broadcast\n    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n    confirm_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [\n            InlineKeyboardButton(text=\"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É\", callback_data=\"confirm_broadcast\"),\n            InlineKeyboardButton(text=\"‚ùå –û—Ç–º–µ–Ω–∏—Ç—å\", callback_data=\"admin_menu\")\n        ]\n    ])\n    \n    await message.answer(\n        f\"üì¢ <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b>\\n\\n\"\n        f\"üë• <b>–ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π:</b> {total_users} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\\n\"\n        f\"üìù <b>–¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è:</b> {'–° —Ñ–æ—Ç–æ' if message.photo else '–¢–µ–∫—Å—Ç–æ–≤–æ–µ'}\\n\\n\"\n        f\"‚ö†Ô∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É?\",\n        reply_markup=confirm_keyboard\n    )\n    \n    # Store message for broadcast\n    await state.update_data(\n        broadcast_message_id=message.message_id,\n        total_users=total_users\n    )\n\n@router.callback_query(F.data == \"confirm_broadcast\")\nasync def admin_broadcast_confirm(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Confirm and execute broadcast\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    state_data = await state.get_data()\n    broadcast_message_id = state_data.get('broadcast_message_id')\n    total_users = state_data.get('total_users', 0)\n    \n    if not broadcast_message_id:\n        await callback.answer(\"‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ\")\n        return\n    \n    await state.clear()\n    \n    # Start broadcast\n    progress_msg = await callback.message.edit_text(\n        f\"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å...</b>\\n\\n\"\n        f\"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\\n\"\n        f\"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: 0\\n\"\n        f\"‚ùå –û—à–∏–±–æ–∫: 0\\n\\n\"\n        f\"‚è≥ –û–∂–∏–¥–∞–π—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è...\"\n    )\n    \n    # Get user IDs and start broadcast\n    user_ids = await db.get_all_user_ids()\n    success_count = 0\n    error_count = 0\n    \n    # Import bot instance\n    from aiogram import Bot\n    from config import Config\n    bot_config = Config()\n    bot = Bot(token=bot_config.TELEGRAM_BOT_TOKEN)\n    \n    for i, user_id in enumerate(user_ids):\n        try:\n            # Forward the broadcast message\n            await bot.forward_message(\n                chat_id=user_id,\n                from_chat_id=callback.from_user.id,\n                message_id=broadcast_message_id\n            )\n            success_count += 1\n            \n            # Update progress every 10 users\n            if (i + 1) % 10 == 0 or i == len(user_ids) - 1:\n                try:\n                    await progress_msg.edit_text(\n                        f\"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ...</b>\\n\\n\"\n                        f\"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\\n\"\n                        f\"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {success_count}\\n\"\n                        f\"‚ùå –û—à–∏–±–æ–∫: {error_count}\\n\"\n                        f\"üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: {((i + 1) / total_users * 100):.1f}%\"\n                    )\n                except:\n                    pass  # Ignore edit errors\n            \n            # Small delay to avoid rate limits\n            await asyncio.sleep(0.05)\n            \n        except Exception as e:\n            error_count += 1\n            logger.warning(f\"Broadcast error for user {user_id}: {e}\")\n            \n            # Longer delay on errors\n            await asyncio.sleep(0.1)\n    \n    # Final results\n    await progress_msg.edit_text(\n        f\"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\\n\\n\"\n        f\"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\\n\"\n        f\"‚úÖ –£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {success_count}\\n\"\n        f\"‚ùå –û—à–∏–±–æ–∫ –¥–æ—Å—Ç–∞–≤–∫–∏: {error_count}\\n\"\n        f\"üìä –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {(success_count / max(total_users, 1) * 100):.1f}%\",\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    \n    # Log admin action\n    admin_log = AdminLog(\n        admin_id=callback.from_user.id,\n        action=\"broadcast_message\",\n        description=f\"Broadcast sent to {success_count}/{total_users} users\"\n    )\n    await db.log_admin_action(admin_log)\n    \n    logger.info(f\"Broadcast completed: {success_count}/{total_users} users\")\n    await callback.answer(\"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\")\n\n@router.callback_query(F.data == \"admin_check_payment\")\nasync def admin_check_payment(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Check payment status manually\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    await callback.message.edit_text(\n        \"üîç <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞</b>\\n\\n\"\n        \"–í–≤–µ–¥–∏—Ç–µ ID –ø–ª–∞—Ç–µ–∂–∞ –Æ–ö–∞—Å—Å—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–æ–≤:\\n\\n\"\n        \"üí° ID –ø–ª–∞—Ç–µ–∂–∞ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤ –ª–æ–≥–∞—Ö –±–æ—Ç–∞ –∏–ª–∏ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ –Æ–ö–∞—Å—Å—ã\",\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_payment_id)\n    await callback.answer()\n\n@router.message(AdminStates.waiting_payment_id)\nasync def process_payment_check(message: Message, state: FSMContext):\n    \"\"\"Process payment ID and check status\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    payment_id = message.text.strip()\n    \n    if not payment_id:\n        await message.reply(\"‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –ø–ª–∞—Ç–µ–∂–∞\")\n        return\n    \n    # Show progress message\n    progress_msg = await message.reply(\"üîç –ü—Ä–æ–≤–µ—Ä—è—é —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞...\")\n    \n    try:\n        from api_integrations.payment_api import PaymentAPI\n        \n        payment_api = PaymentAPI()\n        result = await payment_api.verify_yookassa_payment(payment_id)\n        \n        if result.get(\"status\") == \"error\":\n            await progress_msg.edit_text(f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {result.get('message')}\")\n            await state.clear()\n            return\n        \n        status = result.get(\"status\")\n        amount = result.get(\"amount\")\n        currency = result.get(\"currency\")\n        metadata = result.get(\"metadata\", {})\n        is_paid = result.get(\"paid\", False)\n        \n        user_id = metadata.get(\"user_id\")\n        package_id = metadata.get(\"package_id\")\n        \n        status_text = f\"\"\"\nüîç <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–ª–∞—Ç–µ–∂–∞</b>\n\nüí≥ <b>ID –ø–ª–∞—Ç–µ–∂–∞:</b> {payment_id}\nüí∞ <b>–°—É–º–º–∞:</b> {amount} {currency}\nüìä <b>–°—Ç–∞—Ç—É—Å:</b> {status}\n‚úÖ <b>–û–ø–ª–∞—á–µ–Ω:</b> {'–î–∞ ‚úÖ' if is_paid else '–ù–µ—Ç ‚ùå'}\n\nüë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {user_id or '–ù–µ —É–∫–∞–∑–∞–Ω'}\nüì¶ <b>–ü–∞–∫–µ—Ç:</b> {package_id or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n        \"\"\"\n        \n        if is_paid and user_id and package_id:\n            # Check if credits were already processed\n            payment_exists = await db.payment_exists(payment_id)\n            \n            if payment_exists:\n                status_text += \"\\n\\n‚ö†Ô∏è –ö—Ä–µ–¥–∏—Ç—ã —É–∂–µ –Ω–∞—á–∏—Å–ª–µ–Ω—ã —Ä–∞–Ω–µ–µ\"\n            else:\n                # Process payment manually\n                await progress_msg.edit_text(\"üí∞ –ù–∞—á–∏—Å–ª—è—é –∫—Ä–µ–¥–∏—Ç—ã...\")\n                \n                success = await payment_api._process_successful_card_payment(\n                    user_id=int(user_id),\n                    package_id=package_id,\n                    payment_id=payment_id,\n                    amount=float(amount)\n                )\n                \n                if success:\n                    status_text += \"\\n\\n‚úÖ –ö—Ä–µ–¥–∏—Ç—ã —É—Å–ø–µ—à–Ω–æ –Ω–∞—á–∏—Å–ª–µ–Ω—ã!\"\n                    \n                    # Log admin action\n                    admin_log = AdminLog(\n                        admin_id=message.from_user.id,\n                        action=\"manual_payment_processing\",\n                        target_user_id=int(user_id),\n                        description=f\"Manually processed payment {payment_id}\"\n                    )\n                    await db.log_admin_action(admin_log)\n                else:\n                    status_text += \"\\n\\n‚ùå –û—à–∏–±–∫–∞ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n        elif is_paid:\n            status_text += \"\\n\\n‚ö†Ô∏è –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–µ–Ω, –Ω–æ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –Ω–µ–ø–æ–ª–Ω—ã–µ\"\n        \n        await progress_msg.edit_text(status_text)\n        \n    except Exception as e:\n        logger.error(f\"Error checking payment {payment_id}: {e}\")\n        await progress_msg.edit_text(f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–ª–∞—Ç–µ–∂–∞: {e}\")\n    \n    await state.clear()\n\n@router.callback_query(F.data == \"admin_menu\")\nasync def back_to_admin_menu(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Back to admin menu\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    await state.clear()\n    \n    admin_text = \"\"\"\nüëë <b>–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        admin_text,\n        reply_markup=get_admin_menu_keyboard()\n    )\n    await callback.answer()\n\n# ======= –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ö–†–ï–î–ò–¢–ê–ú–ò =======\n\n@router.callback_query(F.data == \"admin_check_credits\")\nasync def admin_check_credits_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start checking user credits\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    text = \"\"\"\nüîç <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n–í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (Telegram ID), —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –µ–≥–æ –±–∞–ª–∞–Ω—Å –∫—Ä–µ–¥–∏—Ç–æ–≤:\n\n<i>–ü—Ä–∏–º–µ—Ä: 123456789</i>\n    \"\"\"\n    \n    await callback.message.edit_text(\n        text,\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_user_id_for_credits)\n    await state.update_data(action=\"check\")\n    await callback.answer()\n\n@router.callback_query(F.data == \"admin_grant_credits\")\nasync def admin_grant_credits_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start granting credits to user\"\"\"\n    if not await is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞\")\n        return\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º environment\n    from admin_tools.credit_management import credit_manager\n    \n    if not credit_manager.is_production:\n        await callback.message.edit_text(\n            \"‚ö†Ô∏è <b>–í—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞</b>\\n\\n\"\n            \"–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ production (–ø–æ—Å–ª–µ deploy).\\n\"\n            \"–õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–¥–∞–≤–∞—Ç—å –∫—Ä–µ–¥–∏—Ç—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        await callback.answer()\n        return\n    \n    text = \"\"\"\nüíé <b>–í—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é</b>\n\n‚ö†Ô∏è <b>–í–ù–ò–ú–ê–ù–ò–ï:</b> –í—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ production!\n\n–í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (Telegram ID):\n\n<i>–ü—Ä–∏–º–µ—Ä: 123456789</i>\n    \"\"\"\n    \n    await callback.message.edit_text(\n        text,\n        reply_markup=get_back_to_admin_keyboard()\n    )\n    await state.set_state(AdminStates.waiting_user_id_for_credits)\n    await state.update_data(action=\"grant\")\n    await callback.answer()\n\n@router.message(AdminStates.waiting_user_id_for_credits)\nasync def admin_process_user_id_for_action(message: Message, state: FSMContext):\n    \"\"\"Process user ID for credit actions\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    try:\n        data = await state.get_data()\n        action = data.get('action', 'check')\n        user_id = int(message.text.strip())\n        \n        if action == \"check\":\n            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–µ–¥–∏—Ç—ã —á–µ—Ä–µ–∑ –±–µ–∑–æ–ø–∞—Å–Ω—É—é —Å–∏—Å—Ç–µ–º—É\n            result = await check_user_credits(message.from_user.id, user_id)\n            \n            if \"error\" in result:\n                await message.answer(f\"‚ùå {result['error']}\")\n            else:\n                credits_text = f\"\"\"\nüí∞ <b>–ë–∞–ª–∞–Ω—Å –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\nüë§ <b>User ID:</b> {result['user_id']}\nüë§ <b>Username:</b> @{result['username'] or '–Ω–µ —É–∫–∞–∑–∞–Ω'}\nüë§ <b>–ò–º—è:</b> {result['first_name'] or '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}\nüíé <b>–ö—Ä–µ–¥–∏—Ç—ã:</b> {result['credits']}\nüìä <b>–°—Ç–∞—Ç—É—Å:</b> {result['status']}\nüìÖ <b>–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è:</b> {result['created_at'][:10] if result['created_at'] else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}\nüïê <b>–û–±–Ω–æ–≤–ª–µ–Ω:</b> {result['updated_at'][:10] if result['updated_at'] else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}\n                \"\"\"\n                \n                await message.answer(\n                    credits_text,\n                    reply_markup=get_back_to_admin_keyboard()\n                )\n            await state.clear()\n            \n        elif action == \"grant\":\n            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≤–≤–æ–¥—É –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤\n            await state.update_data(user_id=user_id)\n            \n            await message.answer(\n                f\"üíé <b>–í—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}</b>\\n\\n\"\n                f\"–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–ª—è –≤—ã–¥–∞—á–∏ (1-1000):\\n\\n\"\n                f\"<i>–ù–∞–ø—Ä–∏–º–µ—Ä: 50</i>\",\n                reply_markup=get_back_to_admin_keyboard()\n            )\n            await state.set_state(AdminStates.waiting_credits_amount)\n            \n    except ValueError:\n        await message.answer(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–π Telegram ID.\")\n    except Exception as e:\n        logger.error(f\"Error processing user ID for action: {e}\")\n        await message.answer(\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\")\n\n@router.message(AdminStates.waiting_credits_amount)\nasync def admin_process_credits_amount(message: Message, state: FSMContext):\n    \"\"\"Process credits amount input\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    try:\n        credits = int(message.text.strip())\n        \n        if credits <= 0:\n            await message.answer(\"‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.\")\n            return\n            \n        if credits > 1000:\n            await message.answer(\"‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞ —Ä–∞–∑: 1000\")\n            return\n        \n        await state.update_data(credits=credits)\n        \n        await message.answer(\n            f\"üíé <b>–í—ã–¥–∞—á–∞ {credits} –∫—Ä–µ–¥–∏—Ç–æ–≤</b>\\n\\n\"\n            f\"–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –≤—ã–¥–∞—á–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ):\\n\\n\"\n            f\"<i>–ù–∞–ø—Ä–∏–º–µ—Ä: –ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è –∑–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é –æ—à–∏–±–∫—É</i>\\n\\n\"\n            f\"–ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ '-' —á—Ç–æ–±—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å:\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n        await state.set_state(AdminStates.waiting_credits_reason)\n        \n    except ValueError:\n        await message.answer(\"‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤.\")\n    except Exception as e:\n        logger.error(f\"Error processing credits amount: {e}\")\n        await message.answer(\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤.\")\n\n@router.message(AdminStates.waiting_credits_reason)\nasync def admin_process_credits_reason(message: Message, state: FSMContext):\n    \"\"\"Process credits reason and complete grant\"\"\"\n    if not await is_admin(message.from_user.id):\n        return\n    \n    try:\n        data = await state.get_data()\n        user_id = data.get('user_id')\n        credits = data.get('credits')\n        reason = message.text.strip() if message.text.strip() != '-' else \"\"\n        \n        # –í—ã–¥–∞–µ–º –∫—Ä–µ–¥–∏—Ç—ã —á–µ—Ä–µ–∑ –±–µ–∑–æ–ø–∞—Å–Ω—É—é —Å–∏—Å—Ç–µ–º—É —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\n        result = await grant_user_credits(message.from_user.id, user_id, credits, reason, message.bot)\n        \n        if result.get(\"success\"):\n            notification_status = \"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\" if result.get(\"notification_sent\") else \"‚ö†Ô∏è –ù–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ\"\n            \n            success_text = f\"\"\"\n‚úÖ <b>–ö–†–ï–î–ò–¢–´ –£–°–ü–ï–®–ù–û –í–´–î–ê–ù–´!</b>\n\nüë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {result['user_id']}\nüíé <b>–í—ã–¥–∞–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤:</b> {result['credits_granted']}\nüí∞ <b>–°—Ç–∞—Ä—ã–π –±–∞–ª–∞–Ω—Å:</b> {result['old_balance']}\nüí∞ <b>–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å:</b> {result['new_balance']}\nüìù <b>–ü—Ä–∏—á–∏–Ω–∞:</b> {result['reason'] or '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}\nüïê <b>–í—Ä–µ–º—è:</b> {result['timestamp'][:19]}\nüì® <b>–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é:</b> {notification_status}\n\n–û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–ø–∏—Å–∞–Ω–∞ –≤ –ª–æ–≥–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.\n            \"\"\"\n            await message.answer(\n                success_text,\n                reply_markup=get_back_to_admin_keyboard()\n            )\n        else:\n            await message.answer(\n                f\"‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–¥–∞—á–µ –∫—Ä–µ–¥–∏—Ç–æ–≤:</b>\\n\\n{result.get('error')}\",\n                reply_markup=get_back_to_admin_keyboard()\n            )\n            \n    except Exception as e:\n        logger.error(f\"Error in credit grant completion: {e}\")\n        await message.answer(\n            \"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –≤—ã–¥–∞—á–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤.\",\n            reply_markup=get_back_to_admin_keyboard()\n        )\n    \n    await state.clear()\n","size_bytes":23887},"handlers/generate.py":{"content":"from aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nimport uuid\n\nfrom database.database import db\nfrom database.models import VideoGeneration, Transaction, TransactionType, GenerationType\nfrom api_integrations.veo_api import VeoAPI\nfrom keyboards.inline import get_generation_menu_keyboard, get_back_to_menu_keyboard\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nrouter = Router()\nconfig = Config()\n\nclass GenerationStates(StatesGroup):\n    waiting_text_prompt = State()\n    waiting_image_prompt = State()\n    waiting_image = State()\n\n@router.callback_query(F.data == \"generate_video\")\nasync def generate_video_menu(callback: CallbackQuery):\n    \"\"\"Show video generation menu\"\"\"\n    text = \"\"\"\nüé¨ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:\n\nüìù –í–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞ - —Å–æ–∑–¥–∞–π—Ç–µ –≤–∏–¥–µ–æ –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é\nüñº –í–∏–¥–µ–æ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è - –æ–∂–∏–≤–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –ò–ò\n\nüí° –°—Ç–æ–∏–º–æ—Å—Ç—å: 10 –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞ –≤–∏–¥–µ–æ (79‚ÇΩ)\n    \"\"\"\n    \n    await callback.message.edit_text(\n        text,\n        reply_markup=get_generation_menu_keyboard()\n    )\n    await callback.answer()\n\n@router.callback_query(F.data == \"text_to_video\")\nasync def text_to_video_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start text-to-video generation\"\"\"\n    user = await db.get_user(callback.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await callback.message.edit_text(\n            f\"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!</b>\\n\\n\"\n            f\"–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –Ω—É–∂–Ω–æ {config.VIDEO_GENERATION_COST} –∫—Ä–µ–¥–∏—Ç–æ–≤.\\n\"\n            f\"–í–∞—à –±–∞–ª–∞–Ω—Å: {user.credits if user else 0} –∫—Ä–µ–¥–∏—Ç–æ–≤\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        await callback.answer()\n        return\n    \n    prompt_tips = \"\"\"\nüé¨ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞</b>\n\nüìù –ù–∞–ø–∏—à–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–µ–æ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å.\n\nüí° <b>–°–æ–≤–µ—Ç—ã –¥–ª—è –ª—É—á—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:</b>\n‚Ä¢ –û–ø–∏—Å—ã–≤–∞–π—Ç–µ –¥–µ–π—Å—Ç–≤–∏—è, –¥–≤–∏–∂–µ–Ω–∏—è, —Å—Ü–µ–Ω—ã\n‚Ä¢ –£–∫–∞–∑—ã–≤–∞–π—Ç–µ —Å—Ç–∏–ª—å, –æ—Å–≤–µ—â–µ–Ω–∏–µ, —Ä–∞–∫—É—Ä—Å –∫–∞–º–µ—Ä—ã\n‚Ä¢ –ë—É–¥—å—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –∏ –¥–µ—Ç–∞–ª—å–Ω—ã–º–∏\n‚Ä¢ –ò–∑–±–µ–≥–∞–π—Ç–µ —Å–ª–æ–∂–Ω—ã—Ö —Å—Ü–µ–Ω —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π\n\n<b>–ü—Ä–∏–º–µ—Ä —Ö–æ—Ä–æ—à–µ–≥–æ –ø—Ä–æ–º–ø—Ç–∞:</b>\n\"–ö—Ä—É–ø–Ω—ã–π –ø–ª–∞–Ω –∑–æ–ª–æ—Ç–∏—Å—Ç–æ–≥–æ —Ä–µ—Ç—Ä–∏–≤–µ—Ä–∞, –∏–≥—Ä–∞—é—â–µ–≥–æ —Å –º—è—á–æ–º –≤ —Å–æ–ª–Ω–µ—á–Ω–æ–º –ø–∞—Ä–∫–µ. –°–æ–±–∞–∫–∞ —Ä–∞–¥–æ—Å—Ç–Ω–æ –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–µ—Ç, –ª–æ–≤—è –º—è—á. –ú—è–≥–∫–æ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ, –∫–∏–Ω–µ–º–∞—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è —Å—ä–µ–º–∫–∞\"\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –ø—Ä–æ–º–ø—Ç:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        prompt_tips,\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    await state.set_state(GenerationStates.waiting_text_prompt)\n    await callback.answer()\n\n@router.callback_query(F.data == \"image_to_video\")\nasync def image_to_video_start(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Start image-to-video generation\"\"\"\n    user = await db.get_user(callback.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await callback.message.edit_text(\n            f\"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!</b>\\n\\n\"\n            f\"–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ –Ω—É–∂–Ω–æ {config.VIDEO_GENERATION_COST} –∫—Ä–µ–¥–∏—Ç–æ–≤.\\n\"\n            f\"–í–∞—à –±–∞–ª–∞–Ω—Å: {user.credits if user else 0} –∫—Ä–µ–¥–∏—Ç–æ–≤\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        await callback.answer()\n        return\n    \n    image_instructions = \"\"\"\nüñº <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n\nüì∑ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –æ–∂–∏–≤–∏—Ç—å.\n\nüìù –ü–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–ø–∏—à–∏—Ç–µ, –∫–∞–∫ –æ–Ω–æ –¥–æ–ª–∂–Ω–æ –æ–∂–∏—Ç—å:\n\nüí° <b>–°–æ–≤–µ—Ç—ã:</b>\n‚Ä¢ –û–ø–∏—Å—ã–≤–∞–π—Ç–µ –¥–≤–∏–∂–µ–Ω–∏—è –∏ –¥–µ–π—Å—Ç–≤–∏—è\n‚Ä¢ –£–∫–∞–∑—ã–≤–∞–π—Ç–µ, –∫–∞–∫–∏–µ —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –¥–≤–∏–≥–∞—Ç—å—Å—è\n‚Ä¢ –ò–∑–±–µ–≥–∞–π—Ç–µ –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n‚Ä¢ –§–æ–∫—É—Å–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –¥–≤–∏–∂–µ–Ω–∏—è—Ö\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        image_instructions,\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    await state.set_state(GenerationStates.waiting_image)\n    await callback.answer()\n\n@router.message(GenerationStates.waiting_text_prompt)\nasync def process_text_prompt(message: Message, state: FSMContext):\n    \"\"\"Process text-to-video prompt\"\"\"\n    if not message.text:\n        await message.answer(\"‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–µ–æ.\")\n        return\n    \n    await state.clear()\n    \n    # Check user credits again\n    user = await db.get_user(message.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await message.answer(\n            f\"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤! –ù—É–∂–Ω–æ {config.VIDEO_GENERATION_COST} –∫—Ä–µ–¥–∏—Ç–æ–≤.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        return\n    \n    # Generate unique task ID\n    task_id = f\"veo_{uuid.uuid4().hex[:12]}\"\n    \n    # Deduct credits\n    new_credits = user.credits - config.VIDEO_GENERATION_COST\n    await db.update_user_credits(message.from_user.id, new_credits)\n    \n    # Create transaction record\n    transaction = Transaction(\n        user_id=message.from_user.id,\n        type=TransactionType.CREDIT_SPEND,\n        amount=-config.VIDEO_GENERATION_COST,\n        description=f\"Video generation: {message.text[:50]}...\"\n    )\n    await db.create_transaction(transaction)\n    \n    # Create video generation record\n    generation = VideoGeneration(\n        user_id=message.from_user.id,\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.TEXT_TO_VIDEO,\n        model=config.DEFAULT_MODEL,\n        aspect_ratio=config.DEFAULT_ASPECT_RATIO,\n        credits_spent=config.VIDEO_GENERATION_COST\n    )\n    await db.create_video_generation(generation)\n    \n    # Start video generation\n    processing_msg = await message.answer(\n        f\"üé¨ <b>–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤–∞—à–µ –≤–∏–¥–µ–æ...</b>\\n\\n\"\n        f\"üìù –ü—Ä–æ–º–ø—Ç: {message.text[:100]}{'...' if len(message.text) > 100 else ''}\\n\"\n        f\"üí∞ –°–ø–∏—Å–∞–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤: {config.VIDEO_GENERATION_COST}\\n\"\n        f\"üí≥ –û—Å—Ç–∞—Ç–æ–∫: {new_credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\\n\\n\"\n        f\"‚è≥ –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–π–º–µ—Ç 1-5 –º–∏–Ω—É—Ç. –ú—ã —É–≤–µ–¥–æ–º–∏–º –≤–∞—Å –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏!\",\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    \n    # Call Veo API\n    veo_api = VeoAPI()\n    success = await veo_api.generate_video(\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.TEXT_TO_VIDEO,\n        user_id=message.from_user.id\n    )\n    \n    if not success:\n        # Refund credits on failure\n        await db.update_user_credits(message.from_user.id, user.credits)\n        refund_transaction = Transaction(\n            user_id=message.from_user.id,\n            type=TransactionType.ADMIN_GRANT,\n            amount=config.VIDEO_GENERATION_COST,\n            description=\"Refund for failed generation\"\n        )\n        await db.create_transaction(refund_transaction)\n        \n        await message.answer(\n            \"‚ùå <b>–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ</b>\\n\\n\"\n            \"–ö—Ä–µ–¥–∏—Ç—ã –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –Ω–∞ –≤–∞—à —Å—á–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n\n@router.message(GenerationStates.waiting_image)\nasync def process_image_upload(message: Message, state: FSMContext):\n    \"\"\"Process image for image-to-video generation\"\"\"\n    logger.info(f\"Processing image upload from user {message.from_user.id}\")\n    \n    if not message.photo:\n        logger.warning(f\"No photo in message from user {message.from_user.id}\")\n        await message.answer(\"‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\")\n        return\n    \n    # Get the largest photo size\n    photo = message.photo[-1]\n    \n    # Store image file_id in state\n    await state.update_data(image_file_id=photo.file_id)\n    \n    await message.answer(\n        \"üìù <b>–û—Ç–ª–∏—á–Ω–æ! –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ.</b>\\n\\n\"\n        \"–¢–µ–ø–µ—Ä—å –æ–ø–∏—à–∏—Ç–µ, –∫–∞–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –æ–∂–∏—Ç—å:\\n\"\n        \"‚Ä¢ –ö–∞–∫–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å?\\n\"\n        \"‚Ä¢ –ö–∞–∫–∏–µ —á–∞—Å—Ç–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –¥–≤–∏–≥–∞—Ç—å—Å—è?\\n\"\n        \"‚Ä¢ –ö–∞–∫–∞—è –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å?\\n\\n\"\n        \"–ù–∞–ø–∏—à–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ:\",\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    await state.set_state(GenerationStates.waiting_image_prompt)\n\n@router.message(GenerationStates.waiting_image_prompt)\nasync def process_image_prompt(message: Message, state: FSMContext):\n    \"\"\"Process prompt for image-to-video generation\"\"\"\n    logger.info(f\"Processing image prompt from user {message.from_user.id}: {message.text[:50] if message.text else 'No text'}\")\n    \n    if not message.text:\n        await message.answer(\"‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ.\")\n        return\n    \n    state_data = await state.get_data()\n    image_file_id = state_data.get('image_file_id')\n    \n    if not image_file_id:\n        await message.answer(\"‚ùå –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ. –ù–∞—á–Ω–∏—Ç–µ —Å–Ω–∞—á–∞–ª–∞.\")\n        await state.clear()\n        return\n    \n    await state.clear()\n    \n    # Check user credits\n    user = await db.get_user(message.from_user.id)\n    if not user or user.credits < config.VIDEO_GENERATION_COST:\n        await message.answer(\n            f\"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤! –ù—É–∂–Ω–æ {config.VIDEO_GENERATION_COST} –∫—Ä–µ–¥–∏—Ç–æ–≤.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n        return\n    \n    # Generate unique task ID\n    task_id = f\"veo_{uuid.uuid4().hex[:12]}\"\n    \n    # Deduct credits\n    new_credits = user.credits - config.VIDEO_GENERATION_COST\n    await db.update_user_credits(message.from_user.id, new_credits)\n    \n    # Create transaction record\n    transaction = Transaction(\n        user_id=message.from_user.id,\n        type=TransactionType.CREDIT_SPEND,\n        amount=-config.VIDEO_GENERATION_COST,\n        description=f\"Image-to-video generation: {message.text[:50]}...\"\n    )\n    await db.create_transaction(transaction)\n    \n    # For image-to-video, we need to get the actual image URL\n    # In a real implementation, you would upload the image to a public URL\n    # For now, we'll use the file_id (this needs to be converted to a public URL)\n    image_url = f\"telegram_file:{image_file_id}\"  # Placeholder\n    \n    # Create video generation record\n    generation = VideoGeneration(\n        user_id=message.from_user.id,\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.IMAGE_TO_VIDEO,\n        image_url=image_url,\n        model=config.DEFAULT_MODEL,\n        aspect_ratio=config.DEFAULT_ASPECT_RATIO,\n        credits_spent=config.VIDEO_GENERATION_COST\n    )\n    await db.create_video_generation(generation)\n    \n    await message.answer(\n        f\"üñº <b>–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤–∏–¥–µ–æ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...</b>\\n\\n\"\n        f\"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {message.text[:100]}{'...' if len(message.text) > 100 else ''}\\n\"\n        f\"üí∞ –°–ø–∏—Å–∞–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤: {config.VIDEO_GENERATION_COST}\\n\"\n        f\"üí≥ –û—Å—Ç–∞—Ç–æ–∫: {new_credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\\n\\n\"\n        f\"‚è≥ –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–π–º–µ—Ç 1-5 –º–∏–Ω—É—Ç. –ú—ã —É–≤–µ–¥–æ–º–∏–º –≤–∞—Å –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏!\",\n        reply_markup=get_back_to_menu_keyboard()\n    )\n    \n    # Call Veo API for image-to-video\n    veo_api = VeoAPI()\n    success = await veo_api.generate_video(\n        task_id=task_id,\n        prompt=message.text,\n        generation_type=GenerationType.IMAGE_TO_VIDEO,\n        image_file_id=image_file_id,\n        user_id=message.from_user.id\n    )\n    \n    if not success:\n        # Refund credits on failure\n        await db.update_user_credits(message.from_user.id, user.credits)\n        refund_transaction = Transaction(\n            user_id=message.from_user.id,\n            type=TransactionType.ADMIN_GRANT,\n            amount=config.VIDEO_GENERATION_COST,\n            description=\"Refund for failed generation\"\n        )\n        await db.create_transaction(refund_transaction)\n        \n        await message.answer(\n            \"‚ùå <b>–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ</b>\\n\\n\"\n            \"–ö—Ä–µ–¥–∏—Ç—ã –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –Ω–∞ –≤–∞—à —Å—á–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n","size_bytes":13416},"handlers/payments.py":{"content":"from aiogram import Router, F\nfrom aiogram.types import CallbackQuery, Message, PreCheckoutQuery, SuccessfulPayment\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom database.database import db\nfrom database.models import Transaction, TransactionType, PaymentMethod\nfrom keyboards.inline import get_payment_menu_keyboard, get_back_to_menu_keyboard, get_credit_packages_keyboard\nfrom api_integrations.payment_api import PaymentAPI\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nrouter = Router()\nconfig = Config()\n\nclass PaymentStates(StatesGroup):\n    waiting_custom_amount = State()\n\n# Credit packages - –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Ü–µ–Ω—ã\nCREDIT_PACKAGES = {\n    \"package_1\": {\"credits\": 10, \"price_stars\": 79, \"price_rub\": 79, \"title\": \"1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ (10 –∫—Ä–µ–¥–∏—Ç–æ–≤)\"},\n    \"package_5\": {\"credits\": 50, \"price_stars\": 399, \"price_rub\": 399, \"title\": \"5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤–∏–¥–µ–æ (50 –∫—Ä–µ–¥–∏—Ç–æ–≤)\"},\n    \"package_10\": {\"credits\": 100, \"price_stars\": 749, \"price_rub\": 749, \"title\": \"10 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤–∏–¥–µ–æ (100 –∫—Ä–µ–¥–∏—Ç–æ–≤)\", \"popular\": True},\n    \"package_50\": {\"credits\": 500, \"price_stars\": 3499, \"price_rub\": 3499, \"title\": \"50 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –≤–∏–¥–µ–æ (500 –∫—Ä–µ–¥–∏—Ç–æ–≤)\", \"bonus\": 50},\n}\n\n@router.callback_query(F.data == \"buy_credits\")\nasync def buy_credits_menu(callback: CallbackQuery):\n    \"\"\"Show credits purchase menu\"\"\"\n    user = await db.get_user(callback.from_user.id)\n    credits = user.credits if user else 0\n    \n    text = f\"\"\"\nüí∞ <b>–ü–æ–∫—É–ø–∫–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤</b>\n\nüí≥ <b>–í–∞—à —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:\n\n‚≠êÔ∏è <b>Telegram Stars</b> - –±—ã—Å—Ç—Ä–æ –∏ —É–¥–æ–±–Ω–æ\nüí≥ <b>–ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞/–°–ë–ü</b> - —á–µ—Ä–µ–∑ –Æ–ö–∞—Å—Å–∞\n\nüí° <b>1 –∫—Ä–µ–¥–∏—Ç –æ—Ç 7‚ÇΩ</b> (–≤ –±–æ–ª—å—à–æ–º –ø–∞–∫–µ—Ç–µ)\nüé¨ <b>1 –≤–∏–¥–µ–æ = 10 –∫—Ä–µ–¥–∏—Ç–æ–≤ (–æ—Ç 70‚ÇΩ)</b>\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_payment_menu_keyboard()\n        )\n    await callback.answer()\n\n@router.callback_query(F.data == \"pay_stars\")\nasync def pay_with_stars(callback: CallbackQuery):\n    \"\"\"Show Telegram Stars payment options\"\"\"\n    text = \"\"\"\n‚≠êÔ∏è <b>–û–ø–ª–∞—Ç–∞ Telegram Stars</b>\n\nüé¨ <b>1 –≤–∏–¥–µ–æ = 10 –∫—Ä–µ–¥–∏—Ç–æ–≤</b>\nüí∞ <b>–í—ã–≥–æ–¥–Ω—ã–µ —Ü–µ–Ω—ã:</b>\n‚Ä¢ 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è - 79‚≠êÔ∏è (7.9‚≠êÔ∏è –∑–∞ –∫—Ä–µ–¥–∏—Ç)\n‚Ä¢ 5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 399‚≠êÔ∏è (7.98‚≠êÔ∏è –∑–∞ –∫—Ä–µ–¥–∏—Ç) üî•\n‚Ä¢ 10 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 749‚≠êÔ∏è (7.49‚≠êÔ∏è –∑–∞ –∫—Ä–µ–¥–∏—Ç) \n‚Ä¢ 50 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 3499‚≠êÔ∏è (7‚≠êÔ∏è –∑–∞ –∫—Ä–µ–¥–∏—Ç) + üéÅ –±–æ–Ω—É—Å!\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç –∫—Ä–µ–¥–∏—Ç–æ–≤:\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_credit_packages_keyboard(\"stars\")\n        )\n    await callback.answer()\n\n@router.callback_query(F.data == \"pay_card\")\nasync def pay_with_card(callback: CallbackQuery):\n    \"\"\"Show card payment options\"\"\"\n    text = \"\"\"\nüí≥ <b>–û–ø–ª–∞—Ç–∞ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç–æ–π</b>\n\nüé¨ <b>1 –≤–∏–¥–µ–æ = 10 –∫—Ä–µ–¥–∏—Ç–æ–≤</b>\nüí∞ <b>–í—ã–≥–æ–¥–Ω—ã–µ —Ü–µ–Ω—ã:</b>\n‚Ä¢ 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è - 79‚ÇΩ (7.9‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç)\n‚Ä¢ 5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 399‚ÇΩ (7.98‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç) üî• \n‚Ä¢ 10 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 749‚ÇΩ (7.49‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç)\n‚Ä¢ 50 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 3499‚ÇΩ (7‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç) + üéÅ –±–æ–Ω—É—Å!\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç –∫—Ä–µ–¥–∏—Ç–æ–≤:\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_credit_packages_keyboard(\"card\")\n        )\n    await callback.answer()\n\n@router.callback_query(F.data == \"pay_sbp\")\nasync def pay_with_sbp(callback: CallbackQuery):\n    \"\"\"Show SBP payment options\"\"\"\n    text = \"\"\"\nüè¶ <b>–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –°–ë–ü</b>\n\n<b>–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π</b> - –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã 24/7\n\nüé¨ <b>1 –≤–∏–¥–µ–æ = 10 –∫—Ä–µ–¥–∏—Ç–æ–≤</b>\nüí∞ <b>–í—ã–≥–æ–¥–Ω—ã–µ —Ü–µ–Ω—ã:</b>\n‚Ä¢ 1 –≥–µ–Ω–µ—Ä–∞—Ü–∏—è - 79‚ÇΩ (7.9‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç)\n‚Ä¢ 5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 399‚ÇΩ (7.98‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç) üî•\n‚Ä¢ 10 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 749‚ÇΩ (7.49‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç)\n‚Ä¢ 50 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π - 3499‚ÇΩ (7‚ÇΩ –∑–∞ –∫—Ä–µ–¥–∏—Ç) + üéÅ –±–æ–Ω—É—Å!\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç –∫—Ä–µ–¥–∏—Ç–æ–≤:\n    \"\"\"\n    \n    if callback.message:\n        await callback.message.edit_text(\n            text,\n            parse_mode=\"HTML\",\n            reply_markup=get_credit_packages_keyboard(\"sbp\")\n        )\n    await callback.answer()\n\n@router.callback_query(F.data.startswith(\"buy_stars_\"))\nasync def process_stars_payment(callback: CallbackQuery):\n    \"\"\"Process Telegram Stars payment\"\"\"\n    package_id = callback.data.replace(\"buy_stars_\", \"\")\n    package = CREDIT_PACKAGES.get(package_id)\n    \n    if not package:\n        await callback.answer(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞–∫–µ—Ç\")\n        return\n    \n    # Create invoice for Telegram Stars\n    title = f\"üí∞ {package['title']}\"\n    description = f\"–ü–æ–∫—É–ø–∫–∞ {package['credits']} –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ AI –≤–∏–¥–µ–æ\"\n    \n    if package.get('bonus'):\n        description += f\" + {package['bonus']} –±–æ–Ω—É—Å–Ω—ã—Ö –∫—Ä–µ–¥–∏—Ç–æ–≤!\"\n    \n    prices = [{\"label\": \"XTR\", \"amount\": package['price_stars']}]\n    \n    try:\n        if callback.message:\n            await callback.message.answer_invoice(\n                title=title,\n                description=description,\n                payload=f\"credits_{package_id}_{callback.from_user.id}\",\n                provider_token=\"\",  # Empty for Telegram Stars\n                currency=\"XTR\",\n                prices=[{\"label\": \"XTR\", \"amount\": package['price_stars']}]\n            )\n        await callback.answer(\"‚úÖ –°—á–µ—Ç —Å–æ–∑–¥–∞–Ω!\")\n    except Exception as e:\n        logger.error(f\"Error creating Stars invoice: {e}\")\n        await callback.answer(\"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—á–µ—Ç–∞\")\n\n@router.callback_query(F.data.startswith(\"buy_card_\"))\nasync def process_card_payment(callback: CallbackQuery):\n    \"\"\"Process card/SBP payment through YooKassa\"\"\"\n    package_id = callback.data.replace(\"buy_card_\", \"\")\n    package = CREDIT_PACKAGES.get(package_id)\n    \n    if not package:\n        await callback.answer(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞–∫–µ—Ç\")\n        return\n    \n    # Create payment through YooKassa\n    payment_api = PaymentAPI()\n    \n    description = f\"–ü–æ–∫—É–ø–∫–∞ {package['credits']} –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n    if package.get('bonus'):\n        description += f\" + {package['bonus']} –±–æ–Ω—É—Å–Ω—ã—Ö –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n    \n    payment_url = await payment_api.create_yookassa_payment(\n        amount=package['price_rub'],\n        description=description,\n        user_id=callback.from_user.id,\n        package_id=package_id,\n        payment_method=\"bank_card\"\n    )\n    \n    if payment_url:\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üí≥ –û–ø–ª–∞—Ç–∏—Ç—å\", url=payment_url)],\n            [InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥\", callback_data=\"buy_credits\")]\n        ])\n        \n        await callback.message.edit_text(\n            f\"üí≥ <b>–û–ø–ª–∞—Ç–∞ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç–æ–π</b>\\n\\n\"\n            f\"üì¶ <b>–ü–∞–∫–µ—Ç:</b> {package['title']}\\n\"\n            f\"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {package['price_rub']} ‚ÇΩ\\n\\n\"\n            f\"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –æ–ø–ª–∞—Ç–µ:\",\n            parse_mode=\"HTML\",\n            reply_markup=keyboard\n        )\n    else:\n        await callback.message.edit_text(\n            \"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n    \n    await callback.answer()\n\n@router.callback_query(F.data.startswith(\"buy_sbp_\"))\nasync def process_sbp_payment(callback: CallbackQuery):\n    \"\"\"Process SBP payment through YooKassa\"\"\"\n    package_id = callback.data.replace(\"buy_sbp_\", \"\")\n    package = CREDIT_PACKAGES.get(package_id)\n    \n    if not package:\n        await callback.answer(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞–∫–µ—Ç\")\n        return\n    \n    # Create payment through YooKassa with SBP method\n    payment_api = PaymentAPI()\n    \n    description = f\"–ü–æ–∫—É–ø–∫–∞ {package['credits']} –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n    if package.get('bonus'):\n        description += f\" + {package['bonus']} –±–æ–Ω—É—Å–Ω—ã—Ö –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n    \n    payment_url = await payment_api.create_yookassa_payment(\n        amount=package['price_rub'],\n        description=description,\n        user_id=callback.from_user.id,\n        package_id=package_id,\n        payment_method=\"sbp\"\n    )\n    \n    if payment_url:\n        from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n        keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üè¶ –û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ –°–ë–ü\", url=payment_url)],\n            [InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥\", callback_data=\"buy_credits\")]\n        ])\n        \n        await callback.message.edit_text(\n            f\"üè¶ <b>–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ –°–ë–ü</b>\\n\\n\"\n            f\"üì¶ <b>–ü–∞–∫–µ—Ç:</b> {package['title']}\\n\"\n            f\"üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {package['price_rub']} ‚ÇΩ\\n\\n\"\n            f\"<b>–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π</b> - –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–≤–æ–¥—ã 24/7\\n\"\n            f\"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –æ–ø–ª–∞—Ç–µ:\",\n            parse_mode=\"HTML\",\n            reply_markup=keyboard\n        )\n    else:\n        await callback.message.edit_text(\n            \"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\",\n            reply_markup=get_back_to_menu_keyboard()\n        )\n    \n    await callback.answer()\n\n@router.pre_checkout_query()\nasync def process_pre_checkout_query(pre_checkout_query: PreCheckoutQuery):\n    \"\"\"Process pre-checkout query for Telegram Stars\"\"\"\n    await pre_checkout_query.answer(ok=True)\n\n@router.message(F.successful_payment)\nasync def process_successful_payment(message: Message):\n    \"\"\"Process successful Telegram Stars payment with enhanced validation\"\"\"\n    payment = message.successful_payment\n    \n    # SECURITY: Validate that payment is from the actual user who initiated it\n    actual_user_id = message.from_user.id\n    \n    # Parse and validate payload format\n    try:\n        payload_parts = payment.invoice_payload.split('_')\n        if len(payload_parts) < 3 or payload_parts[0] != \"credits\":\n            logger.error(f\"Invalid payment payload format: {payment.invoice_payload}\")\n            return\n        \n        package_id = payload_parts[1]\n        claimed_user_id = int(payload_parts[2])\n        \n        # SECURITY: Ensure user_id in payload matches actual payment sender\n        if claimed_user_id != actual_user_id:\n            logger.error(f\"Payment fraud attempt: payload claims user {claimed_user_id} but payment from {actual_user_id}\")\n            return\n        \n    except (ValueError, IndexError) as e:\n        logger.error(f\"Error parsing payment payload: {e}\")\n        return\n    \n    user_id = actual_user_id  # Use verified user ID\n    \n    # Validate package exists and payment amount matches\n    package = CREDIT_PACKAGES.get(package_id)\n    if not package:\n        logger.error(f\"Invalid package_id in payment: {package_id}\")\n        return\n    \n    # SECURITY: Verify payment amount matches expected package price\n    expected_amount = package['price_stars']\n    actual_amount = payment.total_amount\n    \n    if actual_amount != expected_amount:\n        logger.error(f\"Payment amount mismatch: expected {expected_amount} XTR, got {actual_amount} XTR\")\n        return\n    \n    # Check for duplicate payment processing\n    payment_id = payment.telegram_payment_charge_id\n    if await db.payment_exists(payment_id):\n        logger.warning(f\"Duplicate Telegram Stars payment detected: {payment_id}\")\n        return\n    \n    # Process the validated payment\n    # Calculate total credits (including bonus)\n    total_credits = package['credits']\n    if package.get('bonus'):\n        total_credits += package['bonus']\n    \n    # Update user credits\n    user = await db.get_user(user_id)\n    if user:\n        new_credits = user.credits + total_credits\n        await db.update_user_credits(user_id, new_credits)\n        \n        # Create transaction record\n        transaction = Transaction(\n            user_id=user_id,\n            type=TransactionType.CREDIT_PURCHASE,\n            amount=total_credits,\n            description=f\"Purchase via Telegram Stars: {package['title']}\",\n            payment_method=PaymentMethod.TELEGRAM_STARS,\n            payment_id=payment.telegram_payment_charge_id\n        )\n        await db.create_transaction(transaction)\n        \n        success_text = f\"\"\"\n‚úÖ <b>–ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω!</b>\n\nüí∞ <b>–î–æ–±–∞–≤–ª–µ–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤:</b> {total_credits}\nüí≥ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {new_credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ! üé¨\n        \"\"\"\n        \n        from keyboards.inline import get_main_menu_keyboard\n        await message.answer(\n            success_text,\n            parse_mode=\"HTML\",\n            reply_markup=get_main_menu_keyboard()\n        )\n        \n        logger.info(f\"Stars payment completed: user {user_id}, credits {total_credits}\")\n    else:\n        logger.error(f\"User {user_id} not found for payment processing\")\n\n# Webhook handler for YooKassa payments would be implemented here\n# This requires a separate web server endpoint\n","size_bytes":14022},"handlers/start.py":{"content":"from aiogram import Router, F\nfrom aiogram.filters import CommandStart\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\n\nfrom database.database import db\nfrom database.models import User, UserStatus\nfrom keyboards.inline import get_main_menu_keyboard\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nrouter = Router()\n\n@router.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext):\n    \"\"\"Handle /start command\"\"\"\n    try:\n        user_id = message.from_user.id\n        \n        # Get or create user\n        user = await db.get_user(user_id)\n        if not user:\n            user = User(\n                telegram_id=user_id,\n                username=message.from_user.username,\n                first_name=message.from_user.first_name,\n                last_name=message.from_user.last_name\n            )\n            await db.create_user(user)\n            logger.info(f\"New user created: {user_id}\")\n        \n        # Clear any existing state\n        await state.clear()\n        \n        # Check if this is a return from payment\n        start_param = message.text.split(' ', 1)[1] if ' ' in message.text else None\n        if start_param == \"payment_success\":\n            welcome_text = f\"\"\"\n‚úÖ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ!</b>\n\n–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! üëã\n\nüí∞ <b>–í–∞—à —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {user.credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\n–ï—Å–ª–∏ –≤—ã —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–æ–≤–µ—Ä—à–∏–ª–∏ –æ–ø–ª–∞—Ç—É, –∫—Ä–µ–¥–∏—Ç—ã –±—É–¥—É—Ç –∑–∞—á–∏—Å–ª–µ–Ω—ã –≤ —Ç–µ—á–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–∏–Ω—É—Ç.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:\n            \"\"\"\n        else:\n            # Regular welcome message\n            welcome_text = f\"\"\"\nüé¨ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ AI Video Generator!</b>\n\n–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! üëã\n\n–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–∂–µ—Ç –≤–∞–º —Å–æ–∑–¥–∞–≤–∞—Ç—å –ø–æ—Ç—Ä—è—Å–∞—é—â–∏–µ –≤–∏–¥–µ–æ —Å –ø–æ–º–æ—â—å—é –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞ Veo 3.\n\nüí∞ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {user.credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:\n            \"\"\"\n        \n        await message.answer(\n            welcome_text,\n            parse_mode=\"HTML\",\n            reply_markup=get_main_menu_keyboard()\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error in start command: {e}\")\n        await message.answer(\n            \"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.\",\n            reply_markup=get_main_menu_keyboard()\n        )\n\n@router.callback_query(F.data == \"main_menu\")\nasync def back_to_main_menu(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Handle back to main menu\"\"\"\n    await state.clear()\n    \n    user = await db.get_user(callback.from_user.id)\n    credits = user.credits if user else 0\n    \n    welcome_text = f\"\"\"\nüé¨ <b>AI Video Generator</b>\n\nüí∞ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:\n    \"\"\"\n    \n    await callback.message.edit_text(\n        welcome_text,\n        parse_mode=\"HTML\",\n        reply_markup=get_main_menu_keyboard()\n    )\n    await callback.answer()\n\n@router.callback_query(F.data == \"help\")\nasync def help_command(callback: CallbackQuery):\n    \"\"\"Handle help callback\"\"\"\n    help_text = \"\"\"\nüìñ –ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞\n\n–í–∞–∂–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –ø–æ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—é –∑–∞–ø—Ä–æ—Å–æ–≤:\nhttps://t.me/CatiAiPromt/51\n\n–ü—Ä–∏–º–µ—Ä—ã —Ö–æ—Ä–æ—à–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –∑–¥–µ—Å—å:\nhttps://t.me/CatiAiPromt\n\n–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:\n\nüé• –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ:\n‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (–∏–∑ —Ç–µ–∫—Å—Ç–∞ –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)\n‚Ä¢ –û–ø–∏—à–∏—Ç–µ –¥–µ—Ç–∞–ª—å–Ω–æ, —á—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤–∏–¥–µ—Ç—å –≤ –≤–∏–¥–µ–æ\n‚Ä¢ –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ (1-5 –º–∏–Ω—É—Ç)\n\nüí∞ –ö—Ä–µ–¥–∏—Ç—ã:\n‚Ä¢ 1 –≤–∏–¥–µ–æ = 10 –∫—Ä–µ–¥–∏—Ç–æ–≤ (79‚ÇΩ)\n‚Ä¢ –ü–æ–∫—É–ø–∞–π—Ç–µ –∫—Ä–µ–¥–∏—Ç—ã —á–µ—Ä–µ–∑ Telegram Stars –∏–ª–∏ –±–∞–Ω–∫–æ–≤—Å–∫—É—é –∫–∞—Ä—Ç—É\n‚Ä¢ –ò–∑–±–µ–≥–∞–π—Ç–µ —Å–ª–æ–∂–Ω—ã—Ö —Å—Ü–µ–Ω —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –æ–±—ä–µ–∫—Ç–æ–≤\n    \"\"\"\n    \n    from keyboards.inline import get_back_to_menu_keyboard\n    await callback.message.edit_text(\n        help_text,\n        parse_mode=\"HTML\",\n        reply_markup=get_back_to_menu_keyboard(),\n        disable_web_page_preview=True\n    )\n    await callback.answer()\n","size_bytes":4608},"keyboards/inline.py":{"content":"from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\ndef get_main_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Main menu inline keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"üé¨ –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ\", callback_data=\"generate_video\")],\n        [InlineKeyboardButton(text=\"üí∞ –ö—É–ø–∏—Ç—å –∫—Ä–µ–¥–∏—Ç—ã\", callback_data=\"buy_credits\")],\n        [InlineKeyboardButton(text=\"üìñ –ü–æ–º–æ—â—å\", callback_data=\"help\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_generation_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Video generation menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"üìù –í–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞\", callback_data=\"text_to_video\")],\n        [InlineKeyboardButton(text=\"üñº –í–∏–¥–µ–æ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\", callback_data=\"image_to_video\")],\n        [InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_payment_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Payment method selection keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"‚≠êÔ∏è Telegram Stars\", callback_data=\"pay_stars\")],\n        [InlineKeyboardButton(text=\"üí≥ –ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞\", callback_data=\"pay_card\")],\n        [InlineKeyboardButton(text=\"üè¶ –°–ë–ü (–°–∏—Å—Ç–µ–º–∞ –±—ã—Å—Ç—Ä—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π)\", callback_data=\"pay_sbp\")],\n        [InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_credit_packages_keyboard(payment_method: str) -> InlineKeyboardMarkup:\n    \"\"\"Credit packages keyboard\"\"\"\n    # Import here to avoid circular import\n    from handlers.payments import CREDIT_PACKAGES\n    \n    keyboard = []\n    \n    for package_id, package in CREDIT_PACKAGES.items():\n        # Format package button text\n        text = f\"üíé {package['title']}\"\n        \n        if payment_method == \"stars\":\n            text += f\" - {package['price_stars']} ‚≠êÔ∏è\"\n        else:\n            text += f\" - {package['price_rub']} ‚ÇΩ\"\n        \n        # Add bonus indicator\n        if package.get('bonus'):\n            text += f\" (+{package['bonus']} –±–æ–Ω—É—Å!)\"\n        \n        # Add popular indicator\n        if package.get('popular'):\n            text = \"üî• \" + text\n        \n        callback_data = f\"buy_{payment_method}_{package_id}\"\n        keyboard.append([InlineKeyboardButton(text=text, callback_data=callback_data)])\n    \n    # Back button\n    keyboard.append([InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥\", callback_data=\"buy_credits\")])\n    \n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_back_to_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Simple back to main menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_admin_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Admin menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\", callback_data=\"admin_stats\")],\n        [InlineKeyboardButton(text=\"üí∞ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫—Ä–µ–¥–∏—Ç—ã\", callback_data=\"admin_check_credits\"),\n         InlineKeyboardButton(text=\"üíé –í—ã–¥–∞—Ç—å –∫—Ä–µ–¥–∏—Ç—ã\", callback_data=\"admin_grant_credits\")],\n        [InlineKeyboardButton(text=\"üì¢ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π\", callback_data=\"admin_broadcast\")],\n        [InlineKeyboardButton(text=\"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–∞\", callback_data=\"admin_check_payment\")],\n        [InlineKeyboardButton(text=\"üì® –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ\", callback_data=\"admin_send_notification\")],\n        [InlineKeyboardButton(text=\"üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\", callback_data=\"main_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_back_to_admin_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Back to admin menu keyboard\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"üîô –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\", callback_data=\"admin_menu\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_video_result_keyboard(video_url: str = None) -> InlineKeyboardMarkup:\n    \"\"\"Keyboard for video generation result\"\"\"\n    keyboard = []\n    \n    if video_url:\n        keyboard.append([InlineKeyboardButton(text=\"üì• –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ\", url=video_url)])\n    \n    keyboard.extend([\n        [InlineKeyboardButton(text=\"üé¨ –°–æ–∑–¥–∞—Ç—å –µ—â–µ –≤–∏–¥–µ–æ\", callback_data=\"generate_video\")],\n        [InlineKeyboardButton(text=\"üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\", callback_data=\"main_menu\")]\n    ])\n    \n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef get_confirm_payment_keyboard(payment_url: str) -> InlineKeyboardMarkup:\n    \"\"\"Keyboard with payment confirmation button\"\"\"\n    keyboard = [\n        [InlineKeyboardButton(text=\"üí≥ –û–ø–ª–∞—Ç–∏—Ç—å\", url=payment_url)],\n        [InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥\", callback_data=\"buy_credits\")]\n    ]\n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n","size_bytes":5213},"middlewares/rate_limit.py":{"content":"from aiogram import BaseMiddleware\nfrom aiogram.types import Message, CallbackQuery, TelegramObject\nfrom typing import Callable, Dict, Any, Awaitable, Union\nimport time\nimport asyncio\n\nfrom utils.rate_limiter import rate_limiter\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass RateLimitMiddleware(BaseMiddleware):\n    \"\"\"Rate limiting middleware for aiogram\"\"\"\n    \n    def __init__(self):\n        self.rate_limiter = rate_limiter\n    \n    async def __call__(\n        self,\n        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],\n        event: TelegramObject,\n        data: Dict[str, Any]\n    ) -> Any:\n        \n        # Get user ID from different event types\n        user_id = None\n        if isinstance(event, Message):\n            user_id = event.from_user.id if event.from_user else None\n            # Skip rate limiting for users in generation states (uploading images/prompts)\n            if hasattr(data.get('state'), 'get_state'):\n                try:\n                    current_state = await data['state'].get_state()\n                    if current_state and ('waiting_image' in current_state or 'waiting_text_prompt' in current_state):\n                        return await handler(event, data)\n                except:\n                    pass  # Continue with normal rate limiting if state check fails\n        elif isinstance(event, CallbackQuery):\n            user_id = event.from_user.id if event.from_user else None\n            # Skip rate limiting for navigation callback queries\n            navigation_callbacks = [\n                \"main_menu\", \"buy_credits\", \"pay_stars\", \"pay_card\", \n                \"generate_video\", \"text_to_video\", \"image_to_video\",\n                \"admin_panel\", \"user_stats\", \"broadcast_menu\", \"back_to_menu\"\n            ]\n            if event.data in navigation_callbacks:\n                return await handler(event, data)\n        \n        # Skip rate limiting if no user ID found\n        if not user_id:\n            return await handler(event, data)\n        \n        # Check rate limit\n        if not self.rate_limiter.is_allowed(user_id):\n            reset_time = self.rate_limiter.get_reset_time(user_id)\n            current_time = time.time()\n            \n            if reset_time > current_time:\n                wait_seconds = int(reset_time - current_time) + 1\n                \n                rate_limit_message = (\n                    f\"üö´ <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤!</b>\\n\\n\"\n                    f\"‚è± –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ {wait_seconds} —Å–µ–∫—É–Ω–¥.\\n\\n\"\n                    f\"üí° –≠—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ —Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.\"\n                )\n                \n                if isinstance(event, Message):\n                    await event.answer(rate_limit_message)\n                elif isinstance(event, CallbackQuery):\n                    await event.answer(\n                        f\"–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç! –ñ–¥–∏—Ç–µ {wait_seconds} —Å–µ–∫.\",\n                        show_alert=True\n                    )\n                \n                logger.warning(f\"Rate limit exceeded for user {user_id}\")\n                return  # Don't proceed to handler\n        \n        # Proceed to handler if rate limit not exceeded\n        return await handler(event, data)\n","size_bytes":3416},"utils/helpers.py":{"content":"import re\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Optional, List, Dict, Any\nimport hashlib\nimport uuid\n\ndef validate_prompt(prompt: str) -> tuple[bool, str]:\n    \"\"\"Validate video generation prompt\"\"\"\n    if not prompt or not prompt.strip():\n        return False, \"–ü—Ä–æ–º–ø—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º\"\n    \n    prompt = prompt.strip()\n    \n    if len(prompt) < 10:\n        return False, \"–ü—Ä–æ–º–ø—Ç —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ú–∏–Ω–∏–º—É–º 10 —Å–∏–º–≤–æ–ª–æ–≤.\"\n    \n    if len(prompt) > 1000:\n        return False, \"–ü—Ä–æ–º–ø—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π. –ú–∞–∫—Å–∏–º—É–º 1000 —Å–∏–º–≤–æ–ª–æ–≤.\"\n    \n    # Check for potentially harmful content\n    forbidden_keywords = [\n        \"nsfw\", \"nude\", \"naked\", \"sexual\", \"porn\", \"xxx\",\n        \"violence\", \"kill\", \"death\", \"suicide\", \"harm\",\n        \"drugs\", \"illegal\", \"weapon\", \"bomb\", \"terror\"\n    ]\n    \n    prompt_lower = prompt.lower()\n    for keyword in forbidden_keywords:\n        if keyword in prompt_lower:\n            return False, \"–ü—Ä–æ–º–ø—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç\"\n    \n    return True, \"OK\"\n\ndef format_duration(seconds: int) -> str:\n    \"\"\"Format duration in human-readable format\"\"\"\n    if seconds < 60:\n        return f\"{seconds}—Å\"\n    elif seconds < 3600:\n        minutes = seconds // 60\n        remaining_seconds = seconds % 60\n        if remaining_seconds == 0:\n            return f\"{minutes}–º\"\n        return f\"{minutes}–º {remaining_seconds}—Å\"\n    else:\n        hours = seconds // 3600\n        remaining_minutes = (seconds % 3600) // 60\n        if remaining_minutes == 0:\n            return f\"{hours}—á\"\n        return f\"{hours}—á {remaining_minutes}–º\"\n\ndef format_credits(credits: int) -> str:\n    \"\"\"Format credits with proper plural form\"\"\"\n    if credits % 10 == 1 and credits % 100 != 11:\n        return f\"{credits} –∫—Ä–µ–¥–∏—Ç\"\n    elif credits % 10 in [2, 3, 4] and credits % 100 not in [12, 13, 14]:\n        return f\"{credits} –∫—Ä–µ–¥–∏—Ç–∞\"\n    else:\n        return f\"{credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n\ndef escape_html(text: str) -> str:\n    \"\"\"Escape HTML special characters\"\"\"\n    if not text:\n        return \"\"\n    \n    return (text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace('\"', \"&quot;\")\n            .replace(\"'\", \"&#x27;\"))\n\ndef truncate_text(text: str, max_length: int = 100, suffix: str = \"...\") -> str:\n    \"\"\"Truncate text to specified length\"\"\"\n    if not text:\n        return \"\"\n    \n    if len(text) <= max_length:\n        return text\n    \n    return text[:max_length - len(suffix)] + suffix\n\ndef generate_task_id(prefix: str = \"veo\") -> str:\n    \"\"\"Generate unique task ID\"\"\"\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    random_part = uuid.uuid4().hex[:8]\n    return f\"{prefix}_{timestamp}_{random_part}\"\n\ndef is_valid_url(url: str) -> bool:\n    \"\"\"Check if URL is valid\"\"\"\n    url_pattern = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url_pattern.match(url) is not None\n\ndef hash_string(text: str) -> str:\n    \"\"\"Generate SHA-256 hash of string\"\"\"\n    return hashlib.sha256(text.encode()).hexdigest()\n\ndef parse_callback_data(callback_data: str) -> Dict[str, str]:\n    \"\"\"Parse callback data into dictionary\"\"\"\n    parts = callback_data.split('_')\n    if len(parts) < 2:\n        return {\"action\": callback_data}\n    \n    result = {\"action\": parts[0]}\n    for i, part in enumerate(parts[1:], 1):\n        result[f\"param{i}\"] = part\n    \n    return result\n\ndef format_file_size(size_bytes: int) -> str:\n    \"\"\"Format file size in human-readable format\"\"\"\n    if size_bytes == 0:\n        return \"0 B\"\n    \n    size_names = [\"B\", \"KB\", \"MB\", \"GB\"]\n    i = 0\n    while size_bytes >= 1024 and i < len(size_names) - 1:\n        size_bytes /= 1024\n        i += 1\n    \n    return f\"{size_bytes:.1f} {size_names[i]}\"\n\ndef get_user_display_name(user) -> str:\n    \"\"\"Get user display name from Telegram user object\"\"\"\n    if hasattr(user, 'first_name') and user.first_name:\n        name = user.first_name\n        if hasattr(user, 'last_name') and user.last_name:\n            name += f\" {user.last_name}\"\n        return name\n    elif hasattr(user, 'username') and user.username:\n        return f\"@{user.username}\"\n    else:\n        return f\"User {user.id}\"\n\ndef is_recent_timestamp(timestamp: datetime, hours: int = 24) -> bool:\n    \"\"\"Check if timestamp is within recent hours\"\"\"\n    if not timestamp:\n        return False\n    \n    now = datetime.now()\n    time_diff = now - timestamp\n    return time_diff < timedelta(hours=hours)\n\ndef batch_list(items: List[Any], batch_size: int) -> List[List[Any]]:\n    \"\"\"Split list into batches\"\"\"\n    return [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\n\nasync def retry_async(func, max_retries: int = 3, delay: float = 1.0):\n    \"\"\"Retry async function with exponential backoff\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return await func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise e\n            \n            wait_time = delay * (2 ** attempt)  # Exponential backoff\n            await asyncio.sleep(wait_time)\n    \n    return None\n\ndef clean_filename(filename: str) -> str:\n    \"\"\"Clean filename from invalid characters\"\"\"\n    # Remove invalid characters for filenames\n    invalid_chars = '<>:\"/\\\\|?*'\n    for char in invalid_chars:\n        filename = filename.replace(char, '_')\n    \n    # Limit length\n    filename = filename[:100]\n    \n    return filename\n\ndef format_timestamp(timestamp: datetime, format_type: str = \"short\") -> str:\n    \"\"\"Format timestamp for display\"\"\"\n    if not timestamp:\n        return \"N/A\"\n    \n    now = datetime.now()\n    diff = now - timestamp\n    \n    if format_type == \"relative\":\n        if diff.days > 0:\n            return f\"{diff.days} –¥–Ω–µ–π –Ω–∞–∑–∞–¥\"\n        elif diff.seconds > 3600:\n            hours = diff.seconds // 3600\n            return f\"{hours} —á–∞—Å–æ–≤ –Ω–∞–∑–∞–¥\"\n        elif diff.seconds > 60:\n            minutes = diff.seconds // 60\n            return f\"{minutes} –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥\"\n        else:\n            return \"–¢–æ–ª—å–∫–æ —á—Ç–æ\"\n    elif format_type == \"short\":\n        return timestamp.strftime(\"%d.%m.%Y %H:%M\")\n    elif format_type == \"long\":\n        return timestamp.strftime(\"%d %B %Y, %H:%M:%S\")\n    else:\n        return timestamp.isoformat()\n\ndef extract_numbers(text: str) -> List[int]:\n    \"\"\"Extract all numbers from text\"\"\"\n    numbers = re.findall(r'\\d+', text)\n    return [int(num) for num in numbers]\n\ndef is_valid_telegram_id(user_id: str) -> bool:\n    \"\"\"Check if string is valid Telegram user ID\"\"\"\n    try:\n        user_id_int = int(user_id)\n        return 1 <= user_id_int <= 999999999999\n    except ValueError:\n        return False\n","size_bytes":7130},"utils/logger.py":{"content":"import logging\nimport sys\nfrom datetime import datetime\nfrom logging.handlers import RotatingFileHandler\nimport os\n\ndef setup_logger(name: str = \"telegram_bot\", level: str = \"INFO\") -> logging.Logger:\n    \"\"\"Setup logging configuration\"\"\"\n    \n    # Create logger\n    logger = logging.getLogger(name)\n    logger.setLevel(getattr(logging, level.upper()))\n    \n    # Prevent duplicate handlers\n    if logger.handlers:\n        logger.handlers.clear()\n    \n    # Create formatters\n    detailed_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'\n    )\n    \n    simple_formatter = logging.Formatter(\n        '%(asctime)s - %(levelname)s - %(message)s'\n    )\n    \n    # Console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging.INFO)\n    console_handler.setFormatter(simple_formatter)\n    logger.addHandler(console_handler)\n    \n    # Simplified file handler without rotation to avoid threading issues\n    try:\n        # Create logs directory if it doesn't exist\n        os.makedirs(\"logs\", exist_ok=True)\n        \n        file_handler = logging.FileHandler(\"logs/bot.log\")\n        file_handler.setLevel(logging.DEBUG)\n        file_handler.setFormatter(detailed_formatter)\n        logger.addHandler(file_handler)\n        \n    except Exception as e:\n        logger.warning(f\"Could not setup file logging: {e}\")\n    \n    return logger\n\ndef get_logger(name: str = None) -> logging.Logger:\n    \"\"\"Get logger instance\"\"\"\n    if name:\n        return logging.getLogger(f\"telegram_bot.{name}\")\n    return logging.getLogger(\"telegram_bot\")\n\ndef log_user_action(user_id: int, action: str, details: str = \"\"):\n    \"\"\"Log user actions for monitoring\"\"\"\n    logger = get_logger(\"user_actions\")\n    logger.info(f\"User {user_id}: {action} | {details}\")\n\ndef log_api_call(api_name: str, success: bool, duration: float = None, error: str = None):\n    \"\"\"Log API calls for monitoring\"\"\"\n    logger = get_logger(\"api_calls\")\n    status = \"SUCCESS\" if success else \"FAILED\"\n    duration_str = f\" | Duration: {duration:.2f}s\" if duration else \"\"\n    error_str = f\" | Error: {error}\" if error else \"\"\n    logger.info(f\"API {api_name}: {status}{duration_str}{error_str}\")\n\ndef log_payment(user_id: int, amount: int, method: str, success: bool, payment_id: str = None):\n    \"\"\"Log payment transactions\"\"\"\n    logger = get_logger(\"payments\")\n    status = \"SUCCESS\" if success else \"FAILED\"\n    payment_str = f\" | PaymentID: {payment_id}\" if payment_id else \"\"\n    logger.info(f\"Payment {status}: User {user_id} | Amount {amount} | Method {method}{payment_str}\")\n\ndef sanitize_log_data(data: str) -> str:\n    \"\"\"Sanitize sensitive data from logs\"\"\"\n    # Remove API keys, tokens, and other sensitive information\n    sensitive_patterns = [\n        r'Bearer [A-Za-z0-9\\-_]+',\n        r'token[\"\\s]*[:=][\"\\s]*[A-Za-z0-9\\-_]+',\n        r'key[\"\\s]*[:=][\"\\s]*[A-Za-z0-9\\-_]+',\n        r'password[\"\\s]*[:=][\"\\s]*\\S+',\n    ]\n    \n    sanitized = data\n    for pattern in sensitive_patterns:\n        import re\n        sanitized = re.sub(pattern, '[REDACTED]', sanitized, flags=re.IGNORECASE)\n    \n    return sanitized\n","size_bytes":3194},"utils/rate_limiter.py":{"content":"import time\nfrom typing import Dict, List\nfrom dataclasses import dataclass, field\nfrom config import Config\n\nconfig = Config()\n\n@dataclass\nclass UserLimitData:\n    \"\"\"User rate limit tracking data\"\"\"\n    requests: List[float] = field(default_factory=list)\n    blocked_until: float = 0.0\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self):\n        self.users: Dict[int, UserLimitData] = {}\n        self.max_requests = config.RATE_LIMIT_MESSAGES\n        self.time_window = config.RATE_LIMIT_WINDOW\n        self.block_duration = 300  # 5 minutes block\n    \n    def is_allowed(self, user_id: int) -> bool:\n        \"\"\"Check if user is allowed to make a request\"\"\"\n        current_time = time.time()\n        \n        # Get or create user data\n        if user_id not in self.users:\n            self.users[user_id] = UserLimitData()\n        \n        user_data = self.users[user_id]\n        \n        # Check if user is currently blocked\n        if user_data.blocked_until > current_time:\n            return False\n        \n        # Clean old requests\n        cutoff_time = current_time - self.time_window\n        user_data.requests = [req_time for req_time in user_data.requests if req_time > cutoff_time]\n        \n        # Check rate limit\n        if len(user_data.requests) >= self.max_requests:\n            # Block user\n            user_data.blocked_until = current_time + self.block_duration\n            return False\n        \n        # Record request\n        user_data.requests.append(current_time)\n        return True\n    \n    def get_reset_time(self, user_id: int) -> float:\n        \"\"\"Get time when user's rate limit resets\"\"\"\n        if user_id not in self.users:\n            return 0.0\n        \n        user_data = self.users[user_id]\n        current_time = time.time()\n        \n        if user_data.blocked_until > current_time:\n            return user_data.blocked_until\n        \n        if user_data.requests:\n            return user_data.requests[0] + self.time_window\n        \n        return 0.0\n    \n    def cleanup_old_data(self):\n        \"\"\"Clean up old user data to prevent memory leaks\"\"\"\n        current_time = time.time()\n        cutoff_time = current_time - (self.time_window * 2)  # Keep data for 2x window\n        \n        users_to_remove = []\n        for user_id, user_data in self.users.items():\n            if (user_data.blocked_until < current_time and \n                not user_data.requests):\n                users_to_remove.append(user_id)\n            else:\n                # Clean old requests\n                user_data.requests = [req for req in user_data.requests if req > cutoff_time]\n        \n        for user_id in users_to_remove:\n            del self.users[user_id]\n\n# Global rate limiter instance\nrate_limiter = RateLimiter()\n","size_bytes":2796},"debug_last_request.py":{"content":"#!/usr/bin/env python3\nimport asyncio\nimport aiosqlite\nimport os\nimport json\n\nasync def debug_last_request():\n    \"\"\"Debug the last generation request\"\"\"\n    \n    try:\n        async with aiosqlite.connect('bot_database.db') as db:\n            # Get the latest generation\n            async with db.execute('''\n                SELECT task_id, veo_task_id, prompt, image_url, generation_type, created_at\n                FROM video_generations \n                ORDER BY created_at DESC LIMIT 1\n            ''') as cursor:\n                row = await cursor.fetchone()\n                \n                if row:\n                    task_id, veo_task_id, prompt, image_url, generation_type, created_at = row\n                    print(f\"Latest generation:\")\n                    print(f\"  Task ID: {task_id}\")\n                    print(f\"  Veo Task ID: {veo_task_id}\")\n                    print(f\"  Type: {generation_type}\")\n                    print(f\"  Prompt: {prompt}\")\n                    print(f\"  Image URL: {image_url}\")\n                    print(f\"  Created: {created_at}\")\n                    \n                    # Check if image file exists\n                    if image_url and \"attached_assets\" in image_url:\n                        # Extract local path\n                        import re\n                        path_match = re.search(r'attached_assets/[^\"]+\\.jpg', image_url)\n                        if path_match:\n                            local_path = path_match.group(0)\n                            if os.path.exists(local_path):\n                                file_size = os.path.getsize(local_path)\n                                print(f\"  ‚úÖ Image file exists: {local_path} ({file_size} bytes)\")\n                            else:\n                                print(f\"  ‚ùå Image file NOT found: {local_path}\")\n                        else:\n                            print(f\"  ‚ùå Can't extract path from URL: {image_url}\")\n                    \n                    # Check what API endpoints return for this task\n                    if veo_task_id:\n                        await test_api_response(veo_task_id)\n                else:\n                    print(\"No generations found\")\n                    \n    except Exception as e:\n        print(f\"Error: {e}\")\n\nasync def test_api_response(veo_task_id):\n    \"\"\"Test API response for task\"\"\"\n    import aiohttp\n    \n    api_key = os.getenv(\"VEO_API_KEY\")\n    if not api_key:\n        print(\"No API key available\")\n        return\n        \n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Test the main generation endpoint to see if we can get task info\n    async with aiohttp.ClientSession() as session:\n        # Try a simple API test\n        try:\n            async with session.post(\n                \"https://api.kie.ai/api/v1/veo/generate\",\n                headers=headers,\n                json={\"prompt\": \"test\"},\n                timeout=aiohttp.ClientTimeout(total=10)\n            ) as response:\n                print(f\"\\n  API Test with minimal request:\")\n                print(f\"  Status: {response.status}\")\n                text = await response.text()\n                print(f\"  Response: {text[:200]}...\")\n                \n                if response.status == 200:\n                    try:\n                        data = json.loads(text)\n                        print(f\"  ‚úÖ API is working, got: {data}\")\n                    except:\n                        pass\n                        \n        except Exception as e:\n            print(f\"  API test error: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(debug_last_request())","size_bytes":3675},"webhook_server.py":{"content":"import asyncio\nimport logging\nimport ipaddress\nimport time\nfrom collections import defaultdict\nfrom aiohttp import web, ClientSession\nfrom config import Config\nfrom database.database import db\nfrom api_integrations.veo_api import VeoAPI\nfrom api_integrations.payment_api import PaymentAPI\nfrom utils.logger import get_logger\nimport json\n\nlogger = get_logger(__name__)\nconfig = Config()\n\n# Rate limiting for webhooks (simple in-memory implementation)\nWEBHOOK_RATE_LIMITS = defaultdict(list)  # {ip: [timestamp1, timestamp2, ...]}\nWEBHOOK_RATE_LIMIT_WINDOW = 60  # seconds\nWEBHOOK_RATE_LIMIT_MAX_REQUESTS = 10  # max requests per window\n\ndef check_webhook_rate_limit(ip: str) -> bool:\n    \"\"\"Check if IP is within webhook rate limits\"\"\"\n    now = time.time()\n    \n    # Clean old timestamps\n    WEBHOOK_RATE_LIMITS[ip] = [\n        ts for ts in WEBHOOK_RATE_LIMITS[ip] \n        if now - ts < WEBHOOK_RATE_LIMIT_WINDOW\n    ]\n    \n    # Check if limit exceeded\n    if len(WEBHOOK_RATE_LIMITS[ip]) >= WEBHOOK_RATE_LIMIT_MAX_REQUESTS:\n        return False\n    \n    # Add current request\n    WEBHOOK_RATE_LIMITS[ip].append(now)\n    return True\n\n# YooKassa official IP ranges for webhook security (updated 2024)\nYOOKASSA_IP_RANGES = [\n    '185.71.76.0/27',\n    '185.71.77.0/27', \n    '77.75.153.0/25',\n    '77.75.154.0/25',\n    '77.75.154.128/25',  # Added correct range for IP 77.75.154.206 (covers .128-.255)\n    '77.75.156.11/32',\n    '77.75.156.35/32',\n    '2a02:5180:0:1509::/64',\n    '2a02:5180:0:2655::/64'\n]\n\ndef is_yookassa_ip(ip_address: str) -> bool:\n    \"\"\"Check if IP address is from YooKassa official ranges\"\"\"\n    try:\n        client_ip = ipaddress.ip_address(ip_address)\n        for ip_range in YOOKASSA_IP_RANGES:\n            if client_ip in ipaddress.ip_network(ip_range, strict=False):\n                return True\n        return False\n    except ValueError:\n        logger.error(f\"Invalid IP address format: {ip_address}\")\n        return False\n\nasync def handle_veo_callback(request):\n    \"\"\"Handle Veo API completion callbacks\"\"\"\n    try:\n        # Get task ID from URL path\n        task_id = request.match_info.get('task_id')\n        if not task_id:\n            logger.error(\"No task_id in callback URL\")\n            return web.Response(text=\"Missing task_id\", status=400)\n        \n        # Parse callback data\n        callback_data = await request.json()\n        logger.info(f\"Received Veo callback for task {task_id}: {callback_data}\")\n        \n        # Extract video information from callback\n        status = callback_data.get(\"status\", \"unknown\")\n        video_url = callback_data.get(\"video_url\") or callback_data.get(\"videoUrl\") or callback_data.get(\"url\")\n        error_message = callback_data.get(\"error\") or callback_data.get(\"message\")\n        \n        # Get user ID from database using task_id\n        async with db.get_sqlite_connection() as conn:\n            cursor = await conn.execute(\n                \"SELECT user_id FROM video_generations WHERE task_id = ?\",\n                (task_id,)\n            )\n            row = await cursor.fetchone()\n            if not row:\n                logger.error(f\"Video task not found: {task_id}\")\n                return web.Response(text=\"Task not found\", status=404)\n            \n            user_id = row[0]\n        \n        # Initialize VeoAPI for user notification\n        veo_api = VeoAPI()\n        \n        if status == \"completed\" or status == \"success\":\n            if video_url:\n                # Update database\n                await db.update_video_generation(task_id, \"completed\", video_url=video_url)\n                \n                # Notify user\n                await veo_api._notify_user_completion(user_id, video_url, task_id)\n                logger.info(f\"Video completed via callback: {task_id}\")\n            else:\n                logger.error(f\"Completed status but no video URL for task {task_id}\")\n                \n        elif status == \"failed\" or status == \"error\":\n            # Update database\n            error_msg = error_message or \"Generation failed\"\n            await db.update_video_generation(task_id, \"failed\", error_message=error_msg)\n            \n            # Notify user\n            await veo_api._notify_user_failure(user_id, error_msg)\n            logger.error(f\"Video failed via callback: {task_id} - {error_msg}\")\n        \n        return web.Response(text=\"OK\", status=200)\n        \n    except Exception as e:\n        logger.error(f\"Error handling Veo callback: {e}\")\n        return web.Response(text=\"Internal error\", status=500)\n\ndef get_real_ip(request):\n    \"\"\"Get real client IP address from request headers\"\"\"\n    # Check for forwarded IP headers (common in proxy setups)\n    forwarded_for = request.headers.get('X-Forwarded-For')\n    if forwarded_for:\n        # X-Forwarded-For can contain multiple IPs, take the first one\n        return forwarded_for.split(',')[0].strip()\n    \n    real_ip = request.headers.get('X-Real-IP')\n    if real_ip:\n        return real_ip\n    \n    # Fallback to direct connection IP\n    return request.remote\n\nasync def handle_yookassa_webhook(request):\n    \"\"\"Handle YooKassa payment webhook notifications with security checks\"\"\"\n    try:\n        # Get client IP and validate it's from YooKassa\n        client_ip = get_real_ip(request)\n        logger.info(f\"Received YooKassa webhook from IP: {client_ip}\")\n        \n        # SECURITY: Check rate limiting first\n        if not check_webhook_rate_limit(client_ip):\n            logger.warning(f\"Rate limit exceeded for webhook from IP: {client_ip}\")\n            return web.Response(text=\"Rate limit exceeded\", status=429)\n        \n        # –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏\n        logger.info(f\"Webhook request from IP: {client_ip}\")\n        logger.info(f\"Request headers: {dict(request.headers)}\")\n        \n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º IP –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ (—É–±—Ä–∞–ª–∏ –æ–±—Ö–æ–¥ –¥–ª—è localhost)\n        if not is_yookassa_ip(client_ip):\n            logger.warning(f\"Unauthorized webhook attempt from IP: {client_ip}\")\n            return web.Response(text=\"Forbidden\", status=403)\n        \n        # Get raw payload and signature for HMAC verification\n        raw_payload = await request.read()\n        signature = request.headers.get('X-Yookassa-Signature', '')\n        \n        # Parse webhook data\n        try:\n            webhook_data = await request.json()\n        except Exception as e:\n            logger.error(f\"Invalid JSON in YooKassa webhook: {e}\")\n            return web.Response(text=\"Invalid JSON\", status=400)\n        \n        logger.info(f\"Processing YooKassa webhook: {webhook_data.get('event', 'unknown')}\")\n        \n        # Process webhook using PaymentAPI with HMAC verification\n        payment_api = PaymentAPI()\n        success = await payment_api.process_yookassa_webhook(webhook_data, raw_payload, signature)\n        \n        if success:\n            logger.info(\"YooKassa webhook processed successfully\")\n        else:\n            logger.error(\"Failed to process YooKassa webhook\")\n        \n        # Always return 200 OK to YooKassa regardless of processing result\n        # This prevents them from retrying the webhook\n        return web.Response(text=\"OK\", status=200)\n        \n    except Exception as e:\n        logger.error(f\"Error handling YooKassa webhook: {e}\")\n        # Still return 200 to prevent retries\n        return web.Response(text=\"OK\", status=200)\n\nasync def init_webhook_server():\n    \"\"\"Initialize and start the webhook server\"\"\"\n    app = web.Application()\n    \n    # Add webhook routes\n    app.router.add_post('/webhook/veo-complete/{task_id}', handle_veo_callback)\n    app.router.add_post('/webhook/yookassa', handle_yookassa_webhook)\n    \n    # Health check endpoint\n    async def health(request):\n        return web.Response(text=\"OK\")\n    \n    # Root endpoint for basic connectivity\n    async def root(request):\n        return web.Response(text=\"Telegram Bot Server Running\", status=200)\n    \n    app.router.add_get('/health', health)\n    app.router.add_get('/', root)\n    \n    return app\n\nif __name__ == \"__main__\":\n    # This file is now imported by main.py, not run directly\n    print(\"This module should be imported by main.py, not run directly\")","size_bytes":8288},"utils/payment_monitor.py":{"content":"\"\"\"\nPayment monitoring utility to check successful payments and notify users\n\"\"\"\n\nimport asyncio\nfrom typing import List\nfrom datetime import datetime, timedelta\nimport re\n\nfrom api_integrations.payment_api import PaymentAPI\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass PaymentMonitor:\n    def __init__(self):\n        self.payment_api = PaymentAPI()\n        self.processed_payments = set()  # Keep track of processed payment IDs\n        self.check_interval = 15  # Check every 15 seconds for faster processing\n        \n    async def check_recent_payments(self, lookback_minutes: int = 60):\n        \"\"\"Check recent log entries for payment IDs and verify their status\"\"\"\n        try:\n            import os\n            \n            # Look for payment creation logs in recent output\n            # This is a simple approach - in production you'd store payment IDs in DB\n            \n            # Read recent logs to find payment IDs\n            payment_ids = []\n            \n            # Try to find payment IDs from recent bot activity\n            # In a real system, you'd have a proper payment tracking table\n            \n            logger.info(f\"Checking recent payments from last {lookback_minutes} minutes\")\n            \n            # Get recent payment IDs from database instead of hardcoded list\n            from database.database import db\n            \n            # Get recent payment IDs that might need checking\n            recent_payment_ids = await self.get_recent_payment_ids_from_db(lookback_minutes)\n            \n            for payment_id in recent_payment_ids:\n                if payment_id not in self.processed_payments:\n                    await self.check_and_process_payment(payment_id)\n                    \n        except Exception as e:\n            logger.error(f\"Error checking recent payments: {e}\")\n    \n    async def get_recent_payment_ids_from_db(self, lookback_minutes: int = 60) -> List[str]:\n        \"\"\"Get recent payment IDs from database that might need verification\"\"\"\n        try:\n            from database.database import db\n            from datetime import datetime, timedelta\n            \n            # Get payment IDs from recent transactions that might not be completed\n            cutoff_time = datetime.now() - timedelta(minutes=lookback_minutes)\n            \n            if db.use_postgres:\n                pool = await db.get_postgres_pool()\n                async with pool.acquire() as conn:\n                    rows = await conn.fetch(\"\"\"\n                        SELECT DISTINCT payment_id FROM transactions \n                        WHERE payment_id IS NOT NULL \n                        AND created_at > $1 \n                        AND type = 'credit_purchase'\n                        AND payment_method = 'yookassa'\n                    \"\"\", cutoff_time)\n                    \n                    return [row[0] for row in rows if row[0]]\n            else:\n                async with db.get_sqlite_connection() as conn:\n                    cursor = await conn.execute(\"\"\"\n                        SELECT DISTINCT payment_id FROM transactions \n                        WHERE payment_id IS NOT NULL \n                        AND created_at > ? \n                        AND type = 'credit_purchase'\n                        AND payment_method = 'yookassa'\n                    \"\"\", (cutoff_time.isoformat(),))\n                    \n                    rows = await cursor.fetchall()\n                    return [row[0] for row in rows if row[0]]\n                \n        except Exception as e:\n            logger.error(f\"Error getting recent payment IDs from DB: {e}\")\n            return []\n    \n    async def check_and_process_payment(self, payment_id: str):\n        \"\"\"Check specific payment and process if successful\"\"\"\n        try:\n            result = await self.payment_api.verify_yookassa_payment(payment_id)\n            \n            if result.get('paid', False):\n                # Payment is successful, check if it was already processed\n                from database.database import db\n                payment_exists = await db.payment_exists(payment_id)\n                \n                if not payment_exists:\n                    # Process the payment\n                    metadata = result.get('metadata', {})\n                    user_id = metadata.get('user_id')\n                    package_id = metadata.get('package_id')\n                    amount = result.get('amount')\n                    \n                    if user_id and package_id and amount:\n                        logger.info(f\"Processing untracked successful payment: {payment_id}\")\n                        \n                        success = await self.payment_api._process_successful_card_payment(\n                            user_id=int(user_id),\n                            package_id=package_id,\n                            payment_id=payment_id,\n                            amount=float(amount)\n                        )\n                        \n                        if success:\n                            logger.info(f\"Successfully processed payment {payment_id}\")\n                            self.processed_payments.add(payment_id)\n                        else:\n                            logger.error(f\"Failed to process payment {payment_id}\")\n                else:\n                    # Payment already processed, just mark as seen to avoid re-notifications\n                    self.processed_payments.add(payment_id)\n            else:\n                logger.info(f\"Payment {payment_id} status: {result.get('status')}\")\n                \n        except Exception as e:\n            logger.error(f\"Error checking payment {payment_id}: {e}\")\n    \n    async def start_monitoring(self):\n        \"\"\"Start the payment monitoring loop\"\"\"\n        logger.info(\"Starting payment monitoring...\")\n        \n        while True:\n            try:\n                await self.check_recent_payments()\n                await asyncio.sleep(self.check_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in payment monitoring: {e}\")\n                await asyncio.sleep(self.check_interval)\n\n# Global instance\npayment_monitor = PaymentMonitor()","size_bytes":6218},"PAYMENT_SETUP_GUIDE.md":{"content":"# üîß –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ–± –æ–ø–ª–∞—Ç–µ\n\n## üìã –ü—Ä–æ–±–ª–µ–º–∞\n–í–∞—à –±–æ—Ç –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± —É—Å–ø–µ—à–Ω—ã—Ö –æ–ø–ª–∞—Ç–∞—Ö —á–µ—Ä–µ–∑ –Æ–ö–∞—Å—Å–∞. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–æ–≤–µ—Ä—à–∞—é—Ç –ø–ª–∞—Ç–µ–∂–∏, –Ω–æ –∫—Ä–µ–¥–∏—Ç—ã –Ω–µ –∑–∞—á–∏—Å–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.\n\n## üîç –ü—Ä–∏—á–∏–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã\n1. **–ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã webhook'–∏ –≤ –Æ–ö–∞—Å—Å–∞** - –æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞\n2. **–û—à–∏–±–∫–∏ –≤ –∫–æ–¥–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø–ª–∞—Ç–µ–∂–µ–π** - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã\n3. **–ü–ª–∞—Ç–µ–∂–∏ –æ—Ç–º–µ–Ω—è—é—Ç—Å—è** - –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n\n## ‚úÖ –ü–æ—à–∞–≥–æ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ\n\n### –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—å—Ç–µ API –∫–ª—é—á–∏\n–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É –≤–∞—Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è:\n\n```bash\n# –í Replit Secrets –¥–æ–±–∞–≤—å—Ç–µ:\nYOOKASSA_API_KEY=your_api_key_here\nYOOKASSA_SHOP_ID=your_shop_id_here\n```\n\n**–ì–¥–µ –Ω–∞–π—Ç–∏ —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ:**\n1. –í–æ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –Æ–ö–∞—Å—Å–∞: https://yookassa.ru/my\n2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ **–ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí API –∫–ª—é—á–∏**\n3. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ:\n   - **Shop ID** (–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–∞–≥–∞–∑–∏–Ω–∞)\n   - **–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á** (API Key)\n\n### –®–∞–≥ 2: –ù–∞—Å—Ç—Ä–æ–π—Ç–µ webhook URL\n1. –û—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª `utils/setup_webhooks.py`\n2. –ù–∞–π–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É —Å `replit_url` (—Å—Ç—Ä–æ–∫–∞ 20)\n3. –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ URL –≤–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:\n\n```python\n# –ó–∞–º–µ–Ω–∏—Ç–µ —ç—Ç–æ:\nreplit_url = \"https://your-repl-name.your-username.repl.co\"\n\n# –ù–∞ –≤–∞—à —Ä–µ–∞–ª—å–Ω—ã–π URL, –Ω–∞–ø—Ä–∏–º–µ—Ä:\nreplit_url = \"https://telegram-bot.your-username.repl.co\"\n```\n\n**–ö–∞–∫ –Ω–∞–π—Ç–∏ –≤–∞—à URL:**\n- –û—Ç–∫—Ä–æ–π—Ç–µ –≤–∞—à Repl –≤ –±—Ä–∞—É–∑–µ—Ä–µ\n- –°–∫–æ–ø–∏—Ä—É–π—Ç–µ URL –∏–∑ –∞–¥—Ä–µ—Å–Ω–æ–π —Å—Ç—Ä–æ–∫–∏\n- –£–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ—Å–ª–µ `.repl.co`\n\n### –®–∞–≥ 3: –ó–∞–ø—É—Å—Ç–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫—É webhooks\n–í—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–º–∞–Ω–¥—ã –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ:\n\n```bash\n# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)\npip install aiohttp\n\n# –ó–∞–ø—É—Å—Ç–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫—É webhooks\npython utils/setup_webhooks.py\n```\n\n–í—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å:\n```\n‚úÖ Webhook created for event: payment.succeeded\n‚úÖ Webhook created for event: payment.canceled\n‚úÖ Webhook created for event: payment.waiting_for_capture\n‚úÖ Webhook created for event: refund.succeeded\nüéâ All webhooks configured successfully!\n```\n\n### –®–∞–≥ 4: –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ –Æ–ö–∞—Å—Å–∞\n1. –í–æ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –Æ–ö–∞—Å—Å–∞\n2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ **–ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí HTTP —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è**\n3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ webhook'–∏ –¥–æ–±–∞–≤–∏–ª–∏—Å—å —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º URL\n\n### –®–∞–≥ 5: –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞\n```bash\n# –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ workflow\npython main.py\n```\n\n## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ\n\n### 1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–±–æ—Ç—É webhook endpoint'–∞\n–û—Ç–∫—Ä–æ–π—Ç–µ –≤ –±—Ä–∞—É–∑–µ—Ä–µ: `https://your-app-url.repl.co/health`\n–î–æ–ª–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å: `OK`\n\n### 2. –¢–µ—Å—Ç–æ–≤—ã–π –ø–ª–∞—Ç–µ–∂\n1. –°–æ–∑–¥–∞–π—Ç–µ —Ç–µ—Å—Ç–æ–≤—ã–π –ø–ª–∞—Ç–µ–∂ —á–µ—Ä–µ–∑ –±–æ—Ç–∞\n2. –ü—Ä–æ—Å–ª–µ–¥–∏—Ç–µ –ª–æ–≥–∏ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç:\n   ```\n   INFO - Received YooKassa webhook from IP: [IP]\n   INFO - Processing YooKassa webhook: payment.succeeded\n   INFO - YooKassa webhook processed successfully\n   ```\n\n### 3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞\n```bash\n# –í –ª–æ–≥–∞—Ö –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å:\nINFO - Payment processed successfully: user=123, payment_id=xxx, credits=10\n```\n\n## ‚ùó –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –∏ —Ä–µ—à–µ–Ω–∏—è\n\n### –ü—Ä–æ–±–ª–µ–º–∞: \"Webhook creation error 400\"\n**–†–µ—à–µ–Ω–∏–µ:** –ü—Ä–æ–≤–µ—Ä—å—Ç–µ URL webhook'–∞ - –æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ HTTPS\n\n### –ü—Ä–æ–±–ª–µ–º–∞: \"YooKassa credentials not configured\"\n**–†–µ—à–µ–Ω–∏–µ:** \n1. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ API –∫–ª—é—á–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ Replit Secrets\n2. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\n### –ü—Ä–æ–±–ª–µ–º–∞: –ü–ª–∞—Ç–µ–∂–∏ –≤—Å–µ –µ—â–µ –æ—Ç–º–µ–Ω—è—é—Ç—Å—è\n**–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:**\n1. **–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π email –≤ —á–µ–∫–µ** - –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç—Ä–æ–∫—É 68 –≤ `payment_api.py`\n2. **–ü—Ä–æ–±–ª–µ–º—ã —Å 54-–§–ó** - —É–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —É –≤–∞—Å –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è —Ç–æ–≤–∞—Ä–∞\n3. **–¢–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º** - –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∫–ª—é—á–∏\n\n### –ü—Ä–æ–±–ª–µ–º–∞: Webhook'–∏ –Ω–µ –ø—Ä–∏—Ö–æ–¥—è—Ç\n1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á—Ç–æ –≤–∞—à Repl —Ä–∞–±–æ—Ç–∞–µ—Ç (–Ω–µ –∑–∞—Å—ã–ø–∞–µ—Ç)\n2. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –ø–æ—Ä—Ç 5000 –æ—Ç–∫—Ä—ã—Ç\n3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –Ω–∞ –æ—à–∏–±–∫–∏ –∑–∞–ø—É—Å–∫–∞ webhook —Å–µ—Ä–≤–µ—Ä–∞\n\n## üîß –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n\n### –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ Repl\n–î–æ–±–∞–≤—å—Ç–µ –≤ `main.py` keep-alive –º–µ—Ö–∞–Ω–∏–∑–º:\n```python\n# –£–∂–µ –µ—Å—Ç—å –≤ –∫–æ–¥–µ - webhook server —Ä–∞–±–æ—Ç–∞–µ—Ç 24/7\n```\n\n### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞\nPayment monitor —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–ª–∞—Ç–µ–∂–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥.\n\n## üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞\n\n–ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã –æ—Å—Ç–∞—é—Ç—Å—è:\n1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –±–æ—Ç–∞ –Ω–∞ –æ—à–∏–±–∫–∏\n2. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –≤—Å–µ environment variables —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã\n3. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π—Ç–µ webhook URL –≤—Ä—É—á–Ω—É—é\n\n**–í–∞–∂–Ω–æ:** –ü–æ—Å–ª–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ webhook'–æ–≤ –ø–ª–∞—Ç–µ–∂–∏ –¥–æ–ª–∂–Ω—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –±–µ–∑ –∑–∞–¥–µ—Ä–∂–µ–∫!","size_bytes":5813},"utils/setup_webhooks.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nUtility to setup YooKassa webhooks for payment notifications\nRun this script once to configure webhooks in your YooKassa account\n\"\"\"\n\nimport asyncio\nimport aiohttp\nimport base64\nimport json\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass YooKassaWebhookSetup:\n    def __init__(self):\n        self.yookassa_api_key = config.YOOKASSA_API_KEY\n        self.yookassa_shop_id = config.YOOKASSA_SHOP_ID\n        self.yookassa_base_url = \"https://api.yookassa.ru/v3\"\n        \n    def get_webhook_url(self):\n        \"\"\"Get the webhook URL for your Replit app\"\"\"\n        # Replace with your actual Replit app URL\n        replit_url = \"https://your-repl-name.your-username.repl.co\"  # Update this!\n        return f\"{replit_url}/webhook/yookassa\"\n    \n    async def setup_webhooks(self):\n        \"\"\"Setup webhooks for payment notifications\"\"\"\n        \n        if not self.yookassa_api_key or not self.yookassa_shop_id:\n            logger.error(\"‚ùå YooKassa credentials not configured!\")\n            logger.error(\"Please set YOOKASSA_API_KEY and YOOKASSA_SHOP_ID environment variables\")\n            return False\n            \n        webhook_url = self.get_webhook_url()\n        logger.info(f\"Setting up webhook URL: {webhook_url}\")\n        \n        # Events we want to receive notifications for\n        events = [\n            \"payment.succeeded\",\n            \"payment.canceled\", \n            \"payment.waiting_for_capture\",\n            \"refund.succeeded\"\n        ]\n        \n        success = True\n        \n        for event in events:\n            if await self.create_webhook(event, webhook_url):\n                logger.info(f\"‚úÖ Webhook created for event: {event}\")\n            else:\n                logger.error(f\"‚ùå Failed to create webhook for event: {event}\")\n                success = False\n        \n        if success:\n            logger.info(\"üéâ All webhooks configured successfully!\")\n            logger.info(\"üí° Make sure your app is running on the webhook URL\")\n        else:\n            logger.error(\"‚ö†Ô∏è Some webhooks failed to configure\")\n            \n        return success\n    \n    async def create_webhook(self, event: str, webhook_url: str) -> bool:\n        \"\"\"Create a single webhook for specific event\"\"\"\n        try:\n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\",\n                \"Idempotence-Key\": f\"webhook-{event}-setup\"\n            }\n            \n            webhook_data = {\n                \"event\": event,\n                \"url\": webhook_url\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    f\"{self.yookassa_base_url}/webhooks\",\n                    headers=headers,\n                    json=webhook_data,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status in [200, 201]:\n                        result = await response.json()\n                        logger.debug(f\"Webhook created: {result}\")\n                        return True\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"YooKassa webhook creation error {response.status}: {error_text}\")\n                        return False\n                        \n        except Exception as e:\n            logger.error(f\"Error creating webhook for {event}: {e}\")\n            return False\n    \n    async def list_webhooks(self):\n        \"\"\"List existing webhooks\"\"\"\n        try:\n            auth_string = f\"{self.yookassa_shop_id}:{self.yookassa_api_key}\"\n            auth_bytes = base64.b64encode(auth_string.encode()).decode()\n            \n            headers = {\n                \"Authorization\": f\"Basic {auth_bytes}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.get(\n                    f\"{self.yookassa_base_url}/webhooks\",\n                    headers=headers,\n                    timeout=aiohttp.ClientTimeout(total=10)\n                ) as response:\n                    \n                    if response.status == 200:\n                        result = await response.json()\n                        logger.info(\"üìã Current webhooks:\")\n                        \n                        webhooks = result.get(\"items\", [])\n                        if not webhooks:\n                            logger.info(\"   No webhooks configured\")\n                        else:\n                            for webhook in webhooks:\n                                logger.info(f\"   {webhook['event']} -> {webhook['url']}\")\n                        \n                        return webhooks\n                    else:\n                        error_text = await response.text()\n                        logger.error(f\"Error listing webhooks {response.status}: {error_text}\")\n                        return []\n                        \n        except Exception as e:\n            logger.error(f\"Error listing webhooks: {e}\")\n            return []\n\nasync def main():\n    \"\"\"Main function to run webhook setup\"\"\"\n    print(\"üîß YooKassa Webhook Setup Utility\")\n    print(\"=\" * 40)\n    \n    setup = YooKassaWebhookSetup()\n    \n    # First, list existing webhooks\n    print(\"\\nüìã Checking existing webhooks...\")\n    await setup.list_webhooks()\n    \n    # Setup new webhooks\n    print(f\"\\nüîó Setting up webhooks for URL: {setup.get_webhook_url()}\")\n    print(\"‚ö†Ô∏è  IMPORTANT: Update the webhook URL in this script with your actual Replit app URL!\")\n    \n    success = await setup.setup_webhooks()\n    \n    if success:\n        print(\"\\n‚úÖ Webhook setup completed successfully!\")\n        print(\"\\nüìù Next steps:\")\n        print(\"1. Make sure your bot is running on the webhook URL\")\n        print(\"2. Test a payment to verify webhooks work\")\n        print(\"3. Check logs for incoming webhook notifications\")\n    else:\n        print(\"\\n‚ùå Webhook setup failed!\")\n        print(\"Please check your YooKassa API credentials and try again\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":6478},"WEBHOOK_SETUP.md":{"content":"# üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Webhook URLs –¥–ª—è YooKassa\n\n## –ü—Ä–æ–±–ª–µ–º–∞\n–ü—Ä–∏ –ª–æ–∫–∞–ª—å–Ω–æ–º –∑–∞–ø—É—Å–∫–µ webhooks —Ä–∞–±–æ—Ç–∞—é—Ç, –Ω–æ –ø—Ä–∏ –¥–µ–ø–ª–æ–µ –Ω–µ –ø—Ä–∏—Ö–æ–¥—è—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–ª–∞—Ç–µ–∂–∞—Ö.\n\n## –ü—Ä–∏—á–∏–Ω–∞\nYooKassa –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç webhooks –Ω–∞ URL, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –Ω–∞—Å—Ç—Ä–æ–µ–Ω –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞. –ü—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ —Å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ –Ω–∞ –¥–µ–ø–ª–æ–π URL –º–µ–Ω—è–µ—Ç—Å—è:\n\n- **–õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫**: `https://xxx.replit.dev/webhook/yookassa`  \n- **–ü—Ä–æ–¥–∞–∫—à–Ω –¥–µ–ø–ª–æ–π**: `https://xxx.replit.app/webhook/yookassa`\n\n## ‚úÖ –†–µ—à–µ–Ω–∏–µ\n\n### 1. –£–∑–Ω–∞–π—Ç–µ URL –≤–∞—à–µ–≥–æ –¥–µ–ø–ª–æ—è\n–ü–æ—Å–ª–µ –¥–µ–ø–ª–æ—è –≤–∞—à URL –±—É–¥–µ—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ: `https://your-app-name.replit.app`\n\n### 2. –û–±–Ω–æ–≤–∏—Ç–µ Webhook URL –≤ YooKassa\n1. –í–æ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç YooKassa\n2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–∞–≥–∞–∑–∏–Ω–∞\n3. –ù–∞–π–¥–∏—Ç–µ —Ä–∞–∑–¥–µ–ª \"HTTP —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\" –∏–ª–∏ \"Webhooks\"\n4. –û–±–Ω–æ–≤–∏—Ç–µ URL –Ω–∞: `https://your-app-name.replit.app/webhook/yookassa`\n\n### 3. –í–∞–∂–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n- **–ú–µ—Ç–æ–¥**: POST\n- **–§–æ—Ä–º–∞—Ç**: JSON\n- **–°–æ–±—ã—Ç–∏—è**: `payment.succeeded`, `payment.canceled`\n\n## üîÑ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ\n–ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–¥–∏–Ω URL –¥–ª—è –≤—Å–µ—Ö –æ–∫—Ä—É–∂–µ–Ω–∏–π, –Ω–∞—Å—Ç—Ä–æ–∏–≤ –ø–µ—Ä–µ–∞–¥—Ä–µ—Å–∞—Ü–∏—é.\n\n## üìù –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ\n15-—Å–µ–∫—É–Ω–¥–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π YooKassa.","size_bytes":1658},"admin_tools/credit_manager.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n\"\"\"\nimport asyncio\nimport sys\nimport os\n\n# –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–Ω–µ–≤—É—é –ø–∞–ø–∫—É –≤ –ø—É—Ç—å\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom database.database import db, init_database\nfrom database.models import Transaction, TransactionType\n\nasync def add_credits_to_user(telegram_id: int, credits: int, description: str = \"Manual credit adjustment\"):\n    \"\"\"–î–æ–±–∞–≤–∏—Ç—å –∫—Ä–µ–¥–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\"\"\"\n    await init_database()\n    \n    # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n    user = await db.get_user(telegram_id)\n    if not user:\n        print(f\"ü§ñ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö\")\n        print(f\"üìù –°–æ–∑–¥–∞—é –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...\")\n        \n        # –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n        from database.models import User, UserStatus\n        new_user = User(\n            telegram_id=telegram_id,\n            credits=0,\n            status=UserStatus.REGULAR,\n            first_name=\"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ\",\n            username=None\n        )\n        \n        created = await db.create_user(new_user)\n        if not created:\n            print(f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\")\n            return False\n        \n        user = await db.get_user(telegram_id)\n        print(f\"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞–Ω\")\n    else:\n        print(f\"üë§ –ù–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.first_name} (@{user.username})\")\n    \n    print(f\"üí∞ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {user.credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n    \n    # –û–±–Ω–æ–≤–ª—è–µ–º –∫—Ä–µ–¥–∏—Ç—ã\n    new_credits = user.credits + credits\n    success = await db.update_user_credits(telegram_id, new_credits)\n    \n    if success:\n        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏\n        transaction = Transaction(\n            user_id=telegram_id,\n            type=TransactionType.ADMIN_GRANT,\n            amount=credits,\n            description=description\n        )\n        await db.create_transaction(transaction)\n        \n        print(f\"‚úÖ –£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ {credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n        print(f\"üí≥ –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n        return True\n    else:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n        return False\n\nasync def find_recent_payments(amount: int = 399):\n    \"\"\"–ù–∞–π—Ç–∏ –Ω–µ–¥–∞–≤–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∏ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é —Å—É–º–º—É\"\"\"\n    await init_database()\n    \n    print(f\"üîç –ü–æ–∏—Å–∫ –ø–ª–∞—Ç–µ–∂–µ–π –Ω–∞ —Å—É–º–º—É {amount} —Ä—É–±–ª–µ–π...\")\n    \n    # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –ø–æ–∏—Å–∫–∞ –ø–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º\n    # –ü–æ–∫–∞ —á—Ç–æ –ø—Ä–æ—Å—Ç–æ –≤—ã–≤–æ–¥–∏–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é\n    print(\"üí° –î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\")\n    print(\"   - Telegram ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\")\n    print(\"   - Username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\")\n\nasync def main():\n    \"\"\"–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è\"\"\"\n    if len(sys.argv) < 3:\n        print(\"üìã –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\")\n        print(f\"   python {sys.argv[0]} <telegram_id> <credits> [–æ–ø–∏—Å–∞–Ω–∏–µ]\")\n        print(\"\\nüîç –ü—Ä–∏–º–µ—Ä—ã:\")\n        print(f\"   python {sys.argv[0]} 123456789 35 '–ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è –∑–∞ –ø–∞–∫–µ—Ç 399‚ÇΩ'\")\n        print(f\"   python {sys.argv[0]} 123456789 -10 '–í–æ–∑–≤—Ä–∞—Ç –æ—à–∏–±–æ—á–Ω–æ–≥–æ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è'\")\n        return\n    \n    try:\n        telegram_id = int(sys.argv[1])\n        credits = int(sys.argv[2])\n        description = sys.argv[3] if len(sys.argv) > 3 else \"Manual credit adjustment\"\n        \n        print(f\"üéØ –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ {credits} –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {telegram_id}\")\n        \n        success = await add_credits_to_user(telegram_id, credits, description)\n        \n        if success:\n            print(\"üéâ –û–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!\")\n        else:\n            print(\"üí• –û–ø–µ—Ä–∞—Ü–∏—è –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!\")\n            \n    except ValueError:\n        print(\"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö. Telegram ID –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞–º–∏.\")\n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":4533},"admin_tools/credit_management.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–∞–º–∏ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n–†–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ production (deploy), –Ω–µ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º –∑–∞–ø—É—Å–∫–µ\n\"\"\"\n\nimport os\nimport asyncio\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any\nfrom database.database import db\nfrom database.models import User, Transaction, TransactionType, UserStatus, AdminLog\nfrom config import Config\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\nconfig = Config()\n\nclass CreditManager:\n    \"\"\"–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤\"\"\"\n    \n    def __init__(self):\n        self.is_production = self._is_production_environment()\n        \n    def _is_production_environment(self) -> bool:\n        \"\"\"–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –∑–∞–ø—É—â–µ–Ω–æ –ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≤ production (–Ω–∞ –¥–µ–ø–ª–æ–µ)\"\"\"\n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ DATABASE_URL (–æ–∑–Ω–∞—á–∞–µ—Ç Replit production)\n        database_url = os.getenv('DATABASE_URL')\n        replit_deployment = os.getenv('REPLIT_DEPLOYMENT') == '1'\n        \n        # Production –µ—Å–ª–∏ –µ—Å—Ç—å DATABASE_URL –∏–ª–∏ —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω –¥–µ–ø–ª–æ–π\n        return bool(database_url) or replit_deployment\n    \n    async def check_admin_permissions(self, admin_id: int) -> bool:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\"\"\"\n        try:\n            admin = await db.get_user(admin_id)\n            if not admin or admin.status != UserStatus.ADMIN:\n                logger.warning(f\"Unauthorized credit management attempt by user {admin_id}\")\n                return False\n            return True\n        except Exception as e:\n            logger.error(f\"Error checking admin permissions for {admin_id}: {e}\")\n            return False\n    \n    async def get_user_credits(self, admin_id: int, target_user_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –±–∞–ª–∞–Ω—Å –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n        \n        Args:\n            admin_id: ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n            target_user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏\n            \n        Returns:\n            Dict —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –∫—Ä–µ–¥–∏—Ç–∞—Ö –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ\n        \"\"\"\n        try:\n            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n            if not await self.check_admin_permissions(admin_id):\n                return {\"error\": \"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏\"}\n            \n            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ\n            user = await db.get_user(target_user_id)\n            if not user:\n                return {\"error\": f\"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω\"}\n            \n            # –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É\n            await db.log_admin_action(AdminLog(\n                admin_id=admin_id,\n                action=\"check_credits\",\n                target_user_id=target_user_id,\n                description=f\"–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_user_id}\"\n            ))\n            \n            return {\n                \"user_id\": user.telegram_id,\n                \"username\": user.username,\n                \"first_name\": user.first_name,\n                \"credits\": user.credits,\n                \"status\": user.status.value,\n                \"created_at\": user.created_at.isoformat() if user.created_at else None,\n                \"updated_at\": user.updated_at.isoformat() if user.updated_at else None\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error checking credits for user {target_user_id}: {e}\")\n            return {\"error\": f\"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫—Ä–µ–¥–∏—Ç–æ–≤: {str(e)}\"}\n    \n    async def grant_credits(self, admin_id: int, target_user_id: int, credits_amount: int, reason: str = \"\", bot=None) -> Dict[str, Any]:\n        \"\"\"\n        –í—ã–¥–∞–µ—Ç –∫—Ä–µ–¥–∏—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (—Ç–æ–ª—å–∫–æ –Ω–∞ production)\n        \n        Args:\n            admin_id: ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n            target_user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            credits_amount: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–ª—è –≤—ã–¥–∞—á–∏\n            reason: –ü—Ä–∏—á–∏–Ω–∞ –≤—ã–¥–∞—á–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤\n            \n        Returns:\n            Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –æ–ø–µ—Ä–∞—Ü–∏–∏\n        \"\"\"\n        try:\n            # –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: —Ç–æ–ª—å–∫–æ –Ω–∞ production!\n            if not self.is_production:\n                logger.warning(f\"Credit grant attempt in non-production environment by admin {admin_id}\")\n                return {\n                    \"error\": \"–í—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –Ω–∞ production (–ø–æ—Å–ª–µ deploy)\",\n                    \"environment\": \"local/development\"\n                }\n            \n            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n            if not await self.check_admin_permissions(admin_id):\n                return {\"error\": \"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏\"}\n            \n            # –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤\n            if not isinstance(credits_amount, int) or credits_amount <= 0:\n                return {\"error\": \"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —Ü–µ–ª—ã–º —á–∏—Å–ª–æ–º\"}\n            \n            if credits_amount > 1000:  # –õ–∏–º–∏—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n                return {\"error\": \"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞ —Ä–∞–∑: 1000\"}\n            \n            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            user = await db.get_user(target_user_id)\n            if not user:\n                return {\"error\": f\"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω\"}\n            \n            old_credits = user.credits\n            new_credits = old_credits + credits_amount\n            \n            # –û–±–Ω–æ–≤–ª—è–µ–º –∫—Ä–µ–¥–∏—Ç—ã\n            success = await db.update_user_credits(target_user_id, new_credits)\n            if not success:\n                return {\"error\": \"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö\"}\n            \n            # –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é\n            transaction = Transaction(\n                user_id=target_user_id,\n                type=TransactionType.ADMIN_GRANT,\n                amount=credits_amount,\n                description=f\"–í—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º {admin_id}. –ü—Ä–∏—á–∏–Ω–∞: {reason or '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}\",\n                created_at=datetime.now()\n            )\n            \n            await db.create_transaction(transaction)\n            \n            # –õ–æ–≥–∏—Ä—É–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n            await db.log_admin_action(AdminLog(\n                admin_id=admin_id,\n                action=\"grant_credits\",\n                target_user_id=target_user_id,\n                description=f\"–í—ã–¥–∞–Ω–æ {credits_amount} –∫—Ä–µ–¥–∏—Ç–æ–≤. –ë–∞–ª–∞–Ω—Å: {old_credits} ‚Üí {new_credits}. –ü—Ä–∏—á–∏–Ω–∞: {reason}\"\n            ))\n            \n            logger.info(f\"Admin {admin_id} granted {credits_amount} credits to user {target_user_id}. Balance: {old_credits} ‚Üí {new_credits}\")\n            \n            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, –µ—Å–ª–∏ –µ—Å—Ç—å –±–æ—Ç\n            if bot:\n                try:\n                    notification_text = f\"\"\"\nüéâ <b>–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω—ã –∫—Ä–µ–¥–∏—Ç—ã!</b>\n\nüíé <b>–ü–æ–ª—É—á–µ–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤:</b> {credits_amount}\nüí∞ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {new_credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\n\nüìù <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n{reason if reason else '–ë–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è'}\n\n–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å {new_credits // 10} –≤–∏–¥–µ–æ!\n                    \"\"\"\n                    \n                    await bot.send_message(target_user_id, notification_text)\n                    logger.info(f\"Notification sent to user {target_user_id} about credit grant\")\n                except Exception as e:\n                    logger.warning(f\"Failed to send notification to user {target_user_id}: {e}\")\n            \n            return {\n                \"success\": True,\n                \"user_id\": target_user_id,\n                \"credits_granted\": credits_amount,\n                \"old_balance\": old_credits,\n                \"new_balance\": new_credits,\n                \"reason\": reason,\n                \"timestamp\": datetime.now().isoformat(),\n                \"notification_sent\": bot is not None\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error granting credits to user {target_user_id}: {e}\")\n            return {\"error\": f\"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–¥–∞—á–µ –∫—Ä–µ–¥–∏—Ç–æ–≤: {str(e)}\"}\n\n# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–µ–Ω–µ–¥–∂–µ—Ä–∞\ncredit_manager = CreditManager()\n\nasync def check_user_credits(admin_id: int, user_id: int) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    –ü—É–±–ª–∏—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n    \n    Args:\n        admin_id: ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏\n        \n    Returns:\n        –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫—Ä–µ–¥–∏—Ç–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n    \"\"\"\n    return await credit_manager.get_user_credits(admin_id, user_id)\n\nasync def grant_user_credits(admin_id: int, user_id: int, credits: int, reason: str = \"\", bot=None) -> Dict[str, Any]:\n    \"\"\"\n    –ü—É–±–ª–∏—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–¥–∞—á–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\n    –†–ê–ë–û–¢–ê–ï–¢ –¢–û–õ–¨–ö–û –ù–ê PRODUCTION!\n    \n    Args:\n        admin_id: ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n        credits: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤\n        reason: –ü—Ä–∏—á–∏–Ω–∞ –≤—ã–¥–∞—á–∏\n        \n    Returns:\n        –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏\n    \"\"\"\n    return await credit_manager.grant_credits(admin_id, user_id, credits, reason, bot)\n\n# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø—Ä–∏ deploy\nasync def emergency_credit_restore(admin_id: int, user_id: int, credits: int, payment_id: str = \"\", bot=None) -> Dict[str, Any]:\n    \"\"\"\n    –≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä–µ–¥–∏—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ—Å–ª–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º)\n    \n    Args:\n        admin_id: ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n        credits: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤\n        payment_id: ID –ø–ª–∞—Ç–µ–∂–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)\n        \n    Returns:\n        –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏\n    \"\"\"\n    reason = f\"–≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä–µ–¥–∏—Ç–æ–≤\"\n    if payment_id:\n        reason += f\" –¥–ª—è –ø–ª–∞—Ç–µ–∂–∞ {payment_id}\"\n    \n    return await grant_user_credits(admin_id, user_id, credits, reason, bot)\n\nif __name__ == \"__main__\":\n    # –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)\n    async def main():\n        print(\"üîí Credit Management System\")\n        print(f\"Production mode: {credit_manager.is_production}\")\n        \n        if credit_manager.is_production:\n            print(\"‚úÖ –°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ –≤—ã–¥–∞—á–µ –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n        else:\n            print(\"‚ö†Ô∏è  –õ–æ–∫–∞–ª—å–Ω–∞—è —Å—Ä–µ–¥–∞ - –≤—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞\")\n    \n    asyncio.run(main())","size_bytes":11830},"admin_tools/deploy_credit_tools.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –≤—ã–¥–∞—á–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø—Ä–∏ deploy\n–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∫—Ä–µ–¥–∏—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n\"\"\"\n\nimport asyncio\nimport sys\nfrom typing import List, Dict, Any\nfrom credit_management import check_user_credits, grant_user_credits, emergency_credit_restore\nfrom database.database import db, init_database\nfrom config import Config\n\nconfig = Config()\n\nclass DeployCreditTools:\n    \"\"\"–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫—Ä–µ–¥–∏—Ç–∞–º–∏ –ø—Ä–∏ deploy\"\"\"\n    \n    def __init__(self):\n        self.admin_id = config.ADMIN_USER_ID\n        \n    async def batch_check_credits(self, user_ids: List[int]) -> Dict[int, Dict[str, Any]]:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫—Ä–µ–¥–∏—Ç—ã –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\"\"\"\n        results = {}\n        \n        print(f\"üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–µ–¥–∏—Ç—ã {len(user_ids)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...\")\n        \n        for user_id in user_ids:\n            try:\n                result = await check_user_credits(self.admin_id, user_id)\n                results[user_id] = result\n                \n                if \"error\" not in result:\n                    print(f\"üë§ {user_id}: {result['credits']} –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n                else:\n                    print(f\"‚ùå {user_id}: {result['error']}\")\n                    \n            except Exception as e:\n                print(f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ {user_id}: {e}\")\n                results[user_id] = {\"error\": str(e)}\n        \n        return results\n    \n    async def batch_grant_credits(self, credit_assignments: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        –ú–∞—Å—Å–æ–≤–∞—è –≤—ã–¥–∞—á–∞ –∫—Ä–µ–¥–∏—Ç–æ–≤\n        \n        Args:\n            credit_assignments: —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π —Å –∫–ª—é—á–∞–º–∏:\n                - user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n                - credits: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–µ–¥–∏—Ç–æ–≤\n                - reason: –ø—Ä–∏—á–∏–Ω–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)\n                - payment_id: ID –ø–ª–∞—Ç–µ–∂–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)\n        \"\"\"\n        results = {\n            \"success\": [],\n            \"failed\": [],\n            \"total_credits_granted\": 0\n        }\n        \n        print(f\"üí∞ –ù–∞—á–∏–Ω–∞–µ–º –º–∞—Å—Å–æ–≤—É—é –≤—ã–¥–∞—á—É –∫—Ä–µ–¥–∏—Ç–æ–≤ –¥–ª—è {len(credit_assignments)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...\")\n        \n        for assignment in credit_assignments:\n            user_id = assignment.get(\"user_id\")\n            credits = assignment.get(\"credits\")\n            reason = assignment.get(\"reason\", \"–ú–∞—Å—Å–æ–≤–∞—è –≤—ã–¥–∞—á–∞ –ø—Ä–∏ deploy\")\n            payment_id = assignment.get(\"payment_id\", \"\")\n            \n            if not user_id or not credits:\n                print(f\"‚ùå –ü—Ä–æ–ø—É—Å–∫ –Ω–µ–≤–µ—Ä–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è: {assignment}\")\n                results[\"failed\"].append({\n                    \"assignment\": assignment,\n                    \"error\": \"–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç user_id –∏–ª–∏ credits\"\n                })\n                continue\n            \n            try:\n                if payment_id:\n                    result = await emergency_credit_restore(self.admin_id, user_id, credits, payment_id)\n                else:\n                    result = await grant_user_credits(self.admin_id, user_id, credits, reason)\n                \n                if result.get(\"success\"):\n                    print(f\"‚úÖ {user_id}: +{credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n                    results[\"success\"].append(result)\n                    results[\"total_credits_granted\"] += credits\n                else:\n                    print(f\"‚ùå {user_id}: {result.get('error', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}\")\n                    results[\"failed\"].append({\n                        \"user_id\": user_id,\n                        \"credits\": credits,\n                        \"error\": result.get(\"error\")\n                    })\n                    \n            except Exception as e:\n                print(f\"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–¥–∞—á–µ –∫—Ä–µ–¥–∏—Ç–æ–≤ {user_id}: {e}\")\n                results[\"failed\"].append({\n                    \"user_id\": user_id,\n                    \"credits\": credits,\n                    \"error\": str(e)\n                })\n        \n        print(f\"\\nüìä –ò—Ç–æ–≥–∏ –º–∞—Å—Å–æ–≤–æ–π –≤—ã–¥–∞—á–∏:\")\n        print(f\"‚úÖ –£—Å–ø–µ—à–Ω–æ: {len(results['success'])}\")\n        print(f\"‚ùå –û—à–∏–±–æ–∫: {len(results['failed'])}\")\n        print(f\"üí∞ –í—Å–µ–≥–æ –≤—ã–¥–∞–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤: {results['total_credits_granted']}\")\n        \n        return results\n    \n    async def restore_lost_payment(self, user_id: int, credits: int, payment_id: str) -> Dict[str, Any]:\n        \"\"\"–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∫—Ä–µ–¥–∏—Ç—ã –¥–ª—è –ø–æ—Ç–µ—Ä—è–Ω–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞\"\"\"\n        print(f\"üö® –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ç–µ—Ä—è–Ω–Ω—ã–π –ø–ª–∞—Ç–µ–∂...\")\n        print(f\"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id}\")\n        print(f\"üí∞ –ö—Ä–µ–¥–∏—Ç—ã: {credits}\")\n        print(f\"üí≥ –ü–ª–∞—Ç–µ–∂: {payment_id}\")\n        \n        result = await emergency_credit_restore(self.admin_id, user_id, credits, payment_id)\n        \n        if result.get(\"success\"):\n            print(f\"‚úÖ –£–°–ü–ï–®–ù–û! –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {credits} –∫—Ä–µ–¥–∏—Ç–æ–≤\")\n        else:\n            print(f\"‚ùå –û–®–ò–ë–ö–ê: {result.get('error')}\")\n        \n        return result\n\nasync def main():\n    \"\"\"–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\"\"\"\n    print(\"üöÄ Deploy Credit Tools\")\n    print(\"=\" * 40)\n    \n    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö\n    await init_database()\n    \n    tools = DeployCreditTools()\n    \n    if len(sys.argv) < 2:\n        print(\"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\")\n        print(\"  python deploy_credit_tools.py check <user_id>\")\n        print(\"  python deploy_credit_tools.py grant <user_id> <credits> [reason]\")\n        print(\"  python deploy_credit_tools.py restore <user_id> <credits> <payment_id>\")\n        return\n    \n    command = sys.argv[1].lower()\n    \n    if command == \"check\" and len(sys.argv) >= 3:\n        user_id = int(sys.argv[2])\n        result = await check_user_credits(config.ADMIN_USER_ID, user_id)\n        print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {result}\")\n        \n    elif command == \"grant\" and len(sys.argv) >= 4:\n        user_id = int(sys.argv[2])\n        credits = int(sys.argv[3])\n        reason = sys.argv[4] if len(sys.argv) > 4 else \"Deploy credit grant\"\n        \n        result = await grant_user_credits(config.ADMIN_USER_ID, user_id, credits, reason)\n        print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {result}\")\n        \n    elif command == \"restore\" and len(sys.argv) >= 5:\n        user_id = int(sys.argv[2])\n        credits = int(sys.argv[3])\n        payment_id = sys.argv[4]\n        \n        result = await tools.restore_lost_payment(user_id, credits, payment_id)\n        print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {result}\")\n        \n    else:\n        print(\"‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":7174},"auto_migrate.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –º–∏–≥—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–µ–ø–ª–æ–µ\n–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ build –ø—Ä–æ—Ü–µ—Å—Å–µ\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport os\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\n# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - AUTO-MIGRATE - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# –ò–º–ø–æ—Ä—Ç asyncpg —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω\ntry:\n    import asyncpg\n    POSTGRES_AVAILABLE = True\nexcept ImportError:\n    POSTGRES_AVAILABLE = False\n\nclass AutoMigrator:\n    def __init__(self):\n        self.sqlite_path = \"bot_database.db\"\n        self.postgres_url = os.getenv('DATABASE_URL')\n        \n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–µ–¥—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è\n        self.is_deployment = os.getenv('REPLIT_DEPLOYMENT') == '1'\n        \n        logger.info(f\"AutoMigrator initialized:\")\n        logger.info(f\"  - Is deployment: {self.is_deployment}\")\n        logger.info(f\"  - PostgreSQL available: {POSTGRES_AVAILABLE}\")\n        logger.info(f\"  - DATABASE_URL present: {bool(self.postgres_url)}\")\n        logger.info(f\"  - SQLite file exists: {os.path.exists(self.sqlite_path)}\")\n    \n    async def should_migrate(self) -> bool:\n        \"\"\"–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω—É–∂–Ω–æ –ª–∏ –¥–µ–ª–∞—Ç—å –º–∏–≥—Ä–∞—Ü–∏—é\"\"\"\n        # –ú–∏–≥—Ä–∞—Ü–∏—è –Ω—É–∂–Ω–∞ –µ—Å–ª–∏:\n        # 1. –≠—Ç–æ deployment —Å—Ä–µ–¥–∞\n        # 2. –ï—Å—Ç—å PostgreSQL\n        # 3. –ï—Å—Ç—å SQLite —Ñ–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏\n        # 4. PostgreSQL –±–∞–∑–∞ –ø—É—Å—Ç–∞—è –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –º–µ–Ω—å—à–µ –¥–∞–Ω–Ω—ã—Ö\n        \n        if not self.is_deployment:\n            logger.info(\"Not in deployment - skipping migration\")\n            return False\n            \n        if not POSTGRES_AVAILABLE or not self.postgres_url:\n            logger.info(\"PostgreSQL not available - skipping migration\")\n            return False\n            \n        if not os.path.exists(self.sqlite_path):\n            logger.info(\"No SQLite file found - skipping migration\")\n            return False\n        \n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ SQLite\n        sqlite_users = await self.count_sqlite_users()\n        if sqlite_users == 0:\n            logger.info(\"No users in SQLite - skipping migration\")\n            return False\n        \n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ PostgreSQL\n        postgres_users = await self.count_postgres_users()\n        \n        logger.info(f\"Users count: SQLite={sqlite_users}, PostgreSQL={postgres_users}\")\n        \n        # –ú–∏–≥—Ä–∏—Ä—É–µ–º –µ—Å–ª–∏ –≤ SQLite –±–æ–ª—å—à–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n        should_migrate = sqlite_users > postgres_users\n        \n        if should_migrate:\n            logger.info(\"Migration needed - SQLite has more data\")\n        else:\n            logger.info(\"Migration not needed - PostgreSQL is up to date\")\n            \n        return should_migrate\n    \n    async def count_sqlite_users(self) -> int:\n        \"\"\"–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ SQLite\"\"\"\n        try:\n            async with aiosqlite.connect(self.sqlite_path) as db:\n                cursor = await db.execute(\"SELECT COUNT(*) FROM users\")\n                result = await cursor.fetchone()\n                return result[0] if result else 0\n        except Exception as e:\n            logger.warning(f\"Could not count SQLite users: {e}\")\n            return 0\n    \n    async def count_postgres_users(self) -> int:\n        \"\"\"–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ PostgreSQL\"\"\"\n        try:\n            conn = await asyncpg.connect(self.postgres_url)\n            try:\n                # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç\n                await self.create_postgres_tables(conn)\n                result = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n                return result if result else 0\n            finally:\n                await conn.close()\n        except Exception as e:\n            logger.warning(f\"Could not count PostgreSQL users: {e}\")\n            return 0\n    \n    async def create_postgres_tables(self, conn):\n        \"\"\"–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –≤ PostgreSQL\"\"\"\n        # Users table  \n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                telegram_id BIGINT PRIMARY KEY,\n                username TEXT,\n                first_name TEXT,\n                last_name TEXT,\n                credits INTEGER DEFAULT 0,\n                status TEXT DEFAULT 'regular',\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Transactions table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS transactions (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                type TEXT NOT NULL,\n                amount INTEGER NOT NULL,\n                description TEXT,\n                payment_method TEXT,\n                payment_id TEXT UNIQUE,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Video generations table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS video_generations (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                task_id TEXT UNIQUE,\n                veo_task_id TEXT,\n                prompt TEXT NOT NULL,\n                generation_type TEXT NOT NULL,\n                image_url TEXT,\n                model TEXT DEFAULT 'veo3_fast',\n                aspect_ratio TEXT DEFAULT '16:9',\n                status TEXT DEFAULT 'pending',\n                video_url TEXT,\n                error_message TEXT,\n                credits_spent INTEGER DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                completed_at TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Admin logs table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS admin_logs (\n                id SERIAL PRIMARY KEY,\n                admin_id BIGINT,\n                action TEXT NOT NULL,\n                target_user_id BIGINT,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Create indexes\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_payment_id ON transactions(payment_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_task_id ON video_generations(task_id)')\n    \n    async def migrate_data(self):\n        \"\"\"–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –º–∏–≥—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö\"\"\"\n        logger.info(\"Starting automatic data migration...\")\n        \n        try:\n            # –≠–∫—Å–ø–æ—Ä—Ç –∏–∑ SQLite\n            data = await self.export_sqlite_data()\n            \n            if not any(data.values()):\n                logger.warning(\"No data to migrate!\")\n                return\n            \n            # –ò–º–ø–æ—Ä—Ç –≤ PostgreSQL\n            await self.import_to_postgres(data)\n            \n            logger.info(\"‚úÖ Automatic migration completed successfully!\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Migration failed: {e}\")\n            # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –¥–µ–ø–ª–æ–π –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ –º–∏–≥—Ä–∞—Ü–∏–∏\n            pass\n    \n    async def export_sqlite_data(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ SQLite\"\"\"\n        logger.info(\"Exporting data from SQLite...\")\n        \n        data = {\n            'users': [],\n            'transactions': [],\n            'video_generations': [],\n            'admin_logs': []\n        }\n        \n        async with aiosqlite.connect(self.sqlite_path) as db:\n            # –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n            async with db.execute(\"SELECT * FROM users\") as cursor:\n                async for row in cursor:\n                    data['users'].append({\n                        'telegram_id': row[0],\n                        'username': row[1],\n                        'first_name': row[2],\n                        'last_name': row[3],\n                        'credits': row[4],\n                        'status': row[5],\n                        'created_at': row[6],\n                        'updated_at': row[7]\n                    })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n            async with db.execute(\"SELECT * FROM transactions\") as cursor:\n                async for row in cursor:\n                    data['transactions'].append({\n                        'user_id': row[1],\n                        'type': row[2],\n                        'amount': row[3],\n                        'description': row[4],\n                        'payment_method': row[5],\n                        'payment_id': row[6],\n                        'created_at': row[7]\n                    })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n            async with db.execute(\"SELECT * FROM video_generations\") as cursor:\n                async for row in cursor:\n                    data['video_generations'].append({\n                        'user_id': row[1],\n                        'task_id': row[2],\n                        'veo_task_id': row[3] if len(row) > 3 else None,\n                        'prompt': row[4] if len(row) > 4 else row[3],\n                        'generation_type': row[5] if len(row) > 5 else row[4],\n                        'image_url': row[6] if len(row) > 6 else row[5],\n                        'model': row[7] if len(row) > 7 else row[6],\n                        'aspect_ratio': row[8] if len(row) > 8 else row[7],\n                        'status': row[9] if len(row) > 9 else row[8],\n                        'video_url': row[10] if len(row) > 10 else row[9],\n                        'error_message': row[11] if len(row) > 11 else row[10],\n                        'credits_spent': row[12] if len(row) > 12 else row[11],\n                        'created_at': row[13] if len(row) > 13 else row[12],\n                        'completed_at': row[14] if len(row) > 14 else row[13]\n                    })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\n            try:\n                async with db.execute(\"SELECT * FROM admin_logs\") as cursor:\n                    async for row in cursor:\n                        data['admin_logs'].append({\n                            'admin_id': row[1],\n                            'action': row[2],\n                            'target_user_id': row[3],\n                            'description': row[4],\n                            'created_at': row[5]\n                        })\n            except Exception as e:\n                logger.warning(f\"Could not export admin_logs: {e}\")\n        \n        logger.info(f\"Exported: {len(data['users'])} users, \"\n                   f\"{len(data['transactions'])} transactions, \"\n                   f\"{len(data['video_generations'])} videos, \"\n                   f\"{len(data['admin_logs'])} admin logs\")\n        \n        return data\n    \n    async def import_to_postgres(self, data: Dict[str, List[Dict[str, Any]]]):\n        \"\"\"–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ PostgreSQL\"\"\"\n        logger.info(\"Importing data to PostgreSQL...\")\n        \n        conn = await asyncpg.connect(self.postgres_url)\n        try:\n            # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã\n            await self.create_postgres_tables(conn)\n            \n            # –ò–º–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n            for user in data['users']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                        ON CONFLICT (telegram_id) DO UPDATE SET\n                        username = EXCLUDED.username,\n                        first_name = EXCLUDED.first_name,\n                        last_name = EXCLUDED.last_name,\n                        credits = EXCLUDED.credits,\n                        status = EXCLUDED.status,\n                        updated_at = EXCLUDED.updated_at\n                    ''', \n                        user['telegram_id'],\n                        user['username'],\n                        user['first_name'],\n                        user['last_name'],\n                        user['credits'],\n                        user['status'],\n                        datetime.fromisoformat(user['created_at']) if isinstance(user['created_at'], str) else user['created_at'],\n                        datetime.fromisoformat(user['updated_at']) if isinstance(user['updated_at'], str) else user['updated_at']\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import user {user['telegram_id']}: {e}\")\n            \n            # –ò–º–ø–æ—Ä—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n            for transaction in data['transactions']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                        ON CONFLICT (payment_id) DO NOTHING\n                    ''', \n                        transaction['user_id'],\n                        transaction['type'],\n                        transaction['amount'],\n                        transaction['description'],\n                        transaction['payment_method'],\n                        transaction['payment_id'],\n                        datetime.fromisoformat(transaction['created_at']) if isinstance(transaction['created_at'], str) else transaction['created_at']\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import transaction: {e}\")\n            \n            # –ò–º–ø–æ—Ä—Ç –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n            for video in data['video_generations']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, video_url, error_message, credits_spent, created_at, completed_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\n                        ON CONFLICT (task_id) DO NOTHING\n                    ''', \n                        video['user_id'],\n                        video['task_id'],\n                        video['veo_task_id'],\n                        video['prompt'],\n                        video['generation_type'],\n                        video['image_url'],\n                        video['model'],\n                        video['aspect_ratio'],\n                        video['status'],\n                        video['video_url'],\n                        video['error_message'],\n                        video['credits_spent'],\n                        datetime.fromisoformat(video['created_at']) if isinstance(video['created_at'], str) else video['created_at'],\n                        datetime.fromisoformat(video['completed_at']) if isinstance(video['completed_at'], str) and video['completed_at'] else None\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import video generation: {e}\")\n            \n            # –ò–º–ø–æ—Ä—Ç –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\n            for log in data['admin_logs']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES ($1, $2, $3, $4, $5)\n                    ''', \n                        log['admin_id'],\n                        log['action'],\n                        log['target_user_id'],\n                        log['description'],\n                        datetime.fromisoformat(log['created_at']) if isinstance(log['created_at'], str) else log['created_at']\n                    )\n                except Exception as e:\n                    logger.warning(f\"Failed to import admin log: {e}\")\n                    \n        finally:\n            await conn.close()\n        \n        logger.info(\"PostgreSQL import completed\")\n\nasync def main():\n    \"\"\"–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –º–∏–≥—Ä–∞—Ü–∏–∏\"\"\"\n    migrator = AutoMigrator()\n    \n    if await migrator.should_migrate():\n        await migrator.migrate_data()\n    else:\n        logger.info(\"Migration not needed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":17365},"database_migration.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nDatabase Migration Tool\n–ü–µ—Ä–µ–Ω–æ—Å–∏—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ SQLite (development) –≤ PostgreSQL (production)\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport asyncpg\nimport logging\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\n# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass DatabaseMigrator:\n    def __init__(self):\n        self.sqlite_path = \"bot_database.db\"\n        self.postgres_url = os.getenv('DATABASE_URL')\n        \n        if not self.postgres_url:\n            raise ValueError(\"DATABASE_URL environment variable is required\")\n    \n    async def export_sqlite_data(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ SQLite\"\"\"\n        logger.info(\"–ù–∞—á–∏–Ω–∞–µ–º —ç–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ SQLite...\")\n        \n        data = {\n            'users': [],\n            'transactions': [],\n            'video_generations': [],\n            'admin_logs': []\n        }\n        \n        if not os.path.exists(self.sqlite_path):\n            logger.warning(f\"SQLite —Ñ–∞–π–ª {self.sqlite_path} –Ω–µ –Ω–∞–π–¥–µ–Ω!\")\n            return data\n        \n        async with aiosqlite.connect(self.sqlite_path) as db:\n            # –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n            async with db.execute(\"SELECT * FROM users\") as cursor:\n                async for row in cursor:\n                    data['users'].append({\n                        'telegram_id': row[0],\n                        'username': row[1],\n                        'first_name': row[2],\n                        'last_name': row[3],\n                        'credits': row[4],\n                        'status': row[5],\n                        'created_at': row[6],\n                        'updated_at': row[7]\n                    })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n            async with db.execute(\"SELECT * FROM transactions\") as cursor:\n                async for row in cursor:\n                    data['transactions'].append({\n                        'id': row[0],\n                        'user_id': row[1],\n                        'type': row[2],\n                        'amount': row[3],\n                        'description': row[4],\n                        'payment_method': row[5],\n                        'payment_id': row[6],\n                        'created_at': row[7]\n                    })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n            async with db.execute(\"SELECT * FROM video_generations\") as cursor:\n                async for row in cursor:\n                    data['video_generations'].append({\n                        'id': row[0],\n                        'user_id': row[1],\n                        'task_id': row[2],\n                        'veo_task_id': row[3] if len(row) > 3 else None,\n                        'prompt': row[4] if len(row) > 4 else row[3],\n                        'generation_type': row[5] if len(row) > 5 else row[4],\n                        'image_url': row[6] if len(row) > 6 else row[5],\n                        'model': row[7] if len(row) > 7 else row[6],\n                        'aspect_ratio': row[8] if len(row) > 8 else row[7],\n                        'status': row[9] if len(row) > 9 else row[8],\n                        'video_url': row[10] if len(row) > 10 else row[9],\n                        'error_message': row[11] if len(row) > 11 else row[10],\n                        'credits_spent': row[12] if len(row) > 12 else row[11],\n                        'created_at': row[13] if len(row) > 13 else row[12],\n                        'completed_at': row[14] if len(row) > 14 else row[13]\n                    })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –ª–æ–≥–æ–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n            try:\n                async with db.execute(\"SELECT * FROM admin_logs\") as cursor:\n                    async for row in cursor:\n                        data['admin_logs'].append({\n                            'id': row[0],\n                            'admin_id': row[1],\n                            'action': row[2],\n                            'target_user_id': row[3],\n                            'description': row[4],\n                            'created_at': row[5]\n                        })\n            except Exception as e:\n                logger.warning(f\"–ù–µ —É–¥–∞–ª–æ—Å—å —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å admin_logs: {e}\")\n        \n        logger.info(f\"–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {len(data['users'])} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, \"\n                   f\"{len(data['transactions'])} —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π, \"\n                   f\"{len(data['video_generations'])} –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π, \"\n                   f\"{len(data['admin_logs'])} –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\")\n        \n        return data\n    \n    async def import_to_postgres(self, data: Dict[str, List[Dict[str, Any]]]):\n        \"\"\"–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ PostgreSQL\"\"\"\n        logger.info(\"–ù–∞—á–∏–Ω–∞–µ–º –∏–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ PostgreSQL...\")\n        \n        try:\n            conn = await asyncpg.connect(self.postgres_url)\n            \n            # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç\n            await self.create_postgres_tables(conn)\n            \n            # –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)\n            response = input(\"–û—á–∏—Å—Ç–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ –≤ PostgreSQL? (y/N): \")\n            if response.lower() == 'y':\n                await conn.execute(\"DELETE FROM admin_logs\")\n                await conn.execute(\"DELETE FROM video_generations\") \n                await conn.execute(\"DELETE FROM transactions\")\n                await conn.execute(\"DELETE FROM users\")\n                logger.info(\"–°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã\")\n            \n            # –ò–º–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n            for user in data['users']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n                        ON CONFLICT (telegram_id) DO UPDATE SET\n                        username = EXCLUDED.username,\n                        first_name = EXCLUDED.first_name,\n                        last_name = EXCLUDED.last_name,\n                        credits = EXCLUDED.credits,\n                        status = EXCLUDED.status,\n                        updated_at = EXCLUDED.updated_at\n                    ''', \n                        user['telegram_id'],\n                        user['username'],\n                        user['first_name'],\n                        user['last_name'],\n                        user['credits'],\n                        user['status'],\n                        datetime.fromisoformat(user['created_at']) if isinstance(user['created_at'], str) else user['created_at'],\n                        datetime.fromisoformat(user['updated_at']) if isinstance(user['updated_at'], str) else user['updated_at']\n                    )\n                except Exception as e:\n                    logger.error(f\"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user['telegram_id']}: {e}\")\n            \n            # –ò–º–ø–æ—Ä—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n            for transaction in data['transactions']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7)\n                        ON CONFLICT (payment_id) DO NOTHING\n                    ''', \n                        transaction['user_id'],\n                        transaction['type'],\n                        transaction['amount'],\n                        transaction['description'],\n                        transaction['payment_method'],\n                        transaction['payment_id'],\n                        datetime.fromisoformat(transaction['created_at']) if isinstance(transaction['created_at'], str) else transaction['created_at']\n                    )\n                except Exception as e:\n                    logger.error(f\"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}\")\n            \n            # –ò–º–ø–æ—Ä—Ç –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n            for video in data['video_generations']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO video_generations \n                        (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, video_url, error_message, credits_spent, created_at, completed_at)\n                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\n                        ON CONFLICT (task_id) DO NOTHING\n                    ''', \n                        video['user_id'],\n                        video['task_id'],\n                        video['veo_task_id'],\n                        video['prompt'],\n                        video['generation_type'],\n                        video['image_url'],\n                        video['model'],\n                        video['aspect_ratio'],\n                        video['status'],\n                        video['video_url'],\n                        video['error_message'],\n                        video['credits_spent'],\n                        datetime.fromisoformat(video['created_at']) if isinstance(video['created_at'], str) else video['created_at'],\n                        datetime.fromisoformat(video['completed_at']) if isinstance(video['completed_at'], str) and video['completed_at'] else None\n                    )\n                except Exception as e:\n                    logger.error(f\"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}\")\n            \n            # –ò–º–ø–æ—Ä—Ç –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\n            for log in data['admin_logs']:\n                try:\n                    await conn.execute('''\n                        INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                        VALUES ($1, $2, $3, $4, $5)\n                    ''', \n                        log['admin_id'],\n                        log['action'],\n                        log['target_user_id'],\n                        log['description'],\n                        datetime.fromisoformat(log['created_at']) if isinstance(log['created_at'], str) else log['created_at']\n                    )\n                except Exception as e:\n                    logger.error(f\"–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –∞–¥–º–∏–Ω –ª–æ–≥–∞: {e}\")\n            \n            await conn.close()\n            logger.info(\"–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ PostgreSQL –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!\")\n            \n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL: {e}\")\n            raise\n    \n    async def create_postgres_tables(self, conn):\n        \"\"\"–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –≤ PostgreSQL\"\"\"\n        # Users table  \n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                telegram_id BIGINT PRIMARY KEY,\n                username TEXT,\n                first_name TEXT,\n                last_name TEXT,\n                credits INTEGER DEFAULT 0,\n                status TEXT DEFAULT 'regular',\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Transactions table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS transactions (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                type TEXT NOT NULL,\n                amount INTEGER NOT NULL,\n                description TEXT,\n                payment_method TEXT,\n                payment_id TEXT UNIQUE,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Video generations table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS video_generations (\n                id SERIAL PRIMARY KEY,\n                user_id BIGINT,\n                task_id TEXT UNIQUE,\n                veo_task_id TEXT,\n                prompt TEXT NOT NULL,\n                generation_type TEXT NOT NULL,\n                image_url TEXT,\n                model TEXT DEFAULT 'veo3_fast',\n                aspect_ratio TEXT DEFAULT '16:9',\n                status TEXT DEFAULT 'pending',\n                video_url TEXT,\n                error_message TEXT,\n                credits_spent INTEGER DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                completed_at TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Admin logs table\n        await conn.execute('''\n            CREATE TABLE IF NOT EXISTS admin_logs (\n                id SERIAL PRIMARY KEY,\n                admin_id BIGINT,\n                action TEXT NOT NULL,\n                target_user_id BIGINT,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Create indexes\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_transactions_payment_id ON transactions(payment_id)')\n        await conn.execute('CREATE INDEX IF NOT EXISTS idx_video_generations_task_id ON video_generations(task_id)')\n    \n    async def migrate(self):\n        \"\"\"–ü–æ–ª–Ω–∞—è –º–∏–≥—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö\"\"\"\n        try:\n            # –≠–∫—Å–ø–æ—Ä—Ç –∏–∑ SQLite\n            data = await self.export_sqlite_data()\n            \n            if not any(data.values()):\n                logger.warning(\"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–∏–≥—Ä–∞—Ü–∏–∏!\")\n                return\n            \n            # –ò–º–ø–æ—Ä—Ç –≤ PostgreSQL\n            await self.import_to_postgres(data)\n            \n            # –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏ SQLite\n            import shutil\n            backup_name = f\"bot_database_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db\"\n            shutil.copy2(self.sqlite_path, backup_name)\n            logger.info(f\"–°–æ–∑–¥–∞–Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è SQLite: {backup_name}\")\n            \n            logger.info(\"üéâ –ú–∏–≥—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!\")\n            \n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ –º–∏–≥—Ä–∞—Ü–∏–∏: {e}\")\n            raise\n\nasync def main():\n    \"\"\"–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è\"\"\"\n    print(\"=\" * 60)\n    print(\"üîÑ –ò–ù–°–¢–†–£–ú–ï–ù–¢ –ú–ò–ì–†–ê–¶–ò–ò –ë–ê–ó–´ –î–ê–ù–ù–´–•\")\n    print(\"=\" * 60)\n    print(\"–≠—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç –ø–µ—Ä–µ–Ω–µ—Å–µ—Ç –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ SQLite (development)\")\n    print(\"–≤ PostgreSQL (production) –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.\")\n    print()\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ DATABASE_URL\n    if not os.getenv('DATABASE_URL'):\n        print(\"‚ùå –û—à–∏–±–∫–∞: DATABASE_URL –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!\")\n        print(\"–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ production —Å—Ä–µ–¥–µ.\")\n        return\n    \n    response = input(\"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –º–∏–≥—Ä–∞—Ü–∏—é? (y/N): \")\n    if response.lower() != 'y':\n        print(\"–ú–∏–≥—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.\")\n        return\n    \n    try:\n        migrator = DatabaseMigrator()\n        await migrator.migrate()\n        \n        print()\n        print(\"=\" * 60)\n        print(\"‚úÖ –ú–ò–ì–†–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê –£–°–ü–ï–®–ù–û!\")\n        print(\"=\" * 60)\n        print(\"–¢–µ–ø–µ—Ä—å –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ production –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.\")\n        print(\"–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π.\")\n        \n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ –º–∏–≥—Ä–∞—Ü–∏–∏: {e}\")\n        print(\"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É –∑–∞ –ø–æ–º–æ—â—å—é.\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":16626},"deploy_setup.sh":{"content":"#!/bin/bash\n\necho \"üöÄ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –ù–ê–°–¢–†–û–ô–ö–ê –î–ï–ü–õ–û–Ø\"\necho \"==================================\"\n\n# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π\necho \"üì¶ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏...\"\npip install -q aiogram aiosqlite aiohttp\n\n# –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–µ–¥—É\nif [ \"$REPLIT_DEPLOYMENT\" = \"1\" ]; then\n    echo \"üåç –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ deployment —Å—Ä–µ–¥–∞\"\n    \n    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º PostgreSQL –¥—Ä–∞–π–≤–µ—Ä\n    echo \"üêò –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º PostgreSQL –¥—Ä–∞–π–≤–µ—Ä...\"\n    pip install -q asyncpg\n    \n    # –ó–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –º–∏–≥—Ä–∞—Ü–∏—é\n    echo \"üîÑ –ó–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –º–∏–≥—Ä–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö...\"\n    python auto_migrate.py\n    \n    echo \"‚úÖ –î–µ–ø–ª–æ–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω —É—Å–ø–µ—à–Ω–æ!\"\nelse\n    echo \"üè† –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ development —Å—Ä–µ–¥–∞\"\n    echo \"‚ÑπÔ∏è  –ú–∏–≥—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ –ø—Ä–∏ –¥–µ–ø–ª–æ–µ\"\nfi\n\necho \"‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\"","size_bytes":1046},"force_postgres.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ PostgreSQL –≤ deployed —Å—Ä–µ–¥–µ\n\"\"\"\n\nimport asyncio\nimport os\nimport logging\nfrom database.database import Database\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def force_postgres_connection():\n    \"\"\"–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å PostgreSQL –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ\"\"\"\n    \n    print(\"üîß –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û–ï –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –ù–ê POSTGRESQL\")\n    print(\"=\" * 50)\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è\n    database_url = os.getenv('DATABASE_URL')\n    replit_deployment = os.getenv('REPLIT_DEPLOYMENT')\n    \n    print(f\"REPLIT_DEPLOYMENT: {replit_deployment}\")\n    print(f\"DATABASE_URL –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç: {'–î–ê' if database_url else '–ù–ï–¢'}\")\n    \n    if not database_url:\n        print(\"‚ùå DATABASE_URL –Ω–µ –Ω–∞–π–¥–µ–Ω!\")\n        return False\n    \n    # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º asyncpg –µ—Å–ª–∏ –Ω—É–∂–Ω–æ\n    try:\n        import asyncpg\n        print(\"‚úÖ asyncpg –¥–æ—Å—Ç—É–ø–µ–Ω\")\n    except ImportError:\n        print(\"üì¶ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º asyncpg...\")\n        import subprocess\n        subprocess.run([\"pip\", \"install\", \"asyncpg\"], check=True)\n        import asyncpg\n        print(\"‚úÖ asyncpg —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n    \n    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ\n    try:\n        conn = await asyncpg.connect(database_url)\n        \n        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞–Ω–Ω—ã–µ\n        user_count = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n        print(f\"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ PostgreSQL: {user_count}\")\n        \n        if user_count > 0:\n            users = await conn.fetch(\"SELECT telegram_id, credits FROM users LIMIT 5\")\n            for user in users:\n                print(f\"   - User {user['telegram_id']}: {user['credits']} credits\")\n        \n        await conn.close()\n        print(\"‚úÖ PostgreSQL –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–∞–µ—Ç!\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå –û—à–∏–±–∫–∞ PostgreSQL: {e}\")\n        return False\n\nasync def test_database_selection():\n    \"\"\"–¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–∞–∫—É—é –±–∞–∑—É –≤—ã–±–∏—Ä–∞–µ—Ç —Å–∏—Å—Ç–µ–º–∞\"\"\"\n    \n    print(\"\\nüîç –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –í–´–ë–û–†–ê –ë–ê–ó–´ –î–ê–ù–ù–´–•\")\n    print(\"=\" * 50)\n    \n    # –°–æ–∑–¥–∞–µ–º Database –æ–±—ä–µ–∫—Ç\n    db = Database()\n    \n    print(f\"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –≤—ã–±—Ä–∞–Ω–∞: {'PostgreSQL' if db.use_postgres else 'SQLite'}\")\n    print(f\"DATABASE_URL –Ω–∞—Å—Ç—Ä–æ–µ–Ω: {'–î–ê' if db.database_url else '–ù–ï–¢'}\")\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ\n    if db.use_postgres:\n        try:\n            user = await db.get_user(1864913930)  # Admin user\n            if user:\n                print(f\"‚úÖ –ù–∞–π–¥–µ–Ω admin: {user.credits} credits\")\n                return True\n            else:\n                print(\"‚ùå Admin –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω\")\n                return False\n        except Exception as e:\n            print(f\"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}\")\n            return False\n    else:\n        print(\"‚ùå –°–∏—Å—Ç–µ–º–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç PostgreSQL\")\n        return False\n\nasync def main():\n    \"\"\"–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è\"\"\"\n    \n    # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º PostgreSQL\n    postgres_ok = await force_postgres_connection()\n    \n    # –®–∞–≥ 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã–±–æ—Ä –±–∞–∑—ã\n    db_selection_ok = await test_database_selection()\n    \n    print(\"\\nüìã –ò–¢–û–ì:\")\n    print(\"=\" * 50)\n    \n    if postgres_ok and db_selection_ok:\n        print(\"üéâ –í–°–Å –†–ê–ë–û–¢–ê–ï–¢! Deployed –±–æ—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç PostgreSQL\")\n        print(\"üì± –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∏–¥–Ω—ã –≤ –±–æ—Ç–µ\")\n    elif postgres_ok and not db_selection_ok:\n        print(\"‚ö†Ô∏è  PostgreSQL —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ —Å–∏—Å—Ç–µ–º–∞ –≤—ã–±–∏—Ä–∞–µ—Ç SQLite\")\n        print(\"üîß –ù—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –≤—ã–±–æ—Ä–∞ –±–∞–∑—ã\")\n    else:\n        print(\"‚ùå PostgreSQL –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç\")\n        print(\"üîß –ù—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ DATABASE_URL\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":4341},"migrate_data.sh":{"content":"#!/bin/bash\n\necho \"üîÑ –ë–´–°–¢–†–ê–Ø –ú–ò–ì–†–ê–¶–ò–Ø –î–ê–ù–ù–´–•\"\necho \"================================\"\necho \"–≠—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç –ø–µ—Ä–µ–Ω–µ—Å–µ—Ç –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ SQLite –≤ PostgreSQL\"\necho \"\"\n\n# –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º—ã –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ä–µ–¥–µ\nif [ -z \"$DATABASE_URL\" ]; then\n    echo \"‚ùå –û–®–ò–ë–ö–ê: DATABASE_URL –Ω–µ –Ω–∞–π–¥–µ–Ω!\"\n    echo \"–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –∑–∞–ø—É—Å–∫–∞–µ—Ç–µ —ç—Ç–æ –≤ production (deployed) —Å—Ä–µ–¥–µ.\"\n    echo \"\"\n    echo \"–ß—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –º–∏–≥—Ä–∞—Ü–∏—é:\"\n    echo \"1. –ù–∞–∂–º–∏—Ç–µ 'Deploy' –≤ Replit\"\n    echo \"2. –û—Ç–∫—Ä–æ–π—Ç–µ –∫–æ–Ω—Å–æ–ª—å –≤ deployed –≤–µ—Ä—Å–∏–∏\"\n    echo \"3. –ó–∞–ø—É—Å—Ç–∏—Ç–µ: bash migrate_data.sh\"\n    exit 1\nfi\n\n# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ\necho \"üì¶ –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏...\"\npip install asyncpg aiosqlite > /dev/null 2>&1\n\n# –ó–∞–ø—É—Å–∫–∞–µ–º –º–∏–≥—Ä–∞—Ü–∏—é\necho \"üöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –º–∏–≥—Ä–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö...\"\npython database_migration.py\n\necho \"\"\necho \"‚úÖ –ì–æ—Ç–æ–≤–æ! –¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π.\"","size_bytes":1181},"sync_from_production.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ Production (PostgreSQL) –≤ Development (SQLite)\n–î–ª—è —É–¥–æ–±–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ –ª–æ–∫–∞–ª—å–Ω–æ\n\"\"\"\n\nimport asyncio\nimport aiosqlite\nimport asyncpg\nimport os\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Any\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass ProductionSync:\n    def __init__(self):\n        self.sqlite_path = \"bot_database.db\"\n        self.postgres_url = os.getenv('DATABASE_URL')\n        \n        if not self.postgres_url:\n            raise ValueError(\"‚ùå DATABASE_URL –Ω–µ –Ω–∞–π–¥–µ–Ω! –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ PostgreSQL –Ω–∞—Å—Ç—Ä–æ–µ–Ω.\")\n    \n    async def export_from_postgres(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ PostgreSQL\"\"\"\n        logger.info(\"üì§ –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ Production PostgreSQL...\")\n        \n        data = {\n            'users': [],\n            'transactions': [],\n            'video_generations': [],\n            'admin_logs': []\n        }\n        \n        try:\n            conn = await asyncpg.connect(self.postgres_url)\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n            rows = await conn.fetch(\"SELECT * FROM users ORDER BY created_at\")\n            for row in rows:\n                data['users'].append({\n                    'telegram_id': row['telegram_id'],\n                    'username': row['username'],\n                    'first_name': row['first_name'],\n                    'last_name': row['last_name'],\n                    'credits': row['credits'],\n                    'status': row['status'],\n                    'created_at': row['created_at'],\n                    'updated_at': row['updated_at']\n                })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n            rows = await conn.fetch(\"SELECT * FROM transactions ORDER BY created_at\")\n            for row in rows:\n                data['transactions'].append({\n                    'user_id': row['user_id'],\n                    'type': row['type'],\n                    'amount': row['amount'],\n                    'description': row['description'],\n                    'payment_method': row['payment_method'],\n                    'payment_id': row['payment_id'],\n                    'created_at': row['created_at']\n                })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n            rows = await conn.fetch(\"SELECT * FROM video_generations ORDER BY created_at\")\n            for row in rows:\n                data['video_generations'].append({\n                    'user_id': row['user_id'],\n                    'task_id': row['task_id'],\n                    'veo_task_id': row['veo_task_id'],\n                    'prompt': row['prompt'],\n                    'generation_type': row['generation_type'],\n                    'image_url': row['image_url'],\n                    'model': row['model'],\n                    'aspect_ratio': row['aspect_ratio'],\n                    'status': row['status'],\n                    'video_url': row['video_url'],\n                    'error_message': row['error_message'],\n                    'credits_spent': row['credits_spent'],\n                    'created_at': row['created_at'],\n                    'completed_at': row['completed_at']\n                })\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\n            try:\n                rows = await conn.fetch(\"SELECT * FROM admin_logs ORDER BY created_at\")\n                for row in rows:\n                    data['admin_logs'].append({\n                        'admin_id': row['admin_id'],\n                        'action': row['action'],\n                        'target_user_id': row['target_user_id'],\n                        'description': row['description'],\n                        'created_at': row['created_at']\n                    })\n            except Exception as e:\n                logger.warning(f\"–ù–µ —É–¥–∞–ª–æ—Å—å —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å admin_logs: {e}\")\n            \n            await conn.close()\n            \n            logger.info(f\"‚úÖ –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {len(data['users'])} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, \"\n                       f\"{len(data['transactions'])} —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π, \"\n                       f\"{len(data['video_generations'])} –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π, \"\n                       f\"{len(data['admin_logs'])} –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏–∑ PostgreSQL: {e}\")\n            raise\n        \n        return data\n    \n    async def import_to_sqlite(self, data: Dict[str, List[Dict[str, Any]]]):\n        \"\"\"–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ SQLite\"\"\"\n        logger.info(\"üì• –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ Development SQLite...\")\n        \n        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª\n        if os.path.exists(self.sqlite_path):\n            os.remove(self.sqlite_path)\n            logger.info(\"üóëÔ∏è –£–¥–∞–ª–µ–Ω —Å—Ç–∞—Ä—ã–π SQLite —Ñ–∞–π–ª\")\n        \n        async with aiosqlite.connect(self.sqlite_path) as db:\n            # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã\n            await self.create_sqlite_tables(db)\n            \n            # –ò–º–ø–æ—Ä—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n            for user in data['users']:\n                await db.execute('''\n                    INSERT INTO users (telegram_id, username, first_name, last_name, credits, status, created_at, updated_at)\n                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n                ''', (\n                    user['telegram_id'],\n                    user['username'],\n                    user['first_name'],\n                    user['last_name'],\n                    user['credits'],\n                    user['status'],\n                    user['created_at'].isoformat() if user['created_at'] else None,\n                    user['updated_at'].isoformat() if user['updated_at'] else None\n                ))\n            \n            # –ò–º–ø–æ—Ä—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π\n            for transaction in data['transactions']:\n                await db.execute('''\n                    INSERT INTO transactions (user_id, type, amount, description, payment_method, payment_id, created_at)\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\n                ''', (\n                    transaction['user_id'],\n                    transaction['type'],\n                    transaction['amount'],\n                    transaction['description'],\n                    transaction['payment_method'],\n                    transaction['payment_id'],\n                    transaction['created_at'].isoformat() if transaction['created_at'] else None\n                ))\n            \n            # –ò–º–ø–æ—Ä—Ç –≤–∏–¥–µ–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n            for video in data['video_generations']:\n                await db.execute('''\n                    INSERT INTO video_generations \n                    (user_id, task_id, veo_task_id, prompt, generation_type, image_url, model, aspect_ratio, status, video_url, error_message, credits_spent, created_at, completed_at)\n                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n                ''', (\n                    video['user_id'],\n                    video['task_id'],\n                    video['veo_task_id'],\n                    video['prompt'],\n                    video['generation_type'],\n                    video['image_url'],\n                    video['model'],\n                    video['aspect_ratio'],\n                    video['status'],\n                    video['video_url'],\n                    video['error_message'],\n                    video['credits_spent'],\n                    video['created_at'].isoformat() if video['created_at'] else None,\n                    video['completed_at'].isoformat() if video['completed_at'] else None\n                ))\n            \n            # –ò–º–ø–æ—Ä—Ç –∞–¥–º–∏–Ω –ª–æ–≥–æ–≤\n            for log in data['admin_logs']:\n                await db.execute('''\n                    INSERT INTO admin_logs (admin_id, action, target_user_id, description, created_at)\n                    VALUES (?, ?, ?, ?, ?)\n                ''', (\n                    log['admin_id'],\n                    log['action'],\n                    log['target_user_id'],\n                    log['description'],\n                    log['created_at'].isoformat() if log['created_at'] else None\n                ))\n            \n            await db.commit()\n            logger.info(\"‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ SQLite!\")\n    \n    async def create_sqlite_tables(self, db):\n        \"\"\"–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –≤ SQLite\"\"\"\n        # Users table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                telegram_id INTEGER PRIMARY KEY,\n                username TEXT,\n                first_name TEXT,\n                last_name TEXT,\n                credits INTEGER DEFAULT 0,\n                status TEXT DEFAULT 'regular',\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Transactions table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS transactions (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                user_id INTEGER,\n                type TEXT NOT NULL,\n                amount INTEGER NOT NULL,\n                description TEXT,\n                payment_method TEXT,\n                payment_id TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Video generations table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS video_generations (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                user_id INTEGER,\n                task_id TEXT UNIQUE,\n                veo_task_id TEXT,\n                prompt TEXT NOT NULL,\n                generation_type TEXT NOT NULL,\n                image_url TEXT,\n                model TEXT DEFAULT 'veo3_fast',\n                aspect_ratio TEXT DEFAULT '16:9',\n                status TEXT DEFAULT 'pending',\n                video_url TEXT,\n                error_message TEXT,\n                credits_spent INTEGER DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                completed_at TIMESTAMP,\n                FOREIGN KEY (user_id) REFERENCES users (telegram_id)\n            )\n        ''')\n        \n        # Admin logs table\n        await db.execute('''\n            CREATE TABLE IF NOT EXISTS admin_logs (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                admin_id INTEGER,\n                action TEXT NOT NULL,\n                target_user_id INTEGER,\n                description TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                FOREIGN KEY (admin_id) REFERENCES users (telegram_id)\n            )\n        ''')\n    \n    async def sync(self):\n        \"\"\"–ü–æ–ª–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö\"\"\"\n        try:\n            print(\"üîÑ –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø –î–ê–ù–ù–´–• –ò–ó PRODUCTION\")\n            print(\"=\" * 50)\n            \n            # –≠–∫—Å–ø–æ—Ä—Ç –∏–∑ PostgreSQL\n            data = await self.export_from_postgres()\n            \n            if not any(data.values()):\n                logger.warning(\"‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ PostgreSQL!\")\n                return\n            \n            # –ò–º–ø–æ—Ä—Ç –≤ SQLite\n            await self.import_to_sqlite(data)\n            \n            print(\"=\" * 50)\n            print(\"üéâ –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê –£–°–ü–ï–®–ù–û!\")\n            print(\"=\" * 50)\n            print(\"–¢–µ–ø–µ—Ä—å –≤–∞—à–∏ production –¥–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ development —Å—Ä–µ–¥–µ.\")\n            print(\"–ú–æ–∂–µ—Ç–µ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–∏–º–∏ –ª–æ–∫–∞–ª—å–Ω–æ —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå –û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {e}\")\n            print(f\"\\n‚ùå –û—à–∏–±–∫–∞: {e}\")\n            print(\"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É –∑–∞ –ø–æ–º–æ—â—å—é.\")\n\nasync def main():\n    \"\"\"–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è\"\"\"\n    sync = ProductionSync()\n    await sync.sync()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":12654},"test_db_connection.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n–¢–µ—Å—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö\n\"\"\"\nimport asyncio\nimport os\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def test_connection():\n    print(\"üîç –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø –ö –ë–ê–ó–ï –î–ê–ù–ù–´–•\")\n    print(\"=\" * 50)\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è\n    database_url = os.getenv('DATABASE_URL')\n    print(f\"DATABASE_URL: {'–ù–∞—Å—Ç—Ä–æ–µ–Ω ‚úÖ' if database_url else '–ù–ï –Ω–∞—Å—Ç—Ä–æ–µ–Ω ‚ùå'}\")\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–º–ø–æ—Ä—Ç asyncpg\n    try:\n        import asyncpg\n        print(\"asyncpg: –î–æ—Å—Ç—É–ø–µ–Ω ‚úÖ\")\n        postgres_available = True\n    except ImportError:\n        print(\"asyncpg: –ù–ï –¥–æ—Å—Ç—É–ø–µ–Ω ‚ùå\")\n        postgres_available = False\n    \n    # –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ Database –æ–±—ä–µ–∫—Ç–∞\n    from database.database import Database\n    db = Database()\n    \n    print(f\"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –≤—ã–±—Ä–∞–Ω–∞: {'PostgreSQL ‚úÖ' if db.use_postgres else 'SQLite ‚ùå'}\")\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL\n    if db.use_postgres and postgres_available and database_url:\n        try:\n            import asyncpg\n            conn = await asyncpg.connect(database_url)\n            \n            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ PostgreSQL\n            result = await conn.fetchval(\"SELECT COUNT(*) FROM users\")\n            print(f\"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ PostgreSQL: {result}\")\n            \n            users = await conn.fetch(\"SELECT telegram_id, credits FROM users\")\n            for user in users:\n                print(f\"  - User {user['telegram_id']}: {user['credits']} credits\")\n            \n            await conn.close()\n            print(\"–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL: –†–ê–ë–û–¢–ê–ï–¢ ‚úÖ\")\n            \n        except Exception as e:\n            print(f\"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ PostgreSQL: {e} ‚ùå\")\n    \n    # –ü—Ä–æ–≤–µ—Ä—è–µ–º SQLite\n    import aiosqlite\n    sqlite_path = \"bot_database.db\"\n    \n    if os.path.exists(sqlite_path):\n        print(f\"SQLite —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {sqlite_path}\")\n        \n        try:\n            async with aiosqlite.connect(sqlite_path) as sqlite_db:\n                cursor = await sqlite_db.execute(\"SELECT COUNT(*) FROM users\")\n                result = await cursor.fetchone()\n                print(f\"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ SQLite: {result[0] if result else 0}\")\n        except Exception as e:\n            print(f\"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è SQLite: {e}\")\n    else:\n        print(\"SQLite —Ñ–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç\")\n    \n    print(\"=\" * 50)\n    print(\"üéØ –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø:\")\n    \n    if db.use_postgres:\n        print(\"‚úÖ –°–∏—Å—Ç–µ–º–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ –Ω–∞ PostgreSQL\")\n        print(\"üì± –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ deployed –±–æ—Ç–∞ –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π\")\n    else:\n        print(\"‚ùå –°–∏—Å—Ç–µ–º–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç SQLite –≤–º–µ—Å—Ç–æ PostgreSQL\") \n        print(\"üîß –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ DATABASE_URL –≤ deployed —Å—Ä–µ–¥–µ\")\n\nif __name__ == \"__main__\":\n    asyncio.run(test_connection())","size_bytes":3220},"utils/async_logger.py":{"content":"\"\"\"\n–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏\n\"\"\"\nimport asyncio\nimport logging\nimport threading\nfrom queue import Queue\nfrom typing import Optional\n\n\nclass AsyncLogHandler(logging.Handler):\n    \"\"\"–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ª–æ–≥–æ–≤ –¥–ª—è –≤—ã—Å–æ–∫–∏—Ö –Ω–∞–≥—Ä—É–∑–æ–∫\"\"\"\n    \n    def __init__(self, base_handler: logging.Handler):\n        super().__init__()\n        self.base_handler = base_handler\n        self.log_queue = Queue()\n        self.running = True\n        \n        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤\n        self.log_thread = threading.Thread(target=self._log_worker, daemon=True)\n        self.log_thread.start()\n    \n    def emit(self, record):\n        \"\"\"–î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏\"\"\"\n        if self.running:\n            self.log_queue.put(record)\n    \n    def _log_worker(self):\n        \"\"\"–§–æ–Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –∑–∞–ø–∏—Å–∏ –ª–æ–≥–æ–≤\"\"\"\n        while self.running:\n            try:\n                record = self.log_queue.get(timeout=1)\n                if record is None:  # –°–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è\n                    break\n                self.base_handler.emit(record)\n                self.log_queue.task_done()\n            except:\n                # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø–æ—Ç–æ–∫–µ\n                pass\n    \n    def close(self):\n        \"\"\"–ó–∞–∫—Ä—ã—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫\"\"\"\n        self.running = False\n        self.log_queue.put(None)  # –°–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è\n        self.log_thread.join(timeout=5)\n        self.base_handler.close()\n        super().close()\n\n\ndef setup_async_logging():\n    \"\"\"–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ\"\"\"\n    # –ü–æ–ª—É—á–∏—Ç—å root logger\n    root_logger = logging.getLogger()\n    \n    # –ó–∞–º–µ–Ω–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –Ω–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏\n    for handler in root_logger.handlers[:]:\n        async_handler = AsyncLogHandler(handler)\n        async_handler.setLevel(handler.level)\n        async_handler.setFormatter(handler.formatter)\n        \n        root_logger.removeHandler(handler)\n        root_logger.addHandler(async_handler)","size_bytes":2314},"utils/cache_manager.py":{"content":"\"\"\"\n–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∫—ç—à–∞ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏\n\"\"\"\nimport time\nfrom typing import Any, Dict, Optional, TypeVar, Generic\nimport asyncio\nfrom functools import wraps\n\nT = TypeVar('T')\n\nclass CacheManager(Generic[T]):\n    \"\"\"–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∫—ç—à–∞ —Å TTL\"\"\"\n    \n    def __init__(self, default_ttl: int = 300):\n        self.cache: Dict[str, Dict[str, Any]] = {}\n        self.default_ttl = default_ttl\n        self._lock = asyncio.Lock()\n    \n    def _is_expired(self, entry: Dict[str, Any]) -> bool:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∏—Å—Ç–µ–∫ –ª–∏ –∫—ç—à\"\"\"\n        return time.time() - entry['timestamp'] > entry['ttl']\n    \n    async def get(self, key: str) -> Optional[T]:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –∫—ç—à–∞\"\"\"\n        async with self._lock:\n            if key in self.cache:\n                entry = self.cache[key]\n                if not self._is_expired(entry):\n                    return entry['value']\n                else:\n                    # –£–¥–∞–ª–∏—Ç—å –∏—Å—Ç–µ–∫—à—É—é –∑–∞–ø–∏—Å—å\n                    del self.cache[key]\n            return None\n    \n    async def set(self, key: str, value: T, ttl: Optional[int] = None) -> None:\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫—ç—à\"\"\"\n        async with self._lock:\n            self.cache[key] = {\n                'value': value,\n                'timestamp': time.time(),\n                'ttl': ttl or self.default_ttl\n            }\n    \n    async def delete(self, key: str) -> None:\n        \"\"\"–£–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –∫—ç—à–∞\"\"\"\n        async with self._lock:\n            if key in self.cache:\n                del self.cache[key]\n    \n    async def clear(self) -> None:\n        \"\"\"–û—á–∏—Å—Ç–∏—Ç—å –≤–µ—Å—å –∫—ç—à\"\"\"\n        async with self._lock:\n            self.cache.clear()\n    \n    async def cleanup_expired(self) -> int:\n        \"\"\"–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–µ–∫—à–∏–µ –∑–∞–ø–∏—Å–∏ –∏ –≤–µ—Ä–Ω—É—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö\"\"\"\n        expired_keys = []\n        async with self._lock:\n            for key, entry in self.cache.items():\n                if self._is_expired(entry):\n                    expired_keys.append(key)\n            \n            for key in expired_keys:\n                del self.cache[key]\n        \n        return len(expired_keys)\n    \n    def size(self) -> int:\n        \"\"\"–†–∞–∑–º–µ—Ä –∫—ç—à–∞\"\"\"\n        return len(self.cache)\n\n\ndef cached(ttl: int = 300, key_prefix: str = \"\"):\n    \"\"\"–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π\"\"\"\n    def decorator(func):\n        cache = CacheManager(ttl)\n        \n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # –°–æ–∑–¥–∞—Ç—å –∫–ª—é—á –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤\n            cache_key = f\"{key_prefix}{func.__name__}_{hash(str(args) + str(sorted(kwargs.items())))}\"\n            \n            # –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫—ç—à–∞\n            cached_result = await cache.get(cache_key)\n            if cached_result is not None:\n                return cached_result\n            \n            # –í—ã–ø–æ–ª–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –∏ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n            result = await func(*args, **kwargs)\n            await cache.set(cache_key, result)\n            return result\n        \n        # –î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—ç—à–µ–º –∫ —Ñ—É–Ω–∫—Ü–∏–∏\n        wrapper.cache_clear = cache.clear\n        wrapper.cache_info = lambda: {\"size\": cache.size()}\n        \n        return wrapper\n    return decorator\n\n\n# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∫—ç—à–∞\nuser_cache = CacheManager(ttl=300)  # 5 –º–∏–Ω—É—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\nstats_cache = CacheManager(ttl=600)  # 10 –º–∏–Ω—É—Ç –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏","size_bytes":3858}},"version":1}